public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; final byte [] bigBytes = bigInt . toByteArray () ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { context . eof = true ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
lr_8 ) ; } }
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NonVoidMethodCallMutator]MSP[S] return false ; } } return true ; }
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR1Mutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOD2Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR3Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI3Mutator]MSP[N] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[N] break; default:
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI4Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[IncrementsMutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR3Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR3Mutator]MSP[N] len -- ; } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.ABSMutator]MSP[N] } break;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[N] final int savedPos = context . pos ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[experimental.SwitchMutator]MSP[N] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR6Mutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI2Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI1Mutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.ABSMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[N] } } } }
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[MathMutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.ABSMutator]MSP[N] } break; default:
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[InlineConstantMutator]MSP[N] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI4Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[MathMutator]MSP[N] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static boolean isBase64 ( final byte octet ) {
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { MST[rv.ROR5Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break; default:
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.UOI2Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.ABSMutator]MSP[N] context . eof = true ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; MST[rv.AOR2Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[N] switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR1Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.AOD2Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[NegateConditionalsMutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.ABSMutator]MSP[N]
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
switch ( context . modulus ) { MST[rv.UOI4Mutator]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.OBBN2Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI4Mutator]MSP[N] b += 256 ; }
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[N]
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.UOI2Mutator]MSP[N] if ( b == pad ) { context . eof = true ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[ConditionalsBoundaryMutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR6Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[ArgumentPropagationMutator]MSP[N] }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR3Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.ABSMutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { context . eof = true ; MST[InlineConstantMutator]MSP[N] }
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[N] } } } }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR5Mutator]MSP[N]
switch ( context . modulus ) { MST[rv.UOI1Mutator]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR5Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR4Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( context . eof && context . modulus != 0 ) { MST[NegateConditionalsMutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.UOI1Mutator]MSP[N] b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.AOD2Mutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[InlineConstantMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ROR3Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR2Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[MathMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[experimental.MemberVariableMutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.ROR5Mutator]MSP[N] context . eof = true ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.ABSMutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[N]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[rv.ABSMutator]MSP[N] context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[MathMutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR2Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR2Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[rv.UOI2Mutator]MSP[N] final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI2Mutator]MSP[N] if ( b < 0 ) { b += 256 ; }
if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[experimental.MemberVariableMutator]MSP[N] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[ReturnValsMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR3Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[MathMutator]MSP[N] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR1Mutator]MSP[N] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR3Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.ABSMutator]MSP[N] if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[InlineConstantMutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[NegateConditionalsMutator]MSP[N] context . eof = true ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[N] break; default:
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[N] } } } }
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR6Mutator]MSP[N] len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[rv.UOI2Mutator]MSP[N] context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[NegateConditionalsMutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR4Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI2Mutator]MSP[N] return resizedBytes ; } @Override
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[N] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR5Mutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.UOI1Mutator]MSP[N] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[rv.UOI3Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.CRCR6Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[NegateConditionalsMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[rv.ABSMutator]MSP[N] final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI4Mutator]MSP[N] } break; default:
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[IncrementsMutator]MSP[N] if ( b < 0 ) { b += 256 ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[InlineConstantMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[ReturnValsMutator]MSP[N] } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.OBBN1Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI2Mutator]MSP[N]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ROR5Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[InlineConstantMutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR4Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } } return true ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.AOR4Mutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI1Mutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N]
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI4Mutator]MSP[N] } break;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.UOI3Mutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR3Mutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR2Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR5Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; MST[NullReturnValsMutator]MSP[S] } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI4Mutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR3Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI4Mutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR5Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( len > maxResultSize ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR3Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR1Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI3Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD2Mutator]MSP[N]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR5Mutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR5Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[S]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.UOI4Mutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.ROR2Mutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[S] lr_5 + lr_6 +
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[ConstructorCallMutator]MSP[S] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[NullReturnValsMutator]MSP[S] }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR4Mutator]MSP[N] }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ABSMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[NegateConditionalsMutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI4Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[N]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } } return true ; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI3Mutator]MSP[N] return resizedBytes ; } @Override
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.CRCR5Mutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[experimental.MemberVariableMutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR5Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( len > maxResultSize ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI3Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; MST[NullReturnValsMutator]MSP[N] } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NegateConditionalsMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI1Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[N]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI4Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
switch ( context . modulus ) { MST[experimental.SwitchMutator]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI1Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI3Mutator]MSP[N] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[N] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR4Mutator]MSP[N] context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOD1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR5Mutator]MSP[N] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[MathMutator]MSP[N] break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI4Mutator]MSP[N] context . eof = true ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI1Mutator]MSP[N] context . eof = true ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR1Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI2Mutator]MSP[S] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR5Mutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[InlineConstantMutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ; MST[rv.UOI2Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR4Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[S] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( len > maxResultSize ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[MathMutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[S] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI1Mutator]MSP[N]
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI1Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[N]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ; MST[rv.CRCR3Mutator]MSP[N]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[ArgumentPropagationMutator]MSP[N] }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.ABSMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[NullReturnValsMutator]MSP[N] }
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI4Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR1Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI1Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR2Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR2Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI4Mutator]MSP[N] return resizedBytes ; } @Override
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[MathMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR1Mutator]MSP[S] final byte [] bigBytes = bigInt . toByteArray () ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[N] } break;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] }
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR4Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR3Mutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[N] } break; default:
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[ReturnValsMutator]MSP[N] } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI2Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR6Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI2Mutator]MSP[N]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; MST[IncrementsMutator]MSP[N] }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR2Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; MST[rv.ABSMutator]MSP[N] context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI4Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[N] break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR4Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR2Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[InlineConstantMutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR1Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[N] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[InlineConstantMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR6Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR3Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[MathMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR5Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI2Mutator]MSP[S] return false ; } } return true ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.ROR4Mutator]MSP[N] context . eof = true ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI1Mutator]MSP[N] return resizedBytes ; } @Override
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[InlineConstantMutator]MSP[S] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( context . eof && context . modulus != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI3Mutator]MSP[N] context . eof = true ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI1Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[ConstructorCallMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI3Mutator]MSP[S] final long len = b64 . getEncodedLength ( binaryData ) ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[N]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[InlineConstantMutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD1Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.ABSMutator]MSP[N] return resizedBytes ; } @Override
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.OBBN2Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR2Mutator]MSP[S] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[InlineConstantMutator]MSP[N] }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR6Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[NullReturnValsMutator]MSP[S]
if ( binaryData == null || binaryData . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR3Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR2Mutator]MSP[S] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( len > maxResultSize ) { MST[rv.ROR1Mutator]MSP[S] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[InlineConstantMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR6Mutator]MSP[N]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.ROR5Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI4Mutator]MSP[N] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI3Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.ABSMutator]MSP[N] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR1Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.AOD2Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR4Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[ReturnValsMutator]MSP[N] } public static boolean isBase64 ( final byte octet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR2Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { MST[rv.ROR4Mutator]MSP[N] return; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.UOI4Mutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { MST[rv.ROR3Mutator]MSP[N] b += 256 ; }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI1Mutator]MSP[N] context . eof = true ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.ABSMutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.CRCR3Mutator]MSP[N] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.ABSMutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[MathMutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( inAvail < 0 ) { MST[rv.UOI3Mutator]MSP[N] context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.ROR4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[rv.ABSMutator]MSP[N] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[ReturnValsMutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR3Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR2Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[N] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR3Mutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.UOI4Mutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.UOI2Mutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.AOR2Mutator]MSP[N] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR6Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR3Mutator]MSP[N] }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[N] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
context . ibitWorkArea = context . ibitWorkArea >> 4 ; MST[rv.CRCR1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; MST[rv.AOR1Mutator]MSP[N] } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR5Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[MathMutator]MSP[N]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR4Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[VoidMethodCallMutator]MSP[N] return resizedBytes ; } @Override
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR3Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.ABSMutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR4Mutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } public static boolean isBase64 ( final byte [] arrayOctet ) {
switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR2Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[MathMutator]MSP[N]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[ReturnValsMutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[NegateConditionalsMutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI3Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR4Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[InlineConstantMutator]MSP[N] } } return true ; }
if ( context . eof && context . modulus != 0 ) { MST[rv.UOI4Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI3Mutator]MSP[N] if ( b < 0 ) { b += 256 ; }
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static boolean isBase64 ( final byte octet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI2Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; final byte [] bigBytes = bigInt . toByteArray () ; MST[NonVoidMethodCallMutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
if ( len > maxResultSize ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[InlineConstantMutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI1Mutator]MSP[S] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI1Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[N] break; default:
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI4Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
context . ibitWorkArea = context . ibitWorkArea >> 4 ; MST[InlineConstantMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR4Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] }
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.ABSMutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR1Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI3Mutator]MSP[N]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR1Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI3Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR3Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI2Mutator]MSP[N]
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[NullReturnValsMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[N] } break;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ROR3Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[InlineConstantMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI2Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[N] } break; default:
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI3Mutator]MSP[N] return resizedBytes ; } @Override
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR4Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI4Mutator]MSP[N] return resizedBytes ; } @Override
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR3Mutator]MSP[N]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[InlineConstantMutator]MSP[S]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR1Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[ConditionalsBoundaryMutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR4Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[S] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI3Mutator]MSP[N] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.ABSMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[InlineConstantMutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI4Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR6Mutator]MSP[S] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR6Mutator]MSP[S]
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; }
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR3Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI3Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; }
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[S]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI4Mutator]MSP[S] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI4Mutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[NullReturnValsMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( len > maxResultSize ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.UOI3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.ABSMutator]MSP[N] if ( b == pad ) { context . eof = true ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI2Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[InlineConstantMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[MathMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; MST[VoidMethodCallMutator]MSP[N] break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[ReturnValsMutator]MSP[N] }
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR2Mutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR1Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR6Mutator]MSP[S] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR3Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR2Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( context . eof && context . modulus != 0 ) { MST[rv.UOI1Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR1Mutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ABSMutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } public static boolean isBase64 ( final byte [] arrayOctet ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI2Mutator]MSP[N] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[MathMutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; MST[rv.CRCR1Mutator]MSP[N] context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI2Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[MathMutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
if ( inAvail < 0 ) { context . eof = true ; MST[rv.CRCR4Mutator]MSP[N] if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI1Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[rv.UOI3Mutator]MSP[N] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOD1Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR1Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ABSMutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR3Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[experimental.NakedReceiverMutator]MSP[N] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR2Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.AOR3Mutator]MSP[N] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR2Mutator]MSP[N] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR2Mutator]MSP[N]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[NullReturnValsMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[NonVoidMethodCallMutator]MSP[S] }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR3Mutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI4Mutator]MSP[N] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR2Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR2Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR4Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[InlineConstantMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[experimental.MemberVariableMutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR1Mutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[N]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.CRCR6Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI1Mutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI4Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR1Mutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { MST[rv.ROR4Mutator]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[S] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR2Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR6Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.UOI1Mutator]MSP[N] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI4Mutator]MSP[N] break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { MST[rv.ROR2Mutator]MSP[N] context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; MST[VoidMethodCallMutator]MSP[N] context . ibitWorkArea = context . ibitWorkArea >> 2 ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.AOR3Mutator]MSP[N] } } } }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOD1Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR1Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[N]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.CRCR2Mutator]MSP[N] } } } }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR1Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.OBBN1Mutator]MSP[N]
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[rv.UOI2Mutator]MSP[N] switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.ABSMutator]MSP[N] return resizedBytes ; } @Override
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.AOD2Mutator]MSP[N] break; default:
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI2Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ROR4Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] context . eof = true ; }
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.AOR2Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.CRCR5Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ABSMutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[MathMutator]MSP[N]
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[N] break; default:
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ABSMutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI1Mutator]MSP[N] return resizedBytes ; } @Override
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR3Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[S] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR3Mutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI4Mutator]MSP[N] if ( b < 0 ) { b += 256 ; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[N] context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR4Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI3Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI2Mutator]MSP[N] context . eof = true ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI2Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( context . eof && context . modulus != 0 ) { MST[rv.UOI3Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR3Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[ConstructorCallMutator]MSP[S] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[N] break; default:
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR5Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[ReturnValsMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI4Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; }
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[ConstructorCallMutator]MSP[N] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; MST[ReturnValsMutator]MSP[S] } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR6Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI2Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.AOR3Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[S] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
if ( len > maxResultSize ) { MST[rv.ABSMutator]MSP[S] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[ConstructorCallMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI2Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[ArgumentPropagationMutator]MSP[S]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR3Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI3Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR3Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI2Mutator]MSP[N] return resizedBytes ; } @Override
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI4Mutator]MSP[S] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR3Mutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR1Mutator]MSP[N]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.CRCR4Mutator]MSP[N]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[InlineConstantMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[MathMutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[NullReturnValsMutator]MSP[N] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR4Mutator]MSP[S]
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[ReturnValsMutator]MSP[N] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.AOR3Mutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
switch ( context . modulus ) { MST[rv.UOI3Mutator]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
if ( len > maxResultSize ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR5Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; int b = in [ inPos ++ ] ; MST[rv.UOI1Mutator]MSP[N] if ( b < 0 ) { b += 256 ; }
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[MathMutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( len > maxResultSize ) { MST[rv.UOI2Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR1Mutator]MSP[S] return false ; } } return true ; }
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR1Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.UOI1Mutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI4Mutator]MSP[N]
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI3Mutator]MSP[N] buffer [ context . pos ++ ] = pad ; } break;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N]
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR3Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
switch ( context . modulus ) { MST[rv.ABSMutator]MSP[N] case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; MST[NonVoidMethodCallMutator]MSP[N] final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI3Mutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI4Mutator]MSP[S] final byte [] bigBytes = bigInt . toByteArray () ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR1Mutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR4Mutator]MSP[N] len -- ; } final int startDst = bitlen / 8 - len ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR6Mutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR2Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[MathMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[S] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[InlineConstantMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR2Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR4Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; MST[rv.CRCR2Mutator]MSP[N] context . ibitWorkArea = context . ibitWorkArea >> 2 ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[rv.CRCR6Mutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.UOI2Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.AOR4Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI2Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI2Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; MST[IncrementsMutator]MSP[N] } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.OBBN3Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { MST[rv.ROR2Mutator]MSP[N] context . eof = true ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.AOR4Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR4Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR4Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { MST[rv.ROR2Mutator]MSP[N] return; }
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR5Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR4Mutator]MSP[N]
if ( inAvail < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR6Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR5Mutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.UOI1Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.ABSMutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR2Mutator]MSP[N] len -- ; } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD2Mutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N]
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI1Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.CRCR3Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.OBBN3Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[InlineConstantMutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD2Mutator]MSP[S] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ABSMutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI2Mutator]MSP[S] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI3Mutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
if ( context . eof && context . modulus != 0 ) { MST[NegateConditionalsMutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ABSMutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.ABSMutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR5Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( inAvail < 0 ) { MST[rv.UOI1Mutator]MSP[N] context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI4Mutator]MSP[N] return resizedBytes ; } @Override
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[ConditionalsBoundaryMutator]MSP[S] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[MathMutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[ArgumentPropagationMutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.ROR1Mutator]MSP[N]
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[InlineConstantMutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[NullReturnValsMutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[ConstructorCallMutator]MSP[S] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; MST[rv.CRCR3Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[S] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[IncrementsMutator]MSP[N] if ( b == pad ) { context . eof = true ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.AOR1Mutator]MSP[N]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR6Mutator]MSP[S] final byte [] bigBytes = bigInt . toByteArray () ;
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOD1Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[N] } } } }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR4Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI4Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[BooleanTrueReturnValsMutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR3Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.AOD1Mutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[NegateConditionalsMutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.CRCR5Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.UOI1Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ROR1Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI3Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI1Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI4Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; MST[ReturnValsMutator]MSP[N] } int startSrc = 0 ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { MST[rv.UOI3Mutator]MSP[N] context . eof = true ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.UOI4Mutator]MSP[N] if ( b == pad ) { context . eof = true ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI1Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR5Mutator]MSP[S] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR2Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI1Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI2Mutator]MSP[N] } } } @Override void encode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; }
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR5Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI2Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR4Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOD1Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.UOI1Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[InlineConstantMutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ; MST[rv.ABSMutator]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static boolean isBase64 ( final byte octet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI1Mutator]MSP[N] } break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { MST[rv.UOI1Mutator]MSP[N] final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR1Mutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[rv.UOI2Mutator]MSP[S] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ROR2Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI4Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
void decode ( final byte [] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return; } if ( inAvail < 0 ) { MST[rv.ROR4Mutator]MSP[N] context . eof = true ; }
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[ConditionalsBoundaryMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR5Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; } } } }
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.UOI3Mutator]MSP[N]
throw new IllegalStateException ( lr_4 + context . modulus ) ; MST[NonVoidMethodCallMutator]MSP[S] } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) {
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR6Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.UOI1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[NegateConditionalsMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ; MST[NonVoidMethodCallMutator]MSP[N]
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ; MST[rv.CRCR6Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOR3Mutator]MSP[N]
if ( len > maxResultSize ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ; MST[rv.CRCR5Mutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.ABSMutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR2Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI2Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; MST[rv.UOI3Mutator]MSP[N] if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.CRCR4Mutator]MSP[N] } break;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[InlineConstantMutator]MSP[N]
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.UOI3Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ABSMutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR1Mutator]MSP[N]
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.ABSMutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.ROR5Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOR2Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOR3Mutator]MSP[N]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI4Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.CRCR4Mutator]MSP[N] } break; default:
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[InlineConstantMutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI2Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.OBBN3Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ; MST[rv.UOI4Mutator]MSP[N]
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[MathMutator]MSP[N] } } } }
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[experimental.MemberVariableMutator]MSP[N] } } } }
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; MST[rv.UOI3Mutator]MSP[N] } break;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[ReturnValsMutator]MSP[S] }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[rv.UOI3Mutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; MST[rv.UOI3Mutator]MSP[N] } break; default:
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.CRCR1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI1Mutator]MSP[N] return resizedBytes ; } @Override
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.AOR1Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
if ( binaryData == null || binaryData . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; final long len = b64 . getEncodedLength ( binaryData ) ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOR3Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI2Mutator]MSP[N] return resizedBytes ; } @Override
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[NullReturnValsMutator]MSP[S] }
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 4 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; buffer [ context . pos ++ ] = pad ; } break;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.UOI4Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR6Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOR2Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; }
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.UOI1Mutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[InlineConstantMutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } return true ; }
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[InlineConstantMutator]MSP[S] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[ConstructorCallMutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[S]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR5Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR1Mutator]MSP[N]
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[ArgumentPropagationMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[InlineConstantMutator]MSP[N]
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; MST[experimental.RemoveIncrementsMutator]MSP[N] } final int startDst = bitlen / 8 - len ;
if ( len > maxResultSize ) { MST[rv.UOI4Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
switch ( context . modulus ) { case 0 : break; case 1 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 2 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.ABSMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR1Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[rv.CRCR4Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[InlineConstantMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR5Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[InlineConstantMutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.ABSMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.CRCR6Mutator]MSP[N] } } } }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[NonVoidMethodCallMutator]MSP[S] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; MST[rv.UOI2Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[rv.CRCR5Mutator]MSP[N] len -- ; } final int startDst = bitlen / 8 - len ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.ROR1Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.UOI3Mutator]MSP[N] return resizedBytes ; } @Override
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[MathMutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; MST[NullReturnValsMutator]MSP[N] } @Override
final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; context . modulus = ( context . modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; MST[rv.CRCR4Mutator]MSP[N] int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[MathMutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[rv.AOD1Mutator]MSP[N]
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } static byte [] toIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( inAvail < 0 ) { context . eof = true ; if ( 0 == context . modulus && lineLength == 0 ) { MST[rv.UOI1Mutator]MSP[N] return; } final byte [] buffer = ensureBufferSize ( encodeSize , context ) ; final int savedPos = context . pos ;
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; MST[rv.ABSMutator]MSP[N] if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ;
if ( len > maxResultSize ) { MST[ConditionalsBoundaryMutator]MSP[S] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ABSMutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
case 2 : buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 10 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 4 ) & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[NonVoidMethodCallMutator]MSP[S]
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea << 2 ) & MASK_6BITS ] ; MST[rv.CRCR4Mutator]MSP[N] if ( encodeTable == STANDARD_ENCODE_TABLE ) { buffer [ context . pos ++ ] = pad ; } break; default:
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; buffer [ context . pos ++ ] = (byte) ( context . ibitWorkArea & MASK_8BITS ) ; MST[rv.AOR1Mutator]MSP[N] } } } }
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ; MST[rv.CRCR6Mutator]MSP[S]
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR4Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( MST[ConstructorCallMutator]MSP[N] lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[NegateConditionalsMutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[InlineConstantMutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.UOI3Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.AOD1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; MST[rv.CRCR1Mutator]MSP[N] } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; }
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR2Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[MathMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[rv.ROR4Mutator]MSP[N]
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[MathMutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
for ( int i = 0 ; i < inAvail ; i ++ ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; MST[rv.ABSMutator]MSP[N] if ( b == pad ) { context . eof = true ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.CRCR2Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; MST[rv.AOD2Mutator]MSP[N] final byte [] bigBytes = bigInt . toByteArray () ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.AOD1Mutator]MSP[N]
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; }
public static byte [] decodeBase64 ( final byte [] base64Data ) { return new Base64 () . decode ( base64Data ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] decodeBase64 ( final String base64String ) { return new Base64 () . decode ( base64String ) ; }
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[InlineConstantMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[rv.CRCR5Mutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } final Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; MST[rv.ABSMutator]MSP[N] final long len = b64 . getEncodedLength ( binaryData ) ;
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
if ( context . eof && context . modulus != 0 ) { final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.CRCR5Mutator]MSP[N]
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ABSMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( len > maxResultSize ) { MST[rv.UOI1Mutator]MSP[N] throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( context . eof && context . modulus != 0 ) { MST[rv.ROR3Mutator]MSP[N] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; switch ( context . modulus ) { case 1 : validateTrailingCharacter () ; break; case 2 : validateCharacter ( MASK_4BITS , context ) ;
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[ReturnValsMutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; MST[rv.ABSMutator]MSP[N] return resizedBytes ; } @Override
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR1Mutator]MSP[N] context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) {
buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 8 ) & MASK_8BITS ) ; MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; default:
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
break; } if ( b >= 0 && b < DECODE_TABLE . length ) { final int result = DECODE_TABLE [ b ] ; if ( result >= 0 ) { context . modulus = ( context . modulus + 1 ) % BYTES_PER_ENCODED_BLOCK ; MST[InlineConstantMutator]MSP[N]
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { throw new IllegalArgumentException ( lr_5 + lr_6 +
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; MST[NullReturnValsMutator]MSP[N] } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
context . ibitWorkArea = ( context . ibitWorkArea << 8 ) + b ; if ( 0 == context . modulus ) { buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 18 ) & MASK_6BITS ] ; MST[rv.OBBN1Mutator]MSP[N]
return encodeBase64 ( toIntegerBytes ( bigInteger ) , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public static boolean isArrayByteBase64 ( final byte [] arrayOctet ) { return isBase64 ( arrayOctet ) ; } public static boolean isBase64 ( final byte octet ) {
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ; MST[rv.ABSMutator]MSP[N]
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; MST[ConstructorCallMutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; MST[InlineConstantMutator]MSP[N] len -- ; } final int startDst = bitlen / 8 - len ;
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; if ( context . modulus == 0 ) { MST[rv.UOI1Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
context . ibitWorkArea = context . ibitWorkArea >> 4 ; MST[rv.CRCR3Mutator]MSP[N] buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea ) & MASK_8BITS ) ; break; case 3 : validateCharacter ( MASK_2BITS , context ) ; context . ibitWorkArea = context . ibitWorkArea >> 2 ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; }
if ( isStrictDecoding () && ( context . ibitWorkArea & emptyBitsMask ) != 0 ) { throw new IllegalArgumentException ( lr_5 + lr_6 + lr_7 ) ; } } private void validateTrailingCharacter () { if ( isStrictDecoding () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_5 + lr_6 +
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; context . pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR5Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) { MST[NegateConditionalsMutator]MSP[N]
return octet >= 0 && octet < decodeTable . length && decodeTable [ octet ] != - 1 ; MST[rv.CRCR1Mutator]MSP[N] } public boolean isUrlSafe () { return this . encodeTable == URL_SAFE_ENCODE_TABLE ; } private void validateCharacter ( final int emptyBitsMask , final Context context ) {
if ( len > maxResultSize ) { throw new IllegalArgumentException ( lr_1 + MST[experimental.NakedReceiverMutator]MSP[N] len + lr_2 + maxResultSize ) ; } return b64 . encode ( binaryData ) ; } public static byte [] encodeBase64Chunked ( final byte [] binaryData ) { return encodeBase64 ( binaryData , true ) ;
buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 12 ) & MASK_6BITS ] ; MST[rv.OBBN2Mutator]MSP[N] buffer [ context . pos ++ ] = encodeTable [ ( context . ibitWorkArea >> 6 ) & MASK_6BITS ] ;
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; if ( lineLength > 0 && context . currentLinePos > 0 ) { MST[NegateConditionalsMutator]MSP[N]
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.ABSMutator]MSP[N] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ROR1Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.ABSMutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
public static String encodeBase64URLSafeString ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , true ) ) ; MST[rv.CRCR5Mutator]MSP[N] } public static byte [] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , lr_3 ) ;
for ( int i = 0 ; i < inAvail ; i ++ ) { MST[IncrementsMutator]MSP[S] final byte [] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos ++ ] ; if ( b == pad ) { context . eof = true ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[ReturnValsMutator]MSP[S] }
public static BigInteger decodeInteger ( final byte [] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } public static byte [] encodeBase64 ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false ) ; MST[InlineConstantMutator]MSP[N] }
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ; MST[rv.UOI4Mutator]MSP[N]
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[rv.CRCR4Mutator]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; }
System . arraycopy ( lineSeparator , 0 , buffer , context . pos , lineSeparator . length ) ; MST[rv.CRCR6Mutator]MSP[N] context . pos += lineSeparator . length ; context . currentLinePos = 0 ; } } } } } @Override protected boolean isInAlphabet ( final byte octet ) {
if ( ( ( bigInt . bitLength () % 8 ) != 0 ) && ( ( ( bigInt . bitLength () / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return bigBytes ; } int startSrc = 0 ;
for ( int i = 0 ; i < arrayOctet . length ; i ++ ) { if ( ! isBase64 ( arrayOctet [ i ] ) && ! isWhiteSpace ( arrayOctet [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; }
return octet == PAD_DEFAULT || ( octet >= 0 && octet < DECODE_TABLE . length && DECODE_TABLE [ octet ] != - 1 ) ; MST[NegateConditionalsMutator]MSP[N] } public static boolean isBase64 ( final byte [] arrayOctet ) {
throw new IllegalStateException ( lr_4 + context . modulus ) ; } context . currentLinePos += context . pos - savedPos ; MST[rv.AOR4Mutator]MSP[N] if ( lineLength > 0 && context . currentLinePos > 0 ) {
return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; MST[rv.CRCR6Mutator]MSP[N] } public static byte [] encodeBase64 ( final byte [] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) {
final byte [] resizedBytes = new byte [ bitlen / 8 ] ; MST[InlineConstantMutator]MSP[N] System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } @Override
buffer [ context . pos ++ ] = encodeTable [ context . ibitWorkArea & MASK_6BITS ] ; MST[rv.CRCR3Mutator]MSP[N] context . currentLinePos += BYTES_PER_ENCODED_BLOCK ; if ( lineLength > 0 && lineLength <= context . currentLinePos ) {
context . ibitWorkArea = ( context . ibitWorkArea << BITS_PER_ENCODED_BYTE ) + result ; MST[rv.AOR4Mutator]MSP[N] if ( context . modulus == 0 ) { buffer [ context . pos ++ ] = (byte) ( ( context . ibitWorkArea >> 16 ) & MASK_8BITS ) ;
int len = bigBytes . length ; if ( ( bigInt . bitLength () % 8 ) == 0 ) { MST[rv.AOD2Mutator]MSP[N] startSrc = 1 ; len -- ; } final int startDst = bitlen / 8 - len ;
} public static String encodeBase64String ( final byte [] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } public static byte [] encodeBase64URLSafe ( final byte [] binaryData ) { return encodeBase64 ( binaryData , false , true ) ; MST[rv.CRCR5Mutator]MSP[N] }
@SuppressWarnings ( lr_1 ) @Override public String toString () { return String . format ( lr_2 + lr_3 , this . getClass () . getSimpleName () , Arrays . toString ( buffer ) , currentLinePos , eof , ibitWorkArea , lbitWorkArea , modulus , pos , readPos ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) &&
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ;
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ROR4Mutator]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR6Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return decode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[S] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR5Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; MST[rv.UOI3Mutator]MSP[N] encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; MST[rv.CRCR3Mutator]MSP[N] } else if ( context . pos + size - context . buffer . length > 0 ) {
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR1Mutator]MSP[N] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR2Mutator]MSP[N]
for ( final byte element : arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[N] } return len ; }
switch ( byteToCheck ) { MST[experimental.SwitchMutator]MSP[N] case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ABSMutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[S] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.OBBN3Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR3Mutator]MSP[N] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[ReturnValsMutator]MSP[S] }
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[S] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI4Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; MST[experimental.MemberVariableMutator]MSP[N] context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
for ( final byte element : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR1Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[N] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI4Mutator]MSP[N] }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[N] context . readPos += len ;
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR5Mutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; MST[rv.AOR1Mutator]MSP[S]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[InlineConstantMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ROR1Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[N] } return len ; }
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return pArray ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI2Mutator]MSP[N] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.CRCR3Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[NullReturnValsMutator]MSP[N] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[S] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[N] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR2Mutator]MSP[S] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[InlineConstantMutator]MSP[N] decode ( pArray , 0 , EOF , context ) ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR4Mutator]MSP[N] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR4Mutator]MSP[S]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR5Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[ReturnValsMutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR3Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR3Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String encodeToString ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI3Mutator]MSP[N] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[ArgumentPropagationMutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[PrimitiveReturnsMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[ReturnValsMutator]MSP[N] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI3Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR5Mutator]MSP[N] } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI3Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR6Mutator]MSP[N] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR5Mutator]MSP[S] }
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR5Mutator]MSP[S] }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR4Mutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.ABSMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ROR1Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR6Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[N] } return len ; }
if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR3Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR1Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR3Mutator]MSP[N] throw new EncoderException ( lr_6 ) ; }
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR5Mutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI2Mutator]MSP[S] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[N] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI3Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.UOI2Mutator]MSP[N] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR2Mutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI2Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[N]
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR3Mutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[S] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[ReturnValsMutator]MSP[N] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR2Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[N]
for ( final byte element : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI2Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI1Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[InlineConstantMutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return encode ( pArray , 0 , pArray . length ) ; MST[NullReturnValsMutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return decode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; MST[rv.CRCR6Mutator]MSP[N] } else if ( context . pos + size - context . buffer . length > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR3Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[N] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[InlineConstantMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return pArray ; }
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[InlineConstantMutator]MSP[S] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR3Mutator]MSP[S] }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI3Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI2Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[ReturnValsMutator]MSP[N] } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI3Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ReturnValsMutator]MSP[N] } public String encodeToString ( final byte [] pArray ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI3Mutator]MSP[N]
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR2Mutator]MSP[S] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR2Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; MST[NonVoidMethodCallMutator]MSP[N] } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final byte [] result = new byte [ context . pos ] ; MST[rv.ABSMutator]MSP[N] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[N] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR5Mutator]MSP[N] decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.OBBN1Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI1Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.AOR3Mutator]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI2Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI2Mutator]MSP[S] if ( ! isInAlphabet ( octet ) &&
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[S] } public String encodeToString ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[N] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI4Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.ABSMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR6Mutator]MSP[N]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR4Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR2Mutator]MSP[S] } return len ; }
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR3Mutator]MSP[N] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.ABSMutator]MSP[N] }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR1Mutator]MSP[N] context . buffer = b ; return b ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; MST[rv.CRCR5Mutator]MSP[N] } else if ( context . pos + size - context . buffer . length > 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[InlineConstantMutator]MSP[N]
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR6Mutator]MSP[S] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR4Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[S] } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
for ( final byte element : arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ABSMutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR5Mutator]MSP[N]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) { MST[rv.ROR5Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR5Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return encode ( pArray , 0 , pArray . length ) ; MST[ReturnValsMutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.ABSMutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; MST[NullReturnValsMutator]MSP[N] }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI3Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[S] } return len ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) { MST[rv.UOI2Mutator]MSP[N]
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR6Mutator]MSP[N] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR5Mutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR2Mutator]MSP[N]
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[InlineConstantMutator]MSP[S] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR1Mutator]MSP[S]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[S] } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR3Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; MST[MathMutator]MSP[S]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI4Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.CRCR5Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR1Mutator]MSP[N] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[S] if ( ! isInAlphabet ( octet ) &&
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI3Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[MathMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return encode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI1Mutator]MSP[N] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[N] } return len ; }
for ( final byte element : arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR6Mutator]MSP[S] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.ROR3Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NonVoidMethodCallMutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[S]
readResults ( buf , 0 , buf . length , context ) ; MST[InlineConstantMutator]MSP[N] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.AOR3Mutator]MSP[N] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
readResults ( buf , 0 , buf . length , context ) ; return buf ; MST[NullReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR5Mutator]MSP[N] }
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR4Mutator]MSP[N]
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; MST[NullReturnValsMutator]MSP[N] } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[ReturnValsMutator]MSP[N] }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR4Mutator]MSP[S] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR2Mutator]MSP[N] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI2Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR6Mutator]MSP[N] context . buffer = b ; return b ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[N] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR1Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI1Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[InlineConstantMutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[N] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR2Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.UOI2Mutator]MSP[N]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.ABSMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR4Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI3Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[BooleanFalseReturnValsMutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI4Mutator]MSP[N] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI1Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI4Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return decode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[N] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new EncoderException ( lr_6 ) ; }
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR5Mutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[N] context . readPos += len ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR2Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR3Mutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
for ( final byte element : arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[N]
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[InlineConstantMutator]MSP[N] context . buffer = b ; return b ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[N] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[S] } } public byte [] decode ( final String pArray ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR4Mutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[N]
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR3Mutator]MSP[N] decode ( pArray , 0 , EOF , context ) ;
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[InlineConstantMutator]MSP[S] context . buffer = b ; return b ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR5Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR2Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[ReturnValsMutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[ArgumentPropagationMutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[InlineConstantMutator]MSP[N] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[S] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR2Mutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[S] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR1Mutator]MSP[N]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) { MST[NegateConditionalsMutator]MSP[N]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[ReturnValsMutator]MSP[N] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI1Mutator]MSP[N] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI4Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[S] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR6Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[InlineConstantMutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI1Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.ABSMutator]MSP[N] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI1Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI2Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[PrimitiveReturnsMutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR3Mutator]MSP[N] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR4Mutator]MSP[N]
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI3Mutator]MSP[N] context . readPos += len ;
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.ROR5Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
for ( final byte element : arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[N]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
return encode ( pArray , 0 , pArray . length ) ; MST[InlineConstantMutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return pArray ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR6Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOD1Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[S] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI2Mutator]MSP[N] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
return encode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[S] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[NonVoidMethodCallMutator]MSP[N] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[NullReturnValsMutator]MSP[N] }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI4Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return encode ( pArray , 0 , pArray . length ) ; MST[NonVoidMethodCallMutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI3Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[InlineConstantMutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[S] if ( ! isInAlphabet ( octet ) &&
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[N] } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR3Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.CRCR1Mutator]MSP[S] }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR1Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return resizeBuffer ( context , context . pos + size ) ; MST[NullReturnValsMutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR5Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
return decode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[N] } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String encodeToString ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_6 ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR2Mutator]MSP[S] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR3Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR4Mutator]MSP[S] } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR3Mutator]MSP[N] context . buffer = b ; return b ; }
readResults ( buf , 0 , buf . length , context ) ; MST[rv.CRCR5Mutator]MSP[N] return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI2Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; MST[ReturnValsMutator]MSP[S] } return context . eof ? EOF : 0 ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; MST[NullReturnValsMutator]MSP[N] } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return encode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[S] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[ReturnValsMutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI2Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; MST[ReturnValsMutator]MSP[N] } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.ABSMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return encode ( ( byte [] ) obj ) ; } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public String encodeToString ( final byte [] pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI4Mutator]MSP[S] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.AOR4Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[InlineConstantMutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR4Mutator]MSP[S] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR6Mutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR2Mutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI3Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI4Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; MST[rv.UOI3Mutator]MSP[N] encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ABSMutator]MSP[N]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI2Mutator]MSP[N]
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR3Mutator]MSP[S] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI1Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; MST[ConstructorCallMutator]MSP[S] }
boolean hasData ( final Context context ) { return context . buffer != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) &&
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ABSMutator]MSP[S]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI2Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; MST[rv.CRCR6Mutator]MSP[N] context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI3Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI2Mutator]MSP[S]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[InlineConstantMutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ABSMutator]MSP[N]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[NegateConditionalsMutator]MSP[S]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[N] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[InlineConstantMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI3Mutator]MSP[N] }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[ReturnValsMutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[N] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[S] } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR1Mutator]MSP[N] decode ( pArray , 0 , EOF , context ) ;
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[rv.CRCR6Mutator]MSP[N] decode ( pArray , 0 , EOF , context ) ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI2Mutator]MSP[N] } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOD2Mutator]MSP[S] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI1Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.OBBN2Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; MST[ReturnValsMutator]MSP[N] } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[S] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) { MST[rv.UOI4Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR3Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; MST[ReturnValsMutator]MSP[N] } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR3Mutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.ABSMutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[N]
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[S] } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_6 ) ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR5Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.ROR5Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[N] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR6Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.UOI4Mutator]MSP[N]
return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } protected byte [] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer == null ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return encode ( pArray , 0 , pArray . length ) ; MST[rv.CRCR1Mutator]MSP[N] } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR6Mutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ; MST[rv.ABSMutator]MSP[S]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NegateConditionalsMutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[N] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR4Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[ConstructorCallMutator]MSP[S] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR2Mutator]MSP[N] }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ; MST[rv.ABSMutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
final Context context = new Context () ; encode ( pArray , offset , length , context ) ; MST[rv.UOI4Mutator]MSP[N] encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[N] } @Override public byte [] decode ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new EncoderException ( lr_6 ) ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR3Mutator]MSP[N] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[N]
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[NullReturnValsMutator]MSP[S] }
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; MST[NullReturnValsMutator]MSP[N] } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[N] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR1Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[ReturnValsMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.CRCR4Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI3Mutator]MSP[N] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
final byte [] result = new byte [ context . pos ] ; MST[rv.UOI4Mutator]MSP[N] readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI1Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI2Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[S] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[N]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI4Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[ConditionalsBoundaryMutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR1Mutator]MSP[S] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR5Mutator]MSP[S] context . buffer = b ; return b ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR6Mutator]MSP[S] }
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; MST[experimental.MemberVariableMutator]MSP[N] context . pos = 0 ; context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
return resizeBuffer ( context , context . pos + size ) ; MST[MathMutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[S] } return len ; }
for ( final byte element : arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] if ( pad == element || isInAlphabet ( element ) ) { return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.ABSMutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[InlineConstantMutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI4Mutator]MSP[N] } return len ; }
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[ReturnValsMutator]MSP[S] }
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[NegateConditionalsMutator]MSP[N] throw new EncoderException ( lr_6 ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR4Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR4Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; MST[ReturnValsMutator]MSP[N] } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[NullReturnValsMutator]MSP[N] } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return resizeBuffer ( context , context . pos + size ) ; MST[NonVoidMethodCallMutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR6Mutator]MSP[S] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[VoidMethodCallMutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD1Mutator]MSP[N] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI1Mutator]MSP[N] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR1Mutator]MSP[S] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[MathMutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ROR5Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR1Mutator]MSP[N]
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR3Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[N] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[NegateConditionalsMutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.CRCR3Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR4Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.ABSMutator]MSP[N] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { throw new EncoderException ( lr_6 ) ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[NonVoidMethodCallMutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR4Mutator]MSP[S] throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR3Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NegateConditionalsMutator]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.ROR5Mutator]MSP[S]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[N] } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[N]
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[rv.CRCR5Mutator]MSP[N] context . buffer = b ; return b ; }
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI4Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[PrimitiveReturnsMutator]MSP[N] }
return encode ( pArray , 0 , pArray . length ) ; } public byte [] encode ( final byte [] pArray , final int offset , final int length ) { if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR5Mutator]MSP[N] return pArray ; }
if ( context . readPos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? EOF : 0 ; MST[rv.ROR2Mutator]MSP[N] }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR6Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[InlineConstantMutator]MSP[N] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR3Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[N] } return len ; }
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { return decode ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.ROR1Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[rv.UOI2Mutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOR1Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI3Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI1Mutator]MSP[S] if ( ! isInAlphabet ( octet ) &&
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR1Mutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[MathMutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.UOI3Mutator]MSP[N] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[InlineConstantMutator]MSP[N]
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[rv.CRCR3Mutator]MSP[S] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[S] } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[N]
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[ArgumentPropagationMutator]MSP[S] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[N] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.ABSMutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR5Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { MST[rv.UOI3Mutator]MSP[N] len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR5Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; MST[ReturnValsMutator]MSP[N] }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR2Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int len = Math . min ( available ( context ) , bAvail ) ; MST[rv.ABSMutator]MSP[N] System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos += len ;
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[rv.UOI1Mutator]MSP[S] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR5Mutator]MSP[N] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR1Mutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
final Context context = new Context () ; MST[ConstructorCallMutator]MSP[N] encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; final byte [] buf = new byte [ context . pos - context . readPos ] ;
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI1Mutator]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[rv.UOI4Mutator]MSP[S]
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; MST[rv.CRCR6Mutator]MSP[N] return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR2Mutator]MSP[N]
switch ( byteToCheck ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR1Mutator]MSP[N] } return len ; }
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
if ( pArray == null || pArray . length == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR1Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; MST[ConstructorCallMutator]MSP[N] decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.UOI4Mutator]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( pArray == null || pArray . length == 0 ) { MST[NegateConditionalsMutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[rv.CRCR3Mutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI4Mutator]MSP[N] context . readPos += len ;
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.ABSMutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; MST[InlineConstantMutator]MSP[N] default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.CRCR5Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR5Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[N]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; MST[rv.UOI1Mutator]MSP[N] if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; MST[InlineConstantMutator]MSP[S] }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR5Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR4Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[ReturnValsMutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOD2Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
readResults ( buf , 0 , buf . length , context ) ; return buf ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof byte [] ) ) { MST[rv.ROR1Mutator]MSP[S] throw new EncoderException ( lr_6 ) ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.CRCR3Mutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI4Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.UOI4Mutator]MSP[N] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.UOI1Mutator]MSP[N] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOD2Mutator]MSP[S] } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; } return ( minCapacity > MAX_BUFFER_SIZE ) ? MST[rv.CRCR2Mutator]MSP[S] minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.ABSMutator]MSP[N] } return len ; }
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; MST[rv.CRCR1Mutator]MSP[N]
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR1Mutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[S] } return len ; }
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR6Mutator]MSP[N]
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.AOD1Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; MST[rv.UOI1Mutator]MSP[N] } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.UOI4Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI1Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
context . buffer = new byte [ Math . max ( size , getDefaultBufferSize () ) ] ; context . pos = 0 ; MST[rv.CRCR3Mutator]MSP[N] context . readPos = 0 ; } else if ( context . pos + size - context . buffer . length > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR5Mutator]MSP[N]
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.UOI4Mutator]MSP[N] context . readPos += len ;
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.ROR3Mutator]MSP[N]
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[NegateConditionalsMutator]MSP[N] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR4Mutator]MSP[S] } return len ; }
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; MST[rv.ABSMutator]MSP[N] System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; return b ; }
switch ( byteToCheck ) { MST[rv.UOI1Mutator]MSP[N] case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
newCapacity = createPositiveCapacity ( minCapacity ) ; } final byte [] b = new byte [ newCapacity ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; MST[VoidMethodCallMutator]MSP[S] context . buffer = b ; return b ; }
return resizeBuffer ( context , context . pos + size ) ; MST[rv.AOR4Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.ABSMutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOR4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI4Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[ConstructorCallMutator]MSP[S] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
if ( pArray == null || pArray . length == 0 ) { MST[rv.ROR3Mutator]MSP[N] return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ;
return encode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[S] } public String encodeAsString ( final byte [] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } public String encodeToString ( final byte [] pArray ) {
return resizeBuffer ( context , context . pos + size ) ; MST[rv.UOI4Mutator]MSP[N] } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
return decode ( ( byte [] ) obj ) ; } else if ( obj instanceof String ) { MST[rv.ROR3Mutator]MSP[N] return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_5 ) ; } } public byte [] decode ( final String pArray ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.UOI3Mutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
for ( final byte element : arrayOctet ) { if ( pad == element || isInAlphabet ( element ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; } @Override public byte [] decode ( final byte [] pArray ) {
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[MathMutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[NegateConditionalsMutator]MSP[N]
return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } @Override public byte [] encode ( final byte [] pArray ) { if ( pArray == null || pArray . length == 0 ) { return pArray ; MST[ReturnValsMutator]MSP[N] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { MST[rv.ABSMutator]MSP[N] if ( ! isInAlphabet ( octet ) &&
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.UOI4Mutator]MSP[N] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) { MST[rv.CRCR1Mutator]MSP[N]
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI3Mutator]MSP[S] } return len ; }
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR6Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[MathMutator]MSP[S] } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.UOI1Mutator]MSP[N] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[NonVoidMethodCallMutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
int available ( final Context context ) { return context . buffer != null ? context . pos - context . readPos : 0 ; MST[rv.AOR4Mutator]MSP[N] } protected boolean containsAlphabetOrPad ( final byte [] arrayOctet ) { if ( arrayOctet == null ) { return false ; }
( ! allowWSPad || ( octet != pad ) && ! isWhiteSpace ( octet ) ) ) { return false ; } } return true ; } public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , true ) ; MST[rv.CRCR4Mutator]MSP[N] }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.AOD2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; MST[rv.UOI2Mutator]MSP[N] if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; }
throw new OutOfMemoryError ( lr_4 + ( minCapacity & 0xffffffffL ) ) ; MST[InlineConstantMutator]MSP[N] } return ( minCapacity > MAX_BUFFER_SIZE ) ? minCapacity : MAX_BUFFER_SIZE ; } public static byte [] getChunkSeparator () { return CHUNK_SEPARATOR . clone () ; } protected static boolean isWhiteSpace ( final byte byteToCheck ) {
final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; MST[rv.ABSMutator]MSP[N] context . readPos += len ;
return resizeBuffer ( context , context . pos + size ) ; } return context . buffer ; } public CodecPolicy getCodecPolicy () { return decodingPolicy ; MST[NullReturnValsMutator]MSP[N] } protected int getDefaultBufferSize () { return DEFAULT_BUFFER_SIZE ; } public long getEncodedLength ( final byte [] pArray ) {
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { MST[rv.UOI2Mutator]MSP[N] newCapacity = minCapacity ; } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI1Mutator]MSP[N]
if ( pArray == null || pArray . length == 0 ) { return pArray ; } final Context context = new Context () ; decode ( pArray , 0 , pArray . length , context ) ; MST[VoidMethodCallMutator]MSP[N] decode ( pArray , 0 , EOF , context ) ;
switch ( byteToCheck ) { case ' ' : case '\n' : case '\r' : case '\t' : return true ; default : return false ; MST[rv.CRCR6Mutator]MSP[N] } } private static byte [] resizeBuffer ( final Context context , final int minCapacity ) {
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; MST[rv.CRCR1Mutator]MSP[N] } private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; MST[rv.AOR2Mutator]MSP[S] } return len ; }
final int oldCapacity = context . buffer . length ; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR ; if ( compareUnsigned ( newCapacity , minCapacity ) < 0 ) { newCapacity = minCapacity ; MST[rv.ABSMutator]MSP[S] } if ( compareUnsigned ( newCapacity , MAX_BUFFER_SIZE ) > 0 ) {
long len = ( ( pArray . length + unencodedBlockSize - 1 ) / unencodedBlockSize ) * ( long ) encodedBlockSize ; if ( lineLength > 0 ) { len += ( ( len + lineLength - 1 ) / lineLength ) * chunkSeparatorLength ; } return len ; MST[rv.UOI2Mutator]MSP[N] }
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI4Mutator]MSP[N]
boolean hasData ( final Context context ) { return context . buffer != null ; } public boolean isInAlphabet ( final byte [] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) && MST[rv.UOI2Mutator]MSP[N]
public boolean isStrictDecoding () { return decodingPolicy == CodecPolicy . STRICT ; MST[rv.CRCR5Mutator]MSP[S] } int readResults ( final byte [] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer != null ) {
final byte [] result = new byte [ context . pos ] ; readResults ( result , 0 , result . length , context ) ; return result ; } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[N]
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
public RuleType getRuleType () { return this . engine . getRuleType () ; } public boolean isConcat () { return this . engine . isConcat () ; } public void setConcat ( final boolean concat ) {
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
this . engine . getRuleType () , this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , ruleType ,
this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () ,
this . engine . isConcat () , maxPhonemes ) ; }
@Override MST[rv.CRCR4Mutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine . getRuleType () , this . engine . isConcat () , MST[NonVoidMethodCallMutator]MSP[S] this . engine . getMaxPhonemes () ) ; } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , ruleType ,
@Override MST[rv.CRCR2Mutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
@Override MST[rv.CRCR6Mutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
@Override MST[rv.CRCR3Mutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
@Override MST[rv.CRCR5Mutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; MST[ReturnValsMutator]MSP[N] } public NameType getNameType () { return this . engine . getNameType () ; }
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; MST[NullReturnValsMutator]MSP[S] } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; MST[ArgumentPropagationMutator]MSP[N] } public NameType getNameType () { return this . engine . getNameType () ; }
@Override MST[experimental.MemberVariableMutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; MST[NonVoidMethodCallMutator]MSP[N] }
public RuleType getRuleType () { return this . engine . getRuleType () ; MST[NullReturnValsMutator]MSP[S] } public boolean isConcat () { return this . engine . isConcat () ; } public void setConcat ( final boolean concat ) {
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[N] } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
public String encode ( final String source ) throws EncoderException { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () ,
public RuleType getRuleType () { return this . engine . getRuleType () ; } public boolean isConcat () { return this . engine . isConcat () ; MST[NonVoidMethodCallMutator]MSP[S] } public void setConcat ( final boolean concat ) {
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public NameType getNameType () { return this . engine . getNameType () ; }
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
public RuleType getRuleType () { return this . engine . getRuleType () ; } public boolean isConcat () { return this . engine . isConcat () ; MST[BooleanTrueReturnValsMutator]MSP[S] } public void setConcat ( final boolean concat ) {
public RuleType getRuleType () { return this . engine . getRuleType () ; } public boolean isConcat () { return this . engine . isConcat () ; MST[BooleanFalseReturnValsMutator]MSP[S] } public void setConcat ( final boolean concat ) {
this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; MST[experimental.MemberVariableMutator]MSP[N] } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () ,
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[NonVoidMethodCallMutator]MSP[N] concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
this . engine . isConcat () , MST[ConstructorCallMutator]MSP[S] maxPhonemes ) ; }
this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , MST[NonVoidMethodCallMutator]MSP[S] this . engine . getRuleType () ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } return encode ( ( String ) source ) ; } @Override
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[rv.ROR3Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[rv.ROR1Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , concat , this . engine . getMaxPhonemes () ) ; MST[experimental.MemberVariableMutator]MSP[S] } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; MST[ReturnValsMutator]MSP[N] }
this . engine . isConcat () , MST[NonVoidMethodCallMutator]MSP[S] maxPhonemes ) ; }
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] } public NameType getNameType () { return this . engine . getNameType () ; }
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[rv.UOI2Mutator]MSP[N] concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
this . engine . getRuleType () , this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; MST[NonVoidMethodCallMutator]MSP[S] } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , ruleType ,
this . engine . isConcat () , MST[rv.UOI4Mutator]MSP[N] maxPhonemes ) ; }
this . engine . isConcat () , MST[rv.UOI2Mutator]MSP[N] maxPhonemes ) ; }
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , concat , this . engine . getMaxPhonemes () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; MST[ReturnValsMutator]MSP[S] } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
this . engine . getRuleType () , this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; MST[experimental.MemberVariableMutator]MSP[S] } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , ruleType ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[rv.UOI4Mutator]MSP[S] concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
this . engine . getRuleType () , MST[NonVoidMethodCallMutator]MSP[N] this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , ruleType ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override
public RuleType getRuleType () { return this . engine . getRuleType () ; MST[ReturnValsMutator]MSP[S] } public boolean isConcat () { return this . engine . isConcat () ; } public void setConcat ( final boolean concat ) {
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[rv.UOI3Mutator]MSP[S] concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
public RuleType getRuleType () { return this . engine . getRuleType () ; MST[NonVoidMethodCallMutator]MSP[S] } public boolean isConcat () { return this . engine . isConcat () ; } public void setConcat ( final boolean concat ) {
public String encode ( final String source ) throws EncoderException { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; }
this . engine . isConcat () , MST[experimental.MemberVariableMutator]MSP[S] maxPhonemes ) ; }
this . engine . getRuleType () , this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; MST[ConstructorCallMutator]MSP[N] } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , ruleType ,
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , concat , this . engine . getMaxPhonemes () ) ; MST[ConstructorCallMutator]MSP[S] } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; MST[ConstructorCallMutator]MSP[N] } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () ,
this . engine . isConcat () , MST[rv.UOI1Mutator]MSP[N] maxPhonemes ) ; }
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[rv.ROR4Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine . getRuleType () , this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; } public void setRuleType ( final RuleType ruleType ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , MST[NonVoidMethodCallMutator]MSP[N] ruleType ,
this . engine . isConcat () , this . engine . getMaxPhonemes () ) ; } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[NonVoidMethodCallMutator]MSP[S]
this . engine . isConcat () , MST[NonVoidMethodCallMutator]MSP[S] this . engine . getMaxPhonemes () ) ; } public void setMaxPhonemes ( final int maxPhonemes ) { this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () ,
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[rv.ABSMutator]MSP[N] concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
this . engine = new PhoneticEngine ( this . engine . getNameType () , MST[NonVoidMethodCallMutator]MSP[N] this . engine . getRuleType () , concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[NegateConditionalsMutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine = new PhoneticEngine ( this . engine . getNameType () , this . engine . getRuleType () , MST[rv.UOI1Mutator]MSP[N] concat , this . engine . getMaxPhonemes () ) ; } public void setNameType ( final NameType nameType ) { this . engine = new PhoneticEngine ( nameType ,
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; MST[ArgumentPropagationMutator]MSP[S] } @Override
public String encode ( final String source ) throws EncoderException { if ( source == null ) { return null ; } return this . engine . encode ( source ) ; } public NameType getNameType () { return this . engine . getNameType () ; MST[NullReturnValsMutator]MSP[N] }
@Override MST[ConstructorCallMutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine . isConcat () , MST[rv.UOI3Mutator]MSP[S] maxPhonemes ) ; }
@Override MST[InlineConstantMutator]MSP[N] public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
public RuleType getRuleType () { return this . engine . getRuleType () ; } public boolean isConcat () { return this . engine . isConcat () ; MST[ReturnValsMutator]MSP[N] } public void setConcat ( final boolean concat ) {
@Override public Object encode ( final Object source ) throws EncoderException { if ( ! ( source instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new EncoderException ( lr_1 ) ; } return encode ( ( String ) source ) ; } @Override
this . engine . isConcat () , MST[rv.ABSMutator]MSP[S] maxPhonemes ) ; }
public Branch createBranch () { final Branch branch = new Branch () ; branch . builder . append ( toString () ) ; branch . lastReplacement = this . lastReplacement ; return branch ; } @Override public boolean equals ( final Object other ) {
if ( this == other ) { return true ; } if ( ! ( other instanceof Branch ) ) { return false ; } return toString () . equals ( ( ( Branch ) other ) . toString () ) ; } public void finish () {
while ( builder . length () < MAX_LENGTH ) { builder . append ( '0' ) ; cachedString = null ; } } @Override public int hashCode () { return toString () . hashCode () ; } public void processNextReplacement ( final String replacement , final boolean forceAppend ) {
final boolean append = lastReplacement == null || ! lastReplacement . endsWith ( replacement ) || forceAppend ; if ( append && builder . length () < MAX_LENGTH ) { builder . append ( replacement ) ; if ( builder . length () > MAX_LENGTH ) {
builder . delete ( MAX_LENGTH , builder . length () ) ; } cachedString = null ; } lastReplacement = replacement ; } @Override public String toString () { if ( cachedString == null ) { cachedString = builder . toString () ; } return cachedString ; }
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { return replacementAtStart ; } final int nextIndex = getPatternLength () ;
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return String . format ( lr_1 , pattern , Arrays . asList ( replacementAtStart ) , Arrays . asList ( replacementBeforeVowel ) , Arrays . asList ( replacementDefault ) ) ; } @Override public int compare ( final Rule rule1 , final Rule rule2 ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine () ) { currentLine ++ ; final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( MULTILINE_COMMENT_END ) ) {
inMultilineComment = false ; } continue; } if ( line . startsWith ( MULTILINE_COMMENT_START ) ) { inMultilineComment = true ; } else { final int cmtI = line . indexOf ( COMMENT ) ; if ( cmtI >= 0 ) {
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { continue; } if ( line . contains ( lr_2 ) ) {
final String [] parts = line . split ( lr_2 ) ; if ( parts . length != 2 ) { throw new IllegalArgumentException ( lr_3 + parts . length + lr_4 + rawLine + lr_5 + location ) ; } final String leftCharacter = parts [ 0 ] ;
final String rightCharacter = parts [ 1 ] ; if ( leftCharacter . length () != 1 || rightCharacter . length () != 1 ) { throw new IllegalArgumentException ( lr_6 + lr_7 + rawLine + lr_5 + location ) ; }
asciiFoldings . put ( leftCharacter . charAt ( 0 ) , rightCharacter . charAt ( 0 ) ) ; } else { final String [] parts = line . split ( lr_8 ) ; if ( parts . length != 4 ) {
throw new IllegalArgumentException ( lr_9 + parts . length + lr_4 + rawLine + lr_5 + location ) ; } try { final String pattern = stripQuotes ( parts [ 0 ] ) ; final String replacement1 = stripQuotes ( parts [ 1 ] ) ;
final String replacement2 = stripQuotes ( parts [ 2 ] ) ; final String replacement3 = stripQuotes ( parts [ 3 ] ) ; final Rule r = new Rule ( pattern , replacement1 , replacement2 , replacement3 ) ;
final char patternKey = r . pattern . charAt ( 0 ) ; List < Rule > rules = ruleMapping . get ( patternKey ) ; if ( rules == null ) { rules = new ArrayList <> () ; ruleMapping . put ( patternKey , rules ) ; }
rules . add ( r ) ; } catch ( final IllegalArgumentException e ) { throw new IllegalStateException ( lr_10 + currentLine + lr_11 + location , e ) ; } } } } } private static String stripQuotes ( String str ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
result [ index ++ ] = branch . toString () ; } return result ; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ABSMutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.ROR4Mutator]MSP[N] final char ch = input . charAt ( index ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; MST[VoidMethodCallMutator]MSP[N] currentBranches . addAll ( nextBranches ) ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR5Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.UOI3Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final char ch = input . charAt ( index ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; MST[rv.UOI4Mutator]MSP[N] final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.ROR2Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } return str ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final char ch = input . charAt ( index ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI1Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI3Mutator]MSP[N]
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[rv.UOI2Mutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.UOI1Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR1Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR5Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.ROR1Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
for ( final String branch : branches ) { MST[rv.ABSMutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
if ( ! ( obj instanceof String ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[NegateConditionalsMutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI3Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.ROR4Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.ROR5Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
currentBranches . add ( new Branch () ) ; MST[ConstructorCallMutator]MSP[N] char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[PrimitiveReturnsMutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[rv.AOR4Mutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[ReturnValsMutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[rv.AOR3Mutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[rv.AOR1Mutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[rv.AOD1Mutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[NonVoidMethodCallMutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[rv.AOR2Mutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[NonVoidMethodCallMutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[rv.AOD2Mutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
return rule2 . getPatternLength () - rule1 . getPatternLength () ; MST[MathMutator]MSP[N] } private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[rv.CRCR3Mutator]MSP[N] } } return sb . toString () ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR6Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { MST[rv.UOI1Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[InlineConstantMutator]MSP[S]
if ( ! ( obj instanceof String ) ) { MST[rv.ROR1Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ; MST[rv.UOI4Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ; MST[InlineConstantMutator]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[rv.UOI3Mutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.UOI2Mutator]MSP[N] final char ch = input . charAt ( index ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR6Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.UOI4Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[rv.ABSMutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR4Mutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.AOR4Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[rv.ABSMutator]MSP[N] if ( rules == null ) { continue; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[InlineConstantMutator]MSP[N] for ( final Branch branch : currentBranches ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.ROR3Mutator]MSP[N]
if ( Character . isWhitespace ( ch ) ) { MST[rv.ABSMutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[NegateConditionalsMutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[rv.UOI3Mutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[rv.ROR5Mutator]MSP[N] if ( branching ) {
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[rv.ROR2Mutator]MSP[N] if ( branching ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.ABSMutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR4Mutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.UOI3Mutator]MSP[N] final char ch = input . charAt ( index ) ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR3Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR2Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR5Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
index += rule . getPatternLength () - 1 ; MST[rv.UOI3Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI2Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR1Mutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.AOR4Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR1Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[NegateConditionalsMutator]MSP[N] for ( final Branch branch : currentBranches ) {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[rv.UOI1Mutator]MSP[N] if ( rules == null ) { continue; }
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; MST[rv.UOI3Mutator]MSP[N] } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[rv.CRCR4Mutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.ROR2Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR5Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR4Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.UOI1Mutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.UOI2Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] continue; }
for ( final String nextReplacement : replacements ) { MST[rv.ABSMutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR3Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR1Mutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; MST[rv.ABSMutator]MSP[N] if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR2Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[NegateConditionalsMutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR4Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; MST[rv.UOI1Mutator]MSP[N] if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.UOI3Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR6Mutator]MSP[N]
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; MST[rv.CRCR1Mutator]MSP[N] for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.ROR3Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.CRCR5Mutator]MSP[N] final char ch = input . charAt ( index ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR4Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR5Mutator]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR2Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.UOI4Mutator]MSP[S] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI4Mutator]MSP[S]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI3Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI1Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[InlineConstantMutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[ConditionalsBoundaryMutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[NegateConditionalsMutator]MSP[S]
return soundex ( source , false ) [ 0 ] ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.ROR5Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.ROR3Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[ConstructorCallMutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR6Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[InlineConstantMutator]MSP[N]
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[InlineConstantMutator]MSP[N] } } return sb . toString () ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR3Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR5Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { MST[rv.ABSMutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
index += rule . getPatternLength () - 1 ; MST[InlineConstantMutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return sb . toString () ; }
currentBranches . add ( new Branch () ) ; MST[NonVoidMethodCallMutator]MSP[N] char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
for ( final String nextReplacement : replacements ) { MST[rv.UOI4Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR5Mutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR1Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.UOI2Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.UOI3Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.ABSMutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ABSMutator]MSP[N]
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; MST[ReturnValsMutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.AOR1Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
index += rule . getPatternLength () - 1 ; MST[rv.AOR3Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI3Mutator]MSP[N]
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; MST[ReturnValsMutator]MSP[N] }
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { MST[rv.ROR5Mutator]MSP[N] continue; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR6Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.ROR5Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; MST[rv.UOI2Mutator]MSP[N] } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( branching ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; MST[rv.UOI4Mutator]MSP[N] if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { MST[rv.UOI1Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI4Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR2Mutator]MSP[N]
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } return sb . toString () ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR3Mutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String nextReplacement : replacements ) { MST[rv.UOI4Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ; MST[rv.UOI3Mutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.ROR4Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.ROR5Mutator]MSP[N] final char ch = input . charAt ( index ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[NegateConditionalsMutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { return null ; } final String input = cleanup ( source ) ; MST[NonVoidMethodCallMutator]MSP[N] final Set < Branch > currentBranches = new LinkedHashSet <> () ;
result [ index ++ ] = branch . toString () ; MST[rv.UOI3Mutator]MSP[N] } return result ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } return str ;
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { return null ; } final String input = cleanup ( source ) ; MST[ArgumentPropagationMutator]MSP[N] final Set < Branch > currentBranches = new LinkedHashSet <> () ;
index += rule . getPatternLength () - 1 ; MST[rv.AOR3Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
index += rule . getPatternLength () - 1 ; MST[rv.UOI2Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR3Mutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.ROR1Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR2Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.UOI3Mutator]MSP[S] for ( final Branch branch : currentBranches ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.UOI4Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { MST[NegateConditionalsMutator]MSP[N] continue; }
result [ index ++ ] = branch . toString () ; MST[rv.ABSMutator]MSP[N] } return result ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final char ch = input . charAt ( index ) ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.ROR2Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[rv.UOI1Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.ABSMutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String branch : branches ) { MST[rv.UOI4Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[NegateConditionalsMutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
index += rule . getPatternLength () - 1 ; MST[rv.CRCR4Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
index += rule . getPatternLength () - 1 ; MST[rv.CRCR3Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR4Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR3Mutator]MSP[N]
return soundex ( source , false ) [ 0 ] ; MST[ReturnValsMutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[NonVoidMethodCallMutator]MSP[N] final char ch = input . charAt ( index ) ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[rv.ROR1Mutator]MSP[N] if ( branching ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR2Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[IncrementsMutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR1Mutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.UOI1Mutator]MSP[N] final char ch = input . charAt ( index ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.ROR3Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final Branch branch : currentBranches ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[NegateConditionalsMutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException {
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[InlineConstantMutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[NegateConditionalsMutator]MSP[N] final char ch = input . charAt ( index ) ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR1Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.ABSMutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
result [ index ++ ] = branch . toString () ; MST[rv.UOI4Mutator]MSP[N] } return result ; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.CRCR6Mutator]MSP[N] final char ch = input . charAt ( index ) ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; MST[InlineConstantMutator]MSP[N] for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR5Mutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.UOI1Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI4Mutator]MSP[N]
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ; MST[rv.CRCR6Mutator]MSP[N]
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR3Mutator]MSP[S] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.UOI4Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR4Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI1Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI1Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR5Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[rv.CRCR3Mutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.ABSMutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
result [ index ++ ] = branch . toString () ; MST[IncrementsMutator]MSP[N] } return result ; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.UOI4Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; MST[rv.UOI3Mutator]MSP[N] final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR1Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[NegateConditionalsMutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ; MST[rv.ABSMutator]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[rv.CRCR2Mutator]MSP[N] } } return sb . toString () ; }
if ( ! ( obj instanceof String ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[InlineConstantMutator]MSP[S] } return str ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[rv.UOI1Mutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.UOI1Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR6Mutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; MST[rv.CRCR5Mutator]MSP[N] for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ; MST[VoidMethodCallMutator]MSP[N]
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.UOI2Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR2Mutator]MSP[S]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR1Mutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.CRCR1Mutator]MSP[N] final char ch = input . charAt ( index ) ;
for ( final String branch : branches ) { sb . append ( branch ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR2Mutator]MSP[N]
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ; MST[rv.CRCR1Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ABSMutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI2Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ABSMutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.AOR2Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI1Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI3Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; MST[rv.ABSMutator]MSP[N] final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
for ( final String branch : branches ) { sb . append ( branch ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.ROR2Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI1Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.UOI2Mutator]MSP[S] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR6Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.UOI1Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( branching ) {
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.ROR2Mutator]MSP[N] final char ch = input . charAt ( index ) ;
if ( Character . isWhitespace ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR2Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[rv.UOI4Mutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
result [ index ++ ] = branch . toString () ; } return result ; MST[ReturnValsMutator]MSP[N] }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR4Mutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String nextReplacement : replacements ) { MST[rv.UOI3Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ; MST[rv.UOI2Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR3Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { MST[rv.UOI4Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; MST[experimental.NakedReceiverMutator]MSP[N] final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } return str ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final Branch branch : currentBranches ) { branch . finish () ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.ROR4Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.UOI3Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR3Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.UOI2Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI3Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[InlineConstantMutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.ABSMutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[rv.CRCR2Mutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[rv.UOI3Mutator]MSP[N] if ( rules == null ) { continue; }
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; MST[rv.UOI1Mutator]MSP[N] } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; MST[InlineConstantMutator]MSP[N] for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.UOI1Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String branch : branches ) { MST[rv.UOI4Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR3Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.UOI4Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; MST[rv.UOI3Mutator]MSP[N] if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.ROR1Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ; MST[ConstructorCallMutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[NegateConditionalsMutator]MSP[N]
if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI3Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
if ( Character . isWhitespace ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.UOI3Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[N] }
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; MST[rv.CRCR3Mutator]MSP[N] for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR4Mutator]MSP[N]
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[rv.CRCR6Mutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR4Mutator]MSP[N]
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[NonVoidMethodCallMutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[NegateConditionalsMutator]MSP[S]
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ; MST[rv.CRCR5Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[NonVoidMethodCallMutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
for ( final String branch : branches ) { MST[rv.UOI1Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.UOI3Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
return soundex ( source , false ) [ 0 ] ; MST[InlineConstantMutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
for ( final String branch : branches ) { MST[rv.UOI4Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[NegateConditionalsMutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.ROR4Mutator]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( final String branch : branches ) { MST[rv.UOI3Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[rv.UOI2Mutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.CRCR2Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.ROR1Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR2Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[InlineConstantMutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI4Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[experimental.RemoveIncrementsMutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR5Mutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.UOI4Mutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.ROR5Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
index += rule . getPatternLength () - 1 ; MST[rv.AOD1Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[rv.UOI2Mutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; MST[rv.CRCR6Mutator]MSP[N] for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ;
nextBranches . clear () ; MST[VoidMethodCallMutator]MSP[N] } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.UOI3Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.CRCR6Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[rv.UOI4Mutator]MSP[N] if ( rules == null ) { continue; }
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; MST[NullReturnValsMutator]MSP[N] } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[NegateConditionalsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI3Mutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ABSMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI1Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[NegateConditionalsMutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR2Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
result [ index ++ ] = branch . toString () ; MST[rv.UOI2Mutator]MSP[N] } return result ; }
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ABSMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.UOI3Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return soundex ( source , false ) [ 0 ] ; MST[NonVoidMethodCallMutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[NonVoidMethodCallMutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[NegateConditionalsMutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI2Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR1Mutator]MSP[S]
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.ROR4Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.UOI3Mutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[NegateConditionalsMutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { return replacementAtStart ; MST[NullReturnValsMutator]MSP[N] } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[NegateConditionalsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] int index = 0 ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[NonVoidMethodCallMutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.ROR5Mutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.ROR2Mutator]MSP[N] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI4Mutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR3Mutator]MSP[N]
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { return replacementBeforeVowel ; MST[NullReturnValsMutator]MSP[N] } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ROR5Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ABSMutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ROR2Mutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[ConditionalsBoundaryMutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.ROR5Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.UOI2Mutator]MSP[N] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[NonVoidMethodCallMutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { return replacementAtStart ; MST[ReturnValsMutator]MSP[N] } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.UOI2Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR2Mutator]MSP[S]
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { return replacementBeforeVowel ; MST[ReturnValsMutator]MSP[N] } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[NegateConditionalsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ABSMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI1Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.ROR2Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ABSMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.CRCR1Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.CRCR3Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.CRCR5Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[NonVoidMethodCallMutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI2Mutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI4Mutator]MSP[S] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ABSMutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; MST[ReturnValsMutator]MSP[N] } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI2Mutator]MSP[N]
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.UOI4Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI4Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
if ( ! ( obj instanceof String ) ) { MST[rv.ROR3Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[NegateConditionalsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI3Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR2Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ABSMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR5Mutator]MSP[S]
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR5Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR2Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.ABSMutator]MSP[N] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.ROR4Mutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.ROR3Mutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR6Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.ROR1Mutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[NegateConditionalsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ABSMutator]MSP[N]
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[ReturnValsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { return replacementAtStart ; } final int nextIndex = getPatternLength () ; MST[NonVoidMethodCallMutator]MSP[S]
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ROR4Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ROR1Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.ROR3Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[rv.UOI2Mutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( MST[ConstructorCallMutator]MSP[N] lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR2Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.ROR1Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.ROR3Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.UOI4Mutator]MSP[S] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR1Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR3Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI3Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.ROR3Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.UOI1Mutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR5Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI1Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.UOI4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.ROR4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; MST[InlineConstantMutator]MSP[N] if ( nextCharIsVowel ) { return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[BooleanTrueReturnValsMutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI2Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final boolean nextCharIsVowel = nextIndex < context . length () ? isVowel ( context . charAt ( nextIndex ) ) : false ; if ( nextCharIsVowel ) { MST[rv.UOI1Mutator]MSP[N] return replacementBeforeVowel ; } return replacementDefault ; } private boolean isVowel ( final char ch ) {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public String toString () {
public int getPatternLength () { return pattern . length () ; } public String [] getReplacements ( final String context , final boolean atStart ) { if ( atStart ) { MST[rv.ABSMutator]MSP[N] return replacementAtStart ; } final int nextIndex = getPatternLength () ;
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR3Mutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[rv.CRCR4Mutator]MSP[S] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ; MST[InlineConstantMutator]MSP[N] } public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } @Override public String toString () {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR4Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ;
for ( final String branch : branches ) { MST[rv.UOI3Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.ABSMutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR1Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.ROR2Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
result [ index ++ ] = branch . toString () ; MST[experimental.RemoveIncrementsMutator]MSP[N] } return result ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[rv.CRCR1Mutator]MSP[N] } } return sb . toString () ; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR4Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[MathMutator]MSP[N] } return str ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[rv.CRCR6Mutator]MSP[N] } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { MST[rv.UOI3Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] continue; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.ROR3Mutator]MSP[N] final char ch = input . charAt ( index ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR4Mutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR5Mutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } return str ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( final Branch branch : currentBranches ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[rv.UOI3Mutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR4Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[InlineConstantMutator]MSP[S]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[NegateConditionalsMutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI2Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI2Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
return soundex ( source , false ) [ 0 ] ; MST[InlineConstantMutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.ROR1Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.UOI1Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
return soundex ( source , false ) [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI4Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.ABSMutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.ROR1Mutator]MSP[N] final char ch = input . charAt ( index ) ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; MST[NonVoidMethodCallMutator]MSP[N] int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { MST[rv.UOI2Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR3Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR5Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[NegateConditionalsMutator]MSP[N] if ( branching ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.UOI4Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR3Mutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } return str ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( rules == null ) { continue; }
if ( ! ( obj instanceof String ) ) { MST[rv.ROR4Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String branch : branches ) { MST[rv.ABSMutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[ConditionalsBoundaryMutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { MST[rv.UOI1Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[NegateConditionalsMutator]MSP[N] for ( final Branch branch : currentBranches ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; MST[rv.CRCR5Mutator]MSP[N] final StringBuilder sb = new StringBuilder () ; int index = 0 ;
if ( Character . isWhitespace ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.ROR1Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[rv.UOI2Mutator]MSP[N] if ( rules == null ) { continue; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.ABSMutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.ROR4Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR3Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[InlineConstantMutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; MST[rv.UOI1Mutator]MSP[N] final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI4Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.CRCR2Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.UOI3Mutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[rv.CRCR4Mutator]MSP[N] } } return sb . toString () ; }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ;
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.UOI2Mutator]MSP[N]
if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI2Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR6Mutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR4Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR4Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR2Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.UOI4Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
index += rule . getPatternLength () - 1 ; MST[rv.AOD1Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; MST[EmptyObjectReturnValsMutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[InlineConstantMutator]MSP[N] final char ch = input . charAt ( index ) ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.CRCR3Mutator]MSP[N] final char ch = input . charAt ( index ) ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR3Mutator]MSP[N]
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[ArgumentPropagationMutator]MSP[S] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; MST[rv.ABSMutator]MSP[N] } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( rules == null ) { continue; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI4Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI3Mutator]MSP[N]
return soundex ( source , false ) [ 0 ] ; } public String soundex ( final String source ) { final String [] branches = soundex ( source , true ) ; final StringBuilder sb = new StringBuilder () ; int index = 0 ; MST[rv.CRCR3Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR2Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.ROR5Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[rv.UOI1Mutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
if ( Character . isWhitespace ( ch ) ) { continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; MST[ArgumentPropagationMutator]MSP[N] if ( rules == null ) { continue; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR4Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[InlineConstantMutator]MSP[N] for ( final Branch branch : currentBranches ) {
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[NegateConditionalsMutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } return str ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ABSMutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; MST[VoidMethodCallMutator]MSP[N] if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[rv.UOI4Mutator]MSP[N]
if ( ! ( obj instanceof String ) ) { MST[NegateConditionalsMutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String branch : branches ) { MST[rv.UOI3Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.UOI2Mutator]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[rv.UOI1Mutator]MSP[S] sb . append ( '|' ) ; } } return sb . toString () ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.ABSMutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
index += rule . getPatternLength () - 1 ; MST[rv.CRCR6Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR6Mutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) { MST[rv.ROR5Mutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.UOI4Mutator]MSP[N] final char ch = input . charAt ( index ) ;
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return encode ( ( String ) obj ) ; } @Override public String encode ( final String source ) { if ( source == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] }
private String [] soundex ( final String source , final boolean branching ) { if ( source == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet <> () ;
for ( final String branch : branches ) { MST[rv.UOI2Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String branch : branches ) { MST[rv.UOI1Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR1Mutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[rv.ROR4Mutator]MSP[N] if ( branching ) {
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[rv.ROR3Mutator]MSP[N] if ( branching ) {
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return str ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.ROR4Mutator]MSP[S] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR2Mutator]MSP[N]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( branching ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[NegateConditionalsMutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR1Mutator]MSP[N]
index += rule . getPatternLength () - 1 ; MST[rv.AOD2Mutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { MST[rv.ABSMutator]MSP[N] final char ch = input . charAt ( index ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[InlineConstantMutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
if ( folding && FOLDINGS . containsKey ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR5Mutator]MSP[S]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI4Mutator]MSP[S]
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[rv.UOI4Mutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR4Mutator]MSP[N]
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.ROR3Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
result [ index ++ ] = branch . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } return result ; }
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR5Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
index += rule . getPatternLength () - 1 ; break; } } lastChar = ch ; MST[rv.UOI4Mutator]MSP[S] } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[rv.ROR2Mutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[rv.ROR3Mutator]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] sb . append ( '|' ) ; } } return sb . toString () ; }
if ( Character . isWhitespace ( ch ) ) { MST[rv.ROR5Mutator]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
nextBranch . processNextReplacement ( nextReplacement , force ) ; MST[rv.UOI2Mutator]MSP[N] if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String branch : branches ) { MST[rv.UOI2Mutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final boolean branchingRequired = replacements . length > 1 && branching ; for ( final Branch branch : currentBranches ) {
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { MST[rv.UOI1Mutator]MSP[N] continue; } ch = Character . toLowerCase ( ch ) ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ; MST[rv.ABSMutator]MSP[N]
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; MST[rv.CRCR5Mutator]MSP[N] } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { MST[rv.UOI2Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.CRCR6Mutator]MSP[N]
currentBranches . add ( new Branch () ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length () ; index ++ ) { final char ch = input . charAt ( index ) ; MST[rv.UOI1Mutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { MST[rv.ABSMutator]MSP[N] nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
for ( final String nextReplacement : replacements ) { MST[rv.UOI3Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR1Mutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; MST[rv.ABSMutator]MSP[N] } sb . append ( ch ) ; } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; MST[experimental.NakedReceiverMutator]MSP[N] final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
for ( final String branch : branches ) { sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
result [ index ++ ] = branch . toString () ; } return result ; MST[NullReturnValsMutator]MSP[N] }
result [ index ++ ] = branch . toString () ; MST[rv.UOI1Mutator]MSP[N] } return result ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR1Mutator]MSP[S]
final List < Branch > nextBranches = branching ? new ArrayList < Branch > () : Collections . <Branch > emptyList () ; MST[rv.UOI2Mutator]MSP[N] for ( final Rule rule : rules ) { if ( rule . matches ( inputContext ) ) { if ( branching ) {
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.UOI1Mutator]MSP[N]
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[rv.ROR2Mutator]MSP[N]
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; MST[NonVoidMethodCallMutator]MSP[N] }
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.UOI1Mutator]MSP[S] for ( final Branch branch : currentBranches ) {
for ( final String branch : branches ) { MST[rv.ABSMutator]MSP[N] sb . append ( branch ) ; if ( ++ index < branches . length ) { sb . append ( '|' ) ; } } return sb . toString () ; }
for ( final String nextReplacement : replacements ) { final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ; MST[InlineConstantMutator]MSP[N]
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI3Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
nextBranch . processNextReplacement ( nextReplacement , force ) ; if ( branching ) { nextBranches . add ( nextBranch ) ; } else { break; } } } if ( branching ) { MST[rv.ROR4Mutator]MSP[N] currentBranches . clear () ; currentBranches . addAll ( nextBranches ) ; }
if ( Character . isWhitespace ( ch ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] continue; } final String inputContext = input . substring ( index ) ; final List < Rule > rules = RULES . get ( ch ) ; if ( rules == null ) { continue; }
for ( final String nextReplacement : replacements ) { MST[rv.ABSMutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
index += rule . getPatternLength () - 1 ; MST[MathMutator]MSP[N] break; } } lastChar = ch ; } final String [] result = new String [ currentBranches . size () ] ; int index = 0 ; for ( final Branch branch : currentBranches ) { branch . finish () ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; MST[InlineConstantMutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
} private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder () ; for ( char ch : input . toCharArray () ) { MST[rv.UOI4Mutator]MSP[N] if ( Character . isWhitespace ( ch ) ) { continue; } ch = Character . toLowerCase ( ch ) ;
if ( folding && FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return sb . toString () ; } @Override public Object encode ( final Object obj ) throws EncoderException {
nextBranches . clear () ; } final String [] replacements = rule . getReplacements ( inputContext , lastChar == '\0' ) ; final boolean branchingRequired = replacements . length > 1 && branching ; MST[rv.CRCR4Mutator]MSP[N] for ( final Branch branch : currentBranches ) {
for ( final String nextReplacement : replacements ) { MST[rv.UOI1Mutator]MSP[N] final Branch nextBranch = branchingRequired ? branch . createBranch () : branch ; final boolean force = ( lastChar == 'm' && ch == 'n' ) || ( lastChar == 'n' && ch == 'm' ) ;
if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR2Mutator]MSP[N] str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ;
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; }
final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen () ) ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break; case '\u00C7' :
result . append ( 'S' ) ; index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index = handleH ( value , result , index ) ; break; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break; case 'K' : result . append ( 'K' ) ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; break; case 'Q' : result . append ( 'K' ) ;
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
index = handleS ( value , result , index , slavoGermanic ) ; break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; } @Override public String encode ( final String value ) {
return doubleMetaphone ( value ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { result . append ( 'A' ) ; } return index + 1 ; } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { index += 3 ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) &&
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { result . append ( 'K' , 'X' ) ; return index + 2 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { result . append ( lr_37 , lr_36 ) ; } else {
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else if ( contains ( value , index + 1 , 1 , lr_23 , lr_22 , lr_32 ) || contains ( value , index - 1 , 4 , lr_48 , lr_49 ) ) {
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) ||
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' &&
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) {
result . append ( 'K' ) ; } index += 2 ; } return index ; } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) {
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { result . append ( 'J' , ' ' ) ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
if ( charAt ( value , index + 1 ) == 'J' ) { index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) &&
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; } index += 3 ;
} else if ( ( index == 0 && contains ( value , index + 1 , 1 , lr_78 , lr_37 , lr_41 , lr_79 ) ) || contains ( value , index + 1 , 1 , lr_80 ) ) {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) {
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { result . appendAlternate ( 'S' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; }
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) {
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; index += 3 ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; } return index ; }
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
result . append ( 'A' , 'F' ) ; } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { result . append ( 'S' ) ; index ++ ; } else {
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; } return index ; }
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { result . append ( 'J' ) ; index += 2 ; } else {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; } private boolean conditionC0 ( final String value , final int index ) {
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; } private boolean conditionL0 ( final String value , final int index ) {
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
contains ( value , index - 1 , 4 , lr_133 ) ) { return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; } private boolean isSlavoGermanic ( final String value ) {
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
if ( input . length () == 0 ) { return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; } protected char charAt ( final String value , final int index ) {
if ( index < 0 || index >= value . length () ) { return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ;
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
public void append ( final String value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } public void append ( final String primary , final String alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
this . alternate . length () >= this . maxLength ; }
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.ROR1Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { MST[NegateConditionalsMutator]MSP[N] return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[InlineConstantMutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.AOD1Mutator]MSP[N] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.AOR3Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.UOI2Mutator]MSP[S]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.ROR4Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.ROR1Mutator]MSP[S] }
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.UOI1Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[NegateConditionalsMutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ; MST[rv.CRCR6Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'H' :
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { MST[rv.ROR1Mutator]MSP[N] return false ;
if ( index == value . length () - 3 && MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else { result . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR1Mutator]MSP[N] final boolean slavoGermanic ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return index ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR1Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else { result . append ( 'X' ) ; } index += 2 ; MST[IncrementsMutator]MSP[N] } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; MST[InlineConstantMutator]MSP[N] index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break; case '\u00C7' :
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.AOD1Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.AOR3Mutator]MSP[N] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.ABSMutator]MSP[S]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.UOI3Mutator]MSP[S] index += 3 ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'S' ) ;
for ( final String element : criteria ) { MST[rv.UOI1Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.UOI3Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } return index ; }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.AOD2Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[InlineConstantMutator]MSP[N]
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.ROR4Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR3Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOD1Mutator]MSP[S] index = handleGH ( value , result , index ) ;
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { MST[rv.UOI4Mutator]MSP[N] result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'S' ) ; index ++ ; } else {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ABSMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'H' ) ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( 'S' ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.ROR1Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; MST[rv.CRCR3Mutator]MSP[N] } index += 2 ; } else {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; MST[rv.CRCR3Mutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; MST[rv.CRCR3Mutator]MSP[N] index += 2 ; } else {
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N]
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'Q' : result . append ( 'K' ) ;
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.ROR5Mutator]MSP[N]
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR3Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR2Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] } return index ; }
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] } return index ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) { MST[rv.ABSMutator]MSP[N]
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; MST[InlineConstantMutator]MSP[N] index ++ ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
return doubleMetaphone ( value ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { MST[NonVoidMethodCallMutator]MSP[S] result . append ( 'J' ) ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[InlineConstantMutator]MSP[S] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.ROR4Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.UOI3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] break; case '\u00C7' :
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } index += 2 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[InlineConstantMutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR3Mutator]MSP[N]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR2Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR4Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] result . append ( 'S' , 'X' ) ; } else {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[S] } return index ; }
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.ROR5Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] result . append ( 'K' ) ; return index + 2 ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] break;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.ROR1Mutator]MSP[N] } return index ; }
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.AOD2Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR1Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { MST[rv.ROR1Mutator]MSP[N] return false ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[S] index = handleGH ( value , result , index ) ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'S' ) ;
return handleCC ( value , result , index ) ; MST[PrimitiveReturnsMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR5Mutator]MSP[N] final boolean slavoGermanic ) {
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[rv.ABSMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR3Mutator]MSP[S] index = handleGH ( value , result , index ) ;
result . append ( 'X' ) ; index += 3 ; MST[experimental.RemoveIncrementsMutator]MSP[N] } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; index += 3 ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[S] } return index ; }
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR5Mutator]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR5Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI1Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; MST[rv.UOI2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_4 ) &&
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.UOI2Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { MST[rv.ROR4Mutator]MSP[S] if ( isVowel ( charAt ( value , index + 1 ) ) ) {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.ROR2Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[rv.CRCR1Mutator]MSP[S] } index += 3 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.UOI2Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR6Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR1Mutator]MSP[N] final boolean slavoGermanic ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.AOR2Mutator]MSP[S]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N] }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.ABSMutator]MSP[S] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; }
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[InlineConstantMutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR3Mutator]MSP[S] index = handleGH ( value , result , index ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR3Mutator]MSP[N]
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI3Mutator]MSP[N]
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] index += 2 ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI2Mutator]MSP[S] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[InlineConstantMutator]MSP[S]
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[NegateConditionalsMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[NegateConditionalsMutator]MSP[S]
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[S] break;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.UOI2Mutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.ABSMutator]MSP[N]
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; }
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'S' ) ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.UOI4Mutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ;
result . append ( lr_36 ) ; } index = index + 2 ; MST[rv.CRCR1Mutator]MSP[S] } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { result . append ( lr_40 , lr_41 ) ; index += 2 ;
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR4Mutator]MSP[S]
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR1Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR5Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] } return index ; }
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
if ( charAt ( value , index + 1 ) == 'J' ) { index += 2 ; } else { index ++ ; } } return index ; MST[rv.UOI3Mutator]MSP[N] } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.ROR1Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[NonVoidMethodCallMutator]MSP[S]
if ( input . length () == 0 ) { return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[N] } protected char charAt ( final String value , final int index ) {
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_37 , lr_36 ) ; } else {
index ++ ; result . append ( 'L' ) ; } return index ; MST[ReturnValsMutator]MSP[N] } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR5Mutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( slavoGermanic ) {
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[VoidMethodCallMutator]MSP[S] } index += 3 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.AOR1Mutator]MSP[N]
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.SwitchMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[NegateConditionalsMutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR2Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.ROR2Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( index < 0 || index >= value . length () ) { MST[rv.ROR3Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR4Mutator]MSP[S]
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.ROR5Mutator]MSP[S]
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR2Mutator]MSP[S] } } else {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.AOR2Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR6Mutator]MSP[N]
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.ROR3Mutator]MSP[N]
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; MST[rv.CRCR5Mutator]MSP[S] } index += 2 ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'J' , ' ' ) ;
if ( charAt ( value , index + 1 ) == 'J' ) { MST[rv.UOI3Mutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index = handleS ( value , result , index , slavoGermanic ) ; break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ; MST[rv.CRCR5Mutator]MSP[N]
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ; MST[ReturnValsMutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { result . append ( 'R' ) ; }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR2Mutator]MSP[N]
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'J' ) ; }
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR3Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; } @Override public String encode ( final String value ) {
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; MST[rv.UOI1Mutator]MSP[N] }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.UOI1Mutator]MSP[S]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[NonVoidMethodCallMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.AOR3Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[MathMutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S]
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR1Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[InlineConstantMutator]MSP[N]
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[rv.CRCR2Mutator]MSP[S] } index += 3 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR4Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.ROR3Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR4Mutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
if ( value . startsWith ( element ) ) { result = true ; MST[rv.CRCR5Mutator]MSP[N] break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[rv.CRCR2Mutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
if ( index == value . length () - 3 && MST[NonVoidMethodCallMutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.UOI2Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.UOI3Mutator]MSP[S] result . append ( 'K' ) ; index += 2 ;
if ( index == value . length () - 3 && MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] } return index ; }
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
if ( index == value . length () - 3 && MST[rv.UOI1Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR4Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI4Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR5Mutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } return index ; }
for ( final String element : criteria ) { MST[rv.UOI4Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[NegateConditionalsMutator]MSP[S] final boolean slavoGermanic ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ; MST[rv.CRCR4Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[NegateConditionalsMutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.CRCR4Mutator]MSP[N]
if ( contains ( value , index , 4 , lr_114 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR6Mutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ; }
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.UOI4Mutator]MSP[N]
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[rv.ROR3Mutator]MSP[S] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR1Mutator]MSP[N]
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.UOI1Mutator]MSP[S]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
result . append ( 'A' , 'F' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR5Mutator]MSP[S] if ( slavoGermanic ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR2Mutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.UOI1Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.ROR5Mutator]MSP[N] }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) {
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[InlineConstantMutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.ABSMutator]MSP[N] break; case 'H' :
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[rv.UOI3Mutator]MSP[N] }
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI4Mutator]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { index += 3 ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.ROR1Mutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
if ( index == value . length () - 3 && MST[rv.ROR5Mutator]MSP[S] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[PrimitiveReturnsMutator]MSP[N] }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; MST[VoidMethodCallMutator]MSP[N] } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR4Mutator]MSP[N]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[S] } return index ; }
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
index = handleX ( value , result , index ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[NegateConditionalsMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , index , 4 , lr_114 ) ) { MST[InlineConstantMutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR1Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] break; case '\u00C7' :
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[PrimitiveReturnsMutator]MSP[N]
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; MST[rv.CRCR5Mutator]MSP[N] index += 2 ; } else { index ++ ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR1Mutator]MSP[N] index += 3 ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.ABSMutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; MST[rv.CRCR6Mutator]MSP[N] } index += 2 ;
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case '\u00C7' :
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.CRCR5Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR2Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR1Mutator]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR4Mutator]MSP[N] index += 3 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( slavoGermanic ) {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[InlineConstantMutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.AOR4Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR3Mutator]MSP[N]
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR2Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] } return index ; }
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.ROR5Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.AOR1Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'S' ) ;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.AOR1Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.AOD2Mutator]MSP[N]
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR6Mutator]MSP[N]
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR5Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.CRCR3Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.AOD1Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; MST[rv.UOI4Mutator]MSP[N] break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR4Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR1Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.AOR2Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR2Mutator]MSP[S]
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.ABSMutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR1Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR2Mutator]MSP[N]
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR2Mutator]MSP[N]
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; MST[InlineConstantMutator]MSP[N] } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'H' ) ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR2Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.AOD2Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.ROR1Mutator]MSP[N] index = handleGH ( value , result , index ) ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break; case '\u00C7' :
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.AOR1Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; MST[InlineConstantMutator]MSP[S] } else { index ++ ; result . append ( 'K' ) ; } return index ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[NegateConditionalsMutator]MSP[S]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[NegateConditionalsMutator]MSP[N]
result . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[InlineConstantMutator]MSP[N]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] } return index ; }
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[MathMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.AOR1Mutator]MSP[N] return false ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
contains ( value , index - 1 , 4 , lr_133 ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
result . append ( 'K' ) ; } index += 2 ; } return index ; MST[rv.UOI1Mutator]MSP[N] } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[rv.UOI3Mutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[InlineConstantMutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.ROR5Mutator]MSP[S]
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; MST[rv.ABSMutator]MSP[N] break; case 'M' : result . append ( 'M' ) ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; } public int getMaxCodeLen () { return this . maxCodeLen ; MST[rv.ABSMutator]MSP[N] } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.UOI4Mutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] } else {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ; }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.ROR2Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.UOI2Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[InlineConstantMutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR1Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } return contains ( value , index - 1 , 3 , lr_136 ) &&
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.ROR5Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR5Mutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'F' ) ; MST[InlineConstantMutator]MSP[S] index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
case '\u00D1' : result . append ( 'N' ) ; MST[InlineConstantMutator]MSP[S] index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; break; case 'Q' : result . append ( 'K' ) ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.CRCR5Mutator]MSP[N]
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.ROR2Mutator]MSP[S] result . append ( lr_37 , lr_36 ) ; } else {
result . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } index += 2 ; } return index ; } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[NonVoidMethodCallMutator]MSP[S] } return index ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.ROR1Mutator]MSP[N] } return index ; }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
result . append ( 'A' , 'F' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] } return index ; }
index = handleS ( value , result , index , slavoGermanic ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ;
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR5Mutator]MSP[S]
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.AOR4Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] break; case '\u00C7' :
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.CRCR1Mutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; MST[rv.UOI2Mutator]MSP[N] }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.CRCR6Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
index ++ ; result . append ( 'L' ) ; MST[rv.CRCR6Mutator]MSP[N] } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[rv.UOI4Mutator]MSP[S]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.ROR2Mutator]MSP[S] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.ROR1Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[S] break;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR3Mutator]MSP[N]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[S] } return index ; }
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.UOI4Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI3Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
if ( charAt ( value , index + 1 ) == 'J' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ; }
for ( final String element : criteria ) { MST[rv.UOI3Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.UOI4Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR2Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[ConditionalsBoundaryMutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR2Mutator]MSP[S] } index += 2 ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; MST[VoidMethodCallMutator]MSP[N] } else { result . append ( 'K' ) ; } index += 2 ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'M' : result . append ( 'M' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[InlineConstantMutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.ABSMutator]MSP[S]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.ROR1Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) {
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'K' ) ;
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; break; case 'Q' : result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N]
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.UOI1Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[S] break; case '\u00C7' :
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOR2Mutator]MSP[N]
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR2Mutator]MSP[S]
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[S] index += 2 ; } return index ; }
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] result . append ( 'K' ) ; return index + 2 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.UOI4Mutator]MSP[N]
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.AOD2Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
result . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; index += 3 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[NonVoidMethodCallMutator]MSP[S] result . append ( 'K' ) ; return index + 2 ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR1Mutator]MSP[S] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR1Mutator]MSP[N]
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[NegateConditionalsMutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } return index ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.ROR2Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
if ( charAt ( value , index + 1 ) == 'M' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
for ( final String element : criteria ) { if ( target . equals ( element ) ) { MST[rv.ROR3Mutator]MSP[N] result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.AOR3Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
if ( index == value . length () - 3 && MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
result . append ( 'X' ) ; } return index + 2 ; MST[rv.AOD1Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { MST[NegateConditionalsMutator]MSP[S] result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.UOI3Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR6Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean conditionL0 ( final String value , final int index ) {
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ABSMutator]MSP[S] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || contains ( value , 0 , 3 , lr_52 ) ) { MST[rv.ROR1Mutator]MSP[N] result . appendAlternate ( 'F' ) ; index ++ ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( contains ( value , index + 1 , 1 , lr_23 , lr_22 , lr_32 ) || contains ( value , index - 1 , 4 , lr_48 , lr_49 ) ) { MST[NegateConditionalsMutator]MSP[N]
} else if ( index == 0 ) { MST[rv.UOI2Mutator]MSP[S] if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
result . append ( 'X' ) ; } return index + 2 ; MST[rv.CRCR4Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR5Mutator]MSP[S] } else {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , index - 1 , 4 , lr_133 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.ROR2Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
index = handleS ( value , result , index , slavoGermanic ) ; break; case 'T' : index = handleT ( value , result , index ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'V' : result . append ( 'F' ) ;
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } } else {
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
result . append ( 'X' ) ; } return index + 2 ; MST[rv.AOR3Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.AOD1Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR3Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; index += 3 ; MST[IncrementsMutator]MSP[N] } else { result . append ( lr_33 ) ; index += 2 ; }
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR2Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' ) ;
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; MST[InlineConstantMutator]MSP[N] index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.ROR3Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { MST[rv.UOI4Mutator]MSP[N] return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
index = handleH ( value , result , index ) ; break; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break; case 'K' : result . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.ROR2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.AOD1Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
if ( input . length () == 0 ) { return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected char charAt ( final String value , final int index ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( lr_62 , lr_105 ) ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] index += 2 ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.CRCR6Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR6Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.AOR4Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.ROR2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; MST[rv.CRCR4Mutator]MSP[N] }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.ROR2Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI2Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.ROR1Mutator]MSP[N] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.ROR1Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[NegateConditionalsMutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.UOI3Mutator]MSP[N]
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[InlineConstantMutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR3Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ; MST[VoidMethodCallMutator]MSP[S]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.UOI3Mutator]MSP[S] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
if ( charAt ( value , index + 1 ) == 'J' ) { MST[rv.ABSMutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[N] index ++ ; } return index ; }
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; MST[InlineConstantMutator]MSP[S] index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[InlineConstantMutator]MSP[N]
index = handleS ( value , result , index , slavoGermanic ) ; break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ; MST[rv.CRCR4Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.ROR2Mutator]MSP[N] break; case '\u00C7' :
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.AOR1Mutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.UOI1Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.ROR4Mutator]MSP[S] }
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
if ( charAt ( value , index + 1 ) == 'J' ) { index += 2 ; } else { index ++ ; } } return index ; MST[rv.ABSMutator]MSP[N] } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[InlineConstantMutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'S' ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI4Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.ROR1Mutator]MSP[S] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[MathMutator]MSP[S] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[NegateConditionalsMutator]MSP[N] return false ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.ROR5Mutator]MSP[S]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.AOR1Mutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR3Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[S] index += 2 ; } return index ; }
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.ROR4Mutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } return index ; }
contains ( value , index - 1 , 4 , lr_133 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.AOD1Mutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.AOR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ; MST[rv.CRCR3Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.ROR3Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } index += 2 ; } return index ; } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[S] break; case '\u00C7' :
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR3Mutator]MSP[S] } index += 2 ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[InlineConstantMutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; MST[rv.ABSMutator]MSP[N] }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.ABSMutator]MSP[N]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR3Mutator]MSP[N]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean isSlavoGermanic ( final String value ) {
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR6Mutator]MSP[N] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.UOI3Mutator]MSP[S] break; case 'H' :
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( charAt ( value , index + 1 ) == 'J' ) { index += 2 ; } else { index ++ ; } } return index ; MST[rv.UOI2Mutator]MSP[N] } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ; }
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.ROR3Mutator]MSP[S]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR4Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[MathMutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[MathMutator]MSP[N]
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.AOR4Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.ROR4Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[InlineConstantMutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.AOR1Mutator]MSP[N]
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI4Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
public String doubleMetaphone ( final String value ) { MST[experimental.MemberVariableMutator]MSP[N] return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[rv.CRCR3Mutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; MST[rv.CRCR4Mutator]MSP[N] } index += 2 ; } else {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; MST[rv.CRCR4Mutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; MST[rv.CRCR4Mutator]MSP[N] index += 2 ; } else {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[MathMutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) { MST[rv.UOI1Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.UOI2Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' &&
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.CRCR5Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.ROR3Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; } return index ; MST[ReturnValsMutator]MSP[N] }
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[S] break;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOD2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[MathMutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { result . append ( 'K' ) ; } index += 2 ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR1Mutator]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI3Mutator]MSP[N]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( charAt ( value , index + 1 ) == 'J' ) { MST[InlineConstantMutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
result . append ( 'F' ) ; MST[InlineConstantMutator]MSP[N] index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'S' ) ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR5Mutator]MSP[N]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( index < 0 || index >= value . length () ) { return Character . MIN_VALUE ; } return value . charAt ( index ) ; MST[rv.UOI1Mutator]MSP[N] } protected static boolean contains ( final String value , final int start , final int length ,
for ( final String element : criteria ) { MST[rv.UOI3Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.AOR1Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else { result . append ( 'T' ) ; MST[InlineConstantMutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ;
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.AOR4Mutator]MSP[N]
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[MathMutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR4Mutator]MSP[N]
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
if ( index == value . length () - 3 && MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.UOI1Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else { result . append ( 'J' , 'H' ) ; } index ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOD2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[NegateConditionalsMutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'J' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.UOI1Mutator]MSP[S]
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; } index += 3 ; MST[IncrementsMutator]MSP[N]
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.UOI4Mutator]MSP[N]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.CRCR2Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR2Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[rv.CRCR1Mutator]MSP[S] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ; MST[rv.UOI1Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.UOI1Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.ROR1Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ; MST[experimental.NakedReceiverMutator]MSP[S]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.ROR1Mutator]MSP[N] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[InlineConstantMutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR6Mutator]MSP[S] if ( slavoGermanic ) {
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR4Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[rv.UOI3Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'S' ) ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[S] break; case '\u00C7' :
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.CRCR2Mutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR1Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( index == 0 ) { MST[rv.ABSMutator]MSP[N] if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.AOR3Mutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.AOD2Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; } public int getMaxCodeLen () { return this . maxCodeLen ; MST[rv.UOI2Mutator]MSP[N] } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' &&
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.AOD1Mutator]MSP[N]
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.UOI2Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; MST[rv.UOI2Mutator]MSP[N] } private boolean conditionC0 ( final String value , final int index ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR2Mutator]MSP[N]
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.ROR5Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.UOI4Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[InlineConstantMutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.ABSMutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ; MST[rv.CRCR1Mutator]MSP[S]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.CRCR2Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR5Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.CRCR5Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'H' :
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
if ( ! ( ( index == value . length () - 1 ) && MST[InlineConstantMutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[S] } return index ; }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR2Mutator]MSP[N]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR5Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.ROR2Mutator]MSP[S]
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'A' ) ; } return index + 1 ; } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.UOI1Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'S' ) ;
if ( index == value . length () - 3 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.UOI4Mutator]MSP[S]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.UOI4Mutator]MSP[S] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.ROR4Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } index += 2 ;
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] } return index ; }
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; MST[rv.CRCR1Mutator]MSP[N] index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[InlineConstantMutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'J' , ' ' ) ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.CRCR6Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[NegateConditionalsMutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR4Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } return index ; }
if ( input . length () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; } protected char charAt ( final String value , final int index ) {
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.ROR1Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[ArgumentPropagationMutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
result . append ( 'X' , 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR2Mutator]MSP[N]
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.ABSMutator]MSP[N] break; case 'H' :
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR1Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR4Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; } @Override public String encode ( final String value ) {
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'K' ) ; index += 2 ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[InlineConstantMutator]MSP[S] }
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[rv.CRCR5Mutator]MSP[S] result . append ( lr_62 , lr_105 ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR4Mutator]MSP[S] index = handleGH ( value , result , index ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR4Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.ROR1Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; MST[IncrementsMutator]MSP[N] } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
if ( index < 0 || index >= value . length () ) { MST[rv.ROR4Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR5Mutator]MSP[S]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } return contains ( value , index - 1 , 3 , lr_136 ) &&
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR3Mutator]MSP[S] } } else {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.ROR5Mutator]MSP[S]
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.ROR5Mutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR1Mutator]MSP[S] result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR1Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[rv.CRCR2Mutator]MSP[S] } index += 3 ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; MST[rv.UOI1Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_4 ) &&
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.UOI1Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR5Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR1Mutator]MSP[N]
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; MST[rv.CRCR6Mutator]MSP[S] } index += 2 ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[NonVoidMethodCallMutator]MSP[S]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ; MST[rv.CRCR1Mutator]MSP[S]
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.AOR3Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.AOR3Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[VoidMethodCallMutator]MSP[N] } } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ABSMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.ABSMutator]MSP[N] result . appendAlternate ( 'S' ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR5Mutator]MSP[S]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[NonVoidMethodCallMutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.AOR4Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.UOI1Mutator]MSP[S] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR4Mutator]MSP[N]
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[rv.UOI3Mutator]MSP[N]
for ( final String element : criteria ) { MST[rv.UOI2Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.UOI3Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI2Mutator]MSP[S] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.UOI4Mutator]MSP[S]
if ( charAt ( value , index + 1 ) == 'M' ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.UOI1Mutator]MSP[S]
} else { result . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR2Mutator]MSP[N]
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[NegateConditionalsMutator]MSP[S] result . append ( 'S' ) ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'H' ) ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( ( index == 0 && contains ( value , index + 1 , 1 , lr_78 , lr_37 , lr_41 , lr_79 ) ) || contains ( value , index + 1 , 1 , lr_80 ) ) { MST[NegateConditionalsMutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR4Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[rv.ROR2Mutator]MSP[N] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.UOI3Mutator]MSP[N]
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[rv.UOI2Mutator]MSP[N] }
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR1Mutator]MSP[N]
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { index += 3 ;
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[rv.CRCR2Mutator]MSP[N] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.ROR3Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR6Mutator]MSP[S]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.ROR5Mutator]MSP[S]
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.AOR4Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[InlineConstantMutator]MSP[N]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[InlineConstantMutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI2Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI3Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR1Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[rv.ABSMutator]MSP[N] }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR3Mutator]MSP[N]
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[experimental.NakedReceiverMutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.AOR1Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR6Mutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } return index ; }
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.ROR2Mutator]MSP[S]
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[S]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR2Mutator]MSP[N]
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR2Mutator]MSP[N]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } return index ; }
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ; MST[InlineConstantMutator]MSP[S]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.ROR4Mutator]MSP[N]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR5Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[S] } return index ; }
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[MathMutator]MSP[N] result . appendAlternate ( 'S' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.AOR4Mutator]MSP[N]
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; break; case 'Q' : result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOR1Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { MST[rv.ROR5Mutator]MSP[N] result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; }
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.ROR1Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; }
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } } else {
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[NegateConditionalsMutator]MSP[N]
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'A' , 'F' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( index == value . length () - 3 && MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] break;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'H' ) ;
index = handleS ( value , result , index , slavoGermanic ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( slavoGermanic ) {
if ( index == value . length () - 3 && MST[rv.ROR4Mutator]MSP[S] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR1Mutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.CRCR5Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.ABSMutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.ROR1Mutator]MSP[S] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; MST[InlineConstantMutator]MSP[S] index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR6Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[MathMutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.UOI2Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR3Mutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'K' ) ; return index + 2 ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[rv.ROR2Mutator]MSP[S] result . append ( lr_62 , lr_105 ) ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { MST[NonVoidMethodCallMutator]MSP[N]
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] break;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.ROR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
result . append ( 'X' ) ; } return index + 2 ; MST[rv.AOR2Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
! contains ( value , index - 2 , 4 , lr_5 ) ) { MST[NegateConditionalsMutator]MSP[S] result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; MST[rv.CRCR6Mutator]MSP[S] } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) {
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { result . append ( 'J' ) ; MST[InlineConstantMutator]MSP[N] index += 2 ; } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.UOI2Mutator]MSP[S] result . append ( 'K' ) ; index += 2 ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'K' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } return index ; }
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[ReturnValsMutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
index = handleX ( value , result , index ) ; MST[rv.UOI2Mutator]MSP[N] break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; MST[rv.CRCR6Mutator]MSP[N] final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen () ) ;
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.ROR4Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'S' , 'X' ) ; } else {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR4Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR3Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] break;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[MathMutator]MSP[N]
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break; case '\u00C7' :
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.ROR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ; } else { index ++ ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { result . appendAlternate ( 'S' ) ; MST[InlineConstantMutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR1Mutator]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR2Mutator]MSP[N] index += 3 ;
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.AOD2Mutator]MSP[S] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; MST[rv.CRCR5Mutator]MSP[N] }
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] } return index ; }
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[MathMutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.ABSMutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; MST[rv.ABSMutator]MSP[N] } private boolean conditionC0 ( final String value , final int index ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] result . append ( 'J' ) ; }
if ( index == value . length () - 3 && MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI1Mutator]MSP[N]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ; }
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.ROR2Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ; }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; MST[ReturnValsMutator]MSP[N] } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; }
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR3Mutator]MSP[S]
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR3Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR3Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.ROR3Mutator]MSP[S] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.ROR3Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.CRCR6Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR5Mutator]MSP[N] index += 3 ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR3Mutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( slavoGermanic ) {
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.ROR3Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.ROR3Mutator]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) {
} else { result . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[InlineConstantMutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.AOR4Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; MST[InlineConstantMutator]MSP[S] index += 2 ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; MST[rv.ABSMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_4 ) &&
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.ABSMutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
contains ( value , index - 1 , 4 , lr_133 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[NegateConditionalsMutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.UOI1Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.UOI4Mutator]MSP[S] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[NegateConditionalsMutator]MSP[S]
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR6Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.ROR3Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.UOI2Mutator]MSP[S] contains ( value , index - 2 , 2 , lr_64 ) &&
contains ( value , index - 1 , 4 , lr_133 ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
for ( final String element : criteria ) { if ( target . equals ( element ) ) { MST[rv.ROR2Mutator]MSP[N] result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] return index + 2 ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR5Mutator]MSP[S] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] } return index ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } return index ; }
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.UOI2Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[MathMutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.AOD1Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.AOR4Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.ABSMutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[InlineConstantMutator]MSP[N]
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'S' ) ; index ++ ; } else {
result . append ( 'X' ) ; } return index + 2 ; MST[rv.CRCR5Mutator]MSP[S] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; MST[VoidMethodCallMutator]MSP[N] index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; MST[rv.CRCR2Mutator]MSP[N] break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; MST[rv.ABSMutator]MSP[N] }
result . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } return index ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR3Mutator]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[InlineConstantMutator]MSP[N] index += 3 ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR4Mutator]MSP[N] final boolean slavoGermanic ) {
if ( index == value . length () - 3 && MST[rv.AOR1Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
index = handleS ( value , result , index , slavoGermanic ) ; break; case 'T' : index = handleT ( value , result , index ) ; MST[rv.ABSMutator]MSP[N] break; case 'V' : result . append ( 'F' ) ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.ROR4Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR6Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR6Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) {
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.CRCR6Mutator]MSP[N]
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[ReturnValsMutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.CRCR5Mutator]MSP[N]
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[rv.UOI4Mutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[NegateConditionalsMutator]MSP[N] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR2Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR3Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[ConditionalsBoundaryMutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
return handleCC ( value , result , index ) ; MST[rv.UOI4Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR6Mutator]MSP[S] index = handleGH ( value , result , index ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[ConditionalsBoundaryMutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[InlineConstantMutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.UOI2Mutator]MSP[S]
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[S] break; case '\u00C7' :
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[MathMutator]MSP[N]
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
if ( conditionC0 ( value , index ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.UOI3Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[NonVoidMethodCallMutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; MST[rv.CRCR3Mutator]MSP[N] index += 2 ; } else { index ++ ;
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[rv.CRCR2Mutator]MSP[S] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOR3Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR1Mutator]MSP[N]
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.ROR4Mutator]MSP[N] result . append ( lr_37 , lr_36 ) ; } else {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[NonVoidMethodCallMutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
if ( charAt ( value , index + 1 ) == 'J' ) { MST[NonVoidMethodCallMutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.ROR1Mutator]MSP[N] break;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.CRCR3Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.CRCR3Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.AOR2Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR4Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.ABSMutator]MSP[S] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.ABSMutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[MathMutator]MSP[S] break;
} else if ( index == 0 ) { MST[rv.UOI1Mutator]MSP[S] if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.AOR3Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOD1Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { MST[NegateConditionalsMutator]MSP[N] index += 2 ; } else { index ++ ; } }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } return contains ( value , index - 1 , 3 , lr_136 ) &&
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.ROR3Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } return index ; }
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.ABSMutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.UOI3Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.ROR1Mutator]MSP[N]
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[NegateConditionalsMutator]MSP[N]
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; MST[InlineConstantMutator]MSP[N] index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOR3Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'M' : result . append ( 'M' ) ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR5Mutator]MSP[N] index += 3 ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.UOI2Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[InlineConstantMutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[InlineConstantMutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.UOI1Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { result . append ( 'A' ) ; MST[InlineConstantMutator]MSP[N] } return index + 1 ; } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { MST[rv.UOI3Mutator]MSP[N] return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR2Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.AOR2Mutator]MSP[N]
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR2Mutator]MSP[S]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR6Mutator]MSP[S] } else {
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.ROR4Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; MST[rv.ABSMutator]MSP[N] break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) {
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[rv.CRCR4Mutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ; MST[rv.CRCR1Mutator]MSP[S]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
result . append ( 'A' , 'F' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
result . append ( 'X' , 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[MathMutator]MSP[N] return false ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ; MST[rv.CRCR1Mutator]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'S' ) ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; MST[rv.UOI1Mutator]MSP[N] } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { result . append ( lr_40 , lr_41 ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.AOD1Mutator]MSP[N]
result . append ( 'X' ) ; } return index + 2 ; MST[rv.AOD2Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
result . append ( lr_36 ) ; } index = index + 2 ; MST[rv.UOI4Mutator]MSP[S] } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; MST[ArgumentPropagationMutator]MSP[N] if ( value == null ) { return null ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[InlineConstantMutator]MSP[N]
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
result . append ( 'J' , 'H' ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( index == value . length () - 1 ) { result . append ( 'J' , ' ' ) ;
result . append ( 'X' ) ; } return index + 2 ; MST[rv.CRCR3Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.ROR2Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'K' ) ; index += 2 ;
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.ROR5Mutator]MSP[S]
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; MST[rv.CRCR4Mutator]MSP[N] index += 2 ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.CRCR6Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR6Mutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR3Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[NegateConditionalsMutator]MSP[S] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR4Mutator]MSP[S] } } else {
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.UOI3Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR2Mutator]MSP[N]
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR1Mutator]MSP[N]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.AOD1Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'S' ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD2Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; MST[IncrementsMutator]MSP[N] } else {
result . append ( 'X' ) ; } return index + 2 ; MST[rv.CRCR6Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOR3Mutator]MSP[N]
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; MST[rv.UOI3Mutator]MSP[N] break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'J' ) ; }
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[S] break; case '\u00C7' :
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[MathMutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case '\u00C7' :
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.AOD1Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOD1Mutator]MSP[S]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.ABSMutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( slavoGermanic ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'K' ) ;
return doubleMetaphone ( value ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.UOI3Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR5Mutator]MSP[N]
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; break; case 'Q' : result . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR5Mutator]MSP[S]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR1Mutator]MSP[N] index = handleGH ( value , result , index ) ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( index == value . length () - 3 && MST[rv.AOR3Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[MathMutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
result . append ( 'S' , 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) {
result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } index += 2 ; } return index ; } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR1Mutator]MSP[S] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.ROR2Mutator]MSP[N] if ( slavoGermanic ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.ROR4Mutator]MSP[S]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
if ( index == value . length () - 3 && MST[rv.UOI2Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR5Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( input . length () == 0 ) { MST[rv.ROR4Mutator]MSP[N] return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; } protected char charAt ( final String value , final int index ) {
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; MST[InlineConstantMutator]MSP[N] } else { result . append ( 'L' ) ; } index += 2 ; } else {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR6Mutator]MSP[N]
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.AOR1Mutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR5Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.UOI4Mutator]MSP[S] break; case 'H' :
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] break;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[InlineConstantMutator]MSP[S] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { result . append ( 'R' ) ; }
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] } return index ; }
index = handleS ( value , result , index , slavoGermanic ) ; MST[rv.UOI2Mutator]MSP[N] break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ;
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
if ( value . startsWith ( element ) ) { MST[rv.ROR5Mutator]MSP[N] result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[NegateConditionalsMutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR1Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.UOI3Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.ROR1Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR6Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.AOR3Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR3Mutator]MSP[S]
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR3Mutator]MSP[S]
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.CRCR2Mutator]MSP[S]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ; }
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.ROR3Mutator]MSP[N] break; case '\u00C7' :
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { MST[rv.CRCR5Mutator]MSP[N]
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.ROR1Mutator]MSP[S] result . append ( lr_37 , lr_36 ) ; } else {
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
} else if ( index == 0 ) { MST[rv.UOI4Mutator]MSP[S] if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.CRCR5Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR5Mutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR4Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.ROR1Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.CRCR6Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.ROR5Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR2Mutator]MSP[N]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR4Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
if ( index == value . length () - 3 && MST[InlineConstantMutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
result . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
} else if ( conditionCH0 ( value , index ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.ABSMutator]MSP[N]
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[InlineConstantMutator]MSP[N] index += 3 ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.ROR3Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI3Mutator]MSP[S] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR6Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; MST[InlineConstantMutator]MSP[N] }
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final String target = value . substring ( start , start + length ) ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.UOI3Mutator]MSP[N]
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ; MST[InlineConstantMutator]MSP[S]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.ABSMutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[MathMutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] } return index ; }
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'K' , 'J' ) ; index += 2 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) { MST[NegateConditionalsMutator]MSP[S]
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.ROR3Mutator]MSP[N] }
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR2Mutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR2Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.ROR2Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
for ( final String element : criteria ) { MST[rv.ABSMutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
} else if ( conditionCH0 ( value , index ) ) { MST[rv.UOI2Mutator]MSP[S] result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'S' ) ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.CRCR6Mutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.ROR1Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
} else if ( conditionCH0 ( value , index ) ) { MST[rv.ABSMutator]MSP[N] result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'S' ) ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( final String element : criteria ) { MST[rv.UOI2Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.ROR4Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.UOI2Mutator]MSP[N]
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[InlineConstantMutator]MSP[S]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR4Mutator]MSP[N] index = handleGH ( value , result , index ) ;
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.ROR1Mutator]MSP[S] result . append ( 'S' ) ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.ABSMutator]MSP[N] result . append ( 'J' , 'A' ) ;
if ( index == value . length () - 3 && MST[MathMutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.ROR2Mutator]MSP[S] result . append ( lr_37 , lr_36 ) ; } else {
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.CRCR4Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR4Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR6Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; MST[rv.ROR1Mutator]MSP[N] }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR5Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.CRCR4Mutator]MSP[N]
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.ROR2Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.ROR3Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.ROR1Mutator]MSP[S] result . append ( 'H' ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOD1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[rv.UOI4Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR6Mutator]MSP[N]
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR5Mutator]MSP[S]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI2Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; MST[rv.CRCR2Mutator]MSP[N] }
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; MST[rv.CRCR2Mutator]MSP[N] index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR2Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.UOI3Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[RemoveConditionalMutator_ORDER_IF]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String encode ( final String value ) {
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[rv.CRCR3Mutator]MSP[S] } index += 3 ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) { MST[rv.UOI3Mutator]MSP[S]
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[MathMutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[MathMutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR6Mutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) {
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.UOI3Mutator]MSP[S]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR6Mutator]MSP[S]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.CRCR6Mutator]MSP[S] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.ROR3Mutator]MSP[N] } return index ; }
if ( input . length () == 0 ) { return null ; MST[ReturnValsMutator]MSP[N] } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; } protected char charAt ( final String value , final int index ) {
return handleCC ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.AOR1Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.AOD2Mutator]MSP[N]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.UOI2Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; MST[rv.ABSMutator]MSP[N] break; case 'Q' : result . append ( 'K' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; MST[ReturnValsMutator]MSP[N] }
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.ROR4Mutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.AOR4Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR4Mutator]MSP[N]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.ABSMutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.AOR2Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[ReturnValsMutator]MSP[S] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { result . append ( lr_105 , lr_106 ) ; index += 4 ; MST[IncrementsMutator]MSP[N] } else { index ++ ; } } return index ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR5Mutator]MSP[S]
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.AOR4Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR1Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[InlineConstantMutator]MSP[N]
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.AOD2Mutator]MSP[S] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] result . append ( 'K' ) ; index += 2 ;
for ( final String element : criteria ) { if ( target . equals ( element ) ) { MST[rv.ROR1Mutator]MSP[N] result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[PrimitiveReturnsMutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.ABSMutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.ROR4Mutator]MSP[S]
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.ROR1Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR2Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR1Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[NonVoidMethodCallMutator]MSP[N]
result . append ( 'A' , 'F' ) ; } else { result . append ( 'A' ) ; MST[VoidMethodCallMutator]MSP[S] } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.ROR5Mutator]MSP[S]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[InlineConstantMutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ; }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.UOI3Mutator]MSP[S]
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[rv.UOI1Mutator]MSP[N] }
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] break;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { result . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.AOD2Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.UOI2Mutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.AOR2Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[S]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.UOI3Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[NonVoidMethodCallMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] } return index ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.AOR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR6Mutator]MSP[S]
! contains ( value , index - 2 , 4 , lr_5 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { MST[rv.ROR4Mutator]MSP[N]
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( lr_37 , lr_36 ) ; } else {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.UOI3Mutator]MSP[S] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { MST[rv.UOI3Mutator]MSP[S] result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'S' ) ; index ++ ; } else {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.AOR3Mutator]MSP[N]
return doubleMetaphone ( value ) ; MST[ReturnValsMutator]MSP[N] } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.ROR5Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'M' : result . append ( 'M' ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR4Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR3Mutator]MSP[N] final boolean slavoGermanic ) {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.AOR2Mutator]MSP[S]
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[rv.UOI3Mutator]MSP[S] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) {
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; MST[rv.UOI4Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_4 ) &&
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[MathMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' &&
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.ROR2Mutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ; MST[InlineConstantMutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[InlineConstantMutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR4Mutator]MSP[N]
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { MST[NegateConditionalsMutator]MSP[N] return true ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR2Mutator]MSP[N] final boolean slavoGermanic ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.AOR1Mutator]MSP[N] result . append ( 'S' ) ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.ROR4Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR6Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR6Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[N]
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.CRCR6Mutator]MSP[N]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; MST[rv.CRCR3Mutator]MSP[N] break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; MST[InlineConstantMutator]MSP[N] } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
if ( index == value . length () - 3 && MST[rv.AOR4Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.ROR4Mutator]MSP[S] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.AOD1Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.AOR3Mutator]MSP[N] return false ;
case '\u00D1' : result . append ( 'N' ) ; index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'Q' : result . append ( 'K' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] } return index ; }
if ( input . length () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; } protected char charAt ( final String value , final int index ) {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.AOR4Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR2Mutator]MSP[N]
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] } return index ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.UOI3Mutator]MSP[S] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[InlineConstantMutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] break;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[InlineConstantMutator]MSP[N] result . appendAlternate ( 'S' ) ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] } return index ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.AOD2Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[rv.ABSMutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.AOR2Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOD2Mutator]MSP[S] index = handleGH ( value , result , index ) ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.CRCR3Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR6Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.UOI1Mutator]MSP[S] result . append ( 'K' ) ; index += 2 ;
return doubleMetaphone ( value ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; MST[ReturnValsMutator]MSP[N] } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; }
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( conditionCH0 ( value , index ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
if ( index == value . length () - 3 && MST[rv.ABSMutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
if ( conditionC0 ( value , index ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR6Mutator]MSP[N]
if ( index < 0 || index >= value . length () ) { MST[rv.ROR1Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[MathMutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR4Mutator]MSP[N]
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.ROR3Mutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR3Mutator]MSP[N]
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] break;
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; MST[rv.UOI3Mutator]MSP[N] }
contains ( value , index - 1 , 4 , lr_133 ) ) { return true ; } else { return false ; MST[ReturnValsMutator]MSP[S] } } private boolean conditionM0 ( final String value , final int index ) {
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( lr_36 , lr_37 ) ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
return doubleMetaphone ( value ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[rv.ROR4Mutator]MSP[S] result . append ( 'K' ) ; return index + 2 ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.ROR2Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[S] } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR6Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { result . append ( 'R' ) ; }
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.AOR3Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'H' :
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.UOI3Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOD1Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.UOI4Mutator]MSP[S]
final String ... criteria ) { boolean result = false ; MST[InlineConstantMutator]MSP[N] if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ;
if ( ! ( ( index == value . length () - 1 ) && MST[rv.ABSMutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.ROR4Mutator]MSP[S]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { result . append ( 'J' , 'H' ) ; MST[rv.CRCR6Mutator]MSP[S] } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.CRCR6Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[NonVoidMethodCallMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR6Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[rv.UOI1Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR4Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else { result . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; } private boolean conditionC0 ( final String value , final int index ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.ROR4Mutator]MSP[S] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ABSMutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI1Mutator]MSP[S] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.AOR4Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
result . append ( 'S' ) ; MST[InlineConstantMutator]MSP[S] index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR6Mutator]MSP[N] index += 3 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.UOI4Mutator]MSP[S]
! contains ( value , index + 2 , 2 , lr_25 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR2Mutator]MSP[N]
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[rv.UOI4Mutator]MSP[S] }
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR3Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[rv.CRCR4Mutator]MSP[N] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean conditionL0 ( final String value , final int index ) {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.AOR3Mutator]MSP[S] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; MST[rv.UOI2Mutator]MSP[N] }
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.ROR2Mutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.UOI2Mutator]MSP[N]
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { result . append ( 'A' ) ; MST[rv.CRCR6Mutator]MSP[N] } return index + 1 ; } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
} else { result . append ( 'J' , 'H' ) ; MST[rv.CRCR6Mutator]MSP[N] } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[NegateConditionalsMutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.ROR1Mutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[InlineConstantMutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] } return index ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.ABSMutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR5Mutator]MSP[N]
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; MST[rv.ABSMutator]MSP[N] break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI2Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( lr_62 , lr_105 ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[NonVoidMethodCallMutator]MSP[N]
} else { result . append ( 'X' ) ; MST[VoidMethodCallMutator]MSP[N] } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[NegateConditionalsMutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.CRCR2Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.CRCR5Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR1Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[MathMutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[NegateConditionalsMutator]MSP[S] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
if ( index == value . length () - 3 && MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR5Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[NegateConditionalsMutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'H' ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } } else {
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[InlineConstantMutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ; }
if ( index < 0 || index >= value . length () ) { return Character . MIN_VALUE ; MST[ReturnValsMutator]MSP[N] } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; MST[IncrementsMutator]MSP[N] } else { index ++ ; } }
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; MST[rv.ABSMutator]MSP[N] }
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
if ( conditionC0 ( value , index ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.UOI3Mutator]MSP[N]
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[InlineConstantMutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; MST[rv.CRCR6Mutator]MSP[N] index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; } @Override public String encode ( final String value ) {
result . append ( 'S' ) ; MST[VoidMethodCallMutator]MSP[N] } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { index += 3 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] return index + 2 ;
result . append ( lr_36 ) ; } index = index + 2 ; MST[MathMutator]MSP[N] } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
for ( final String element : criteria ) { if ( target . equals ( element ) ) { MST[rv.ROR4Mutator]MSP[N] result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] } return index ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.AOR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.ROR1Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
if ( ! ( ( index == value . length () - 1 ) && MST[rv.UOI2Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.ROR4Mutator]MSP[S]
if ( index == value . length () - 3 && MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { MST[rv.UOI4Mutator]MSP[N] return false ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.UOI2Mutator]MSP[S]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] } return index ; }
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[MathMutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[MathMutator]MSP[S]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( slavoGermanic ) {
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[InlineConstantMutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
result . append ( 'X' , 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR4Mutator]MSP[S]
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR4Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.AOR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'J' , 'A' ) ;
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] } return index ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR4Mutator]MSP[N]
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] return index + 2 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( slavoGermanic ) {
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR3Mutator]MSP[S]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
if ( value . startsWith ( element ) ) { result = true ; MST[rv.CRCR6Mutator]MSP[N] break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.ROR1Mutator]MSP[N]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR3Mutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR1Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { MST[rv.ROR2Mutator]MSP[N] return false ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.AOR3Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( slavoGermanic ) {
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.ROR4Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.ABSMutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; MST[ReturnValsMutator]MSP[N] }
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.UOI2Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.ROR3Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N] } else { index ++ ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[S] } return index ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[InlineConstantMutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOR4Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
final String ... criteria ) { boolean result = false ; MST[rv.CRCR1Mutator]MSP[N] if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( index < 0 || index >= value . length () ) { MST[rv.UOI1Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; MST[rv.CRCR5Mutator]MSP[N] } index += 2 ;
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
if ( charAt ( value , index + 1 ) == 'J' ) { MST[rv.ROR5Mutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( slavoGermanic ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.ROR4Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[rv.AOR1Mutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[InlineConstantMutator]MSP[N]
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[MathMutator]MSP[N] result . append ( 'J' , ' ' ) ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.AOD1Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[rv.UOI1Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] } else {
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; MST[rv.UOI3Mutator]MSP[N] break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.UOI4Mutator]MSP[N] index += 3 ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.ROR5Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( value . startsWith ( element ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( isVowel ( charAt ( value , index + 1 ) ) ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[InlineConstantMutator]MSP[S]
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { MST[rv.ROR5Mutator]MSP[N] if ( isVowel ( charAt ( value , index + 1 ) ) ) {
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; MST[NegateConditionalsMutator]MSP[N] }
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.UOI4Mutator]MSP[S] result . append ( lr_37 , lr_36 ) ; } else {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.AOD1Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOD2Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[InlineConstantMutator]MSP[N]
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean conditionL0 ( final String value , final int index ) {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.CRCR2Mutator]MSP[S] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.UOI3Mutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( index == value . length () - 3 && MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
index = handleS ( value , result , index , slavoGermanic ) ; MST[rv.UOI2Mutator]MSP[N] break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[S] index = handleGH ( value , result , index ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR6Mutator]MSP[N]
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR5Mutator]MSP[N]
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'S' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; MST[rv.CRCR1Mutator]MSP[N] }
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_62 , lr_105 ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[InlineConstantMutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR5Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
contains ( value , index - 1 , 4 , lr_133 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; MST[VoidMethodCallMutator]MSP[N] } else { result . append ( '0' , 'T' ) ; } index += 2 ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR1Mutator]MSP[N]
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.AOR2Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.UOI4Mutator]MSP[S] result . append ( 'K' ) ; index += 2 ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { MST[rv.ROR1Mutator]MSP[N] index += 2 ; } else { index ++ ; } }
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.ABSMutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.UOI2Mutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[rv.ROR1Mutator]MSP[S] result . append ( lr_62 , lr_105 ) ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } return index ; }
result . append ( 'A' , 'F' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; MST[rv.CRCR5Mutator]MSP[S] } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR4Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.CRCR2Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.ROR5Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.UOI2Mutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.AOR3Mutator]MSP[S]
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } index += 2 ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR2Mutator]MSP[N]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR5Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.AOD1Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] } return index ; }
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR6Mutator]MSP[N]
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[InlineConstantMutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR4Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
result . append ( 'A' , 'F' ) ; } else { result . append ( 'A' ) ; MST[rv.CRCR2Mutator]MSP[S] } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.ROR1Mutator]MSP[N]
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'S' ) ;
result . append ( 'K' ) ; } index += 2 ; } return index ; MST[rv.UOI2Mutator]MSP[N] } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( value . startsWith ( element ) ) { MST[NonVoidMethodCallMutator]MSP[N] result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR3Mutator]MSP[N] index += 3 ;
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[NonVoidMethodCallMutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
if ( charAt ( value , index + 1 ) == 'L' ) { MST[NonVoidMethodCallMutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
if ( charAt ( value , index + 1 ) == 'M' ) { MST[InlineConstantMutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[InlineConstantMutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( ! ( ( index == value . length () - 1 ) && MST[InlineConstantMutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR5Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[MathMutator]MSP[S]
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[NegateConditionalsMutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR6Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ; }
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.CRCR5Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
index ++ ; result . append ( 'L' ) ; MST[rv.CRCR5Mutator]MSP[N] } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
result . append ( 'X' , 'S' ) ; MST[VoidMethodCallMutator]MSP[N] } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR3Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[ConditionalsBoundaryMutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR5Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[N] index ++ ; } return index ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.ROR2Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ; MST[InlineConstantMutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.ROR3Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( index == value . length () - 3 && MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else { if ( index > 0 ) { MST[rv.ROR4Mutator]MSP[N] if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.AOR2Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[NonVoidMethodCallMutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI2Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.ABSMutator]MSP[N]
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR3Mutator]MSP[S]
result . append ( 'S' ) ; index ++ ; MST[IncrementsMutator]MSP[S] break; case 'C' : index = handleC ( value , result , index ) ; break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.UOI3Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; MST[rv.UOI3Mutator]MSP[N] } private boolean conditionC0 ( final String value , final int index ) {
public String doubleMetaphone ( final String value ) { MST[rv.CRCR4Mutator]MSP[N] return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[InlineConstantMutator]MSP[N]
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ; MST[ReturnValsMutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.ROR3Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; MST[rv.CRCR1Mutator]MSP[S] } } else {
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
index = handleSC ( value , result , index ) ; MST[rv.UOI1Mutator]MSP[N] } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { result . appendAlternate ( 'S' ) ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.CRCR6Mutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } return index ; }
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { MST[rv.ROR2Mutator]MSP[N] if ( isVowel ( charAt ( value , index + 1 ) ) ) {
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.ABSMutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[rv.CRCR3Mutator]MSP[S] } index += 3 ;
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { MST[rv.ROR1Mutator]MSP[N] return true ;
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[rv.UOI2Mutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.ROR1Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) {
for ( final String element : criteria ) { MST[rv.ABSMutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR6Mutator]MSP[N]
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.AOD2Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[InlineConstantMutator]MSP[S] if ( slavoGermanic ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] index = handleGH ( value , result , index ) ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR2Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.CRCR6Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[NonVoidMethodCallMutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.ROR3Mutator]MSP[S] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
index = handleS ( value , result , index , slavoGermanic ) ; break; case 'T' : index = handleT ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'V' : result . append ( 'F' ) ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOR1Mutator]MSP[N]
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' , ' ' ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR4Mutator]MSP[N]
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.CRCR2Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.ROR2Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
return index ; MST[ReturnValsMutator]MSP[N] } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) &&
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; MST[rv.CRCR6Mutator]MSP[N] } index += 2 ; } else {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; MST[rv.CRCR6Mutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ; } else {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[MathMutator]MSP[S]
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[NegateConditionalsMutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.AOR2Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.ROR2Mutator]MSP[N] index = handleGH ( value , result , index ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ; }
if ( value . startsWith ( element ) ) { result = true ; MST[rv.CRCR3Mutator]MSP[N] break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.CRCR2Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[InlineConstantMutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
result . append ( 'K' ) ; } index += 2 ; } return index ; MST[rv.ABSMutator]MSP[N] } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.UOI2Mutator]MSP[S]
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) { MST[rv.UOI4Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ; MST[rv.CRCR5Mutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.AOR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR6Mutator]MSP[S]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.AOR1Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
result . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; index += 3 ;
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.AOD1Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR1Mutator]MSP[S]
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR1Mutator]MSP[N]
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.AOD2Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.ROR5Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'X' , 'S' ) ;
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.CRCR3Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[NonVoidMethodCallMutator]MSP[N]
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR5Mutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR5Mutator]MSP[S] if ( slavoGermanic ) {
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.ROR2Mutator]MSP[N] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.AOR2Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[rv.CRCR1Mutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.UOI3Mutator]MSP[S] result . append ( 'S' ) ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.CRCR2Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else { result . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; }
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; } @Override public String encode ( final String value ) {
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( index == value . length () - 3 && MST[rv.AOD2Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR1Mutator]MSP[N]
result . append ( lr_36 ) ; } index = index + 2 ; MST[rv.CRCR3Mutator]MSP[S] } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.ROR1Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[VoidMethodCallMutator]MSP[N] } index += 2 ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[InlineConstantMutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[N] index ++ ; } return index ; }
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.AOD1Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
contains ( value , index - 1 , 4 , lr_133 ) ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.ROR2Mutator]MSP[N] } return index ; }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N]
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[MathMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR2Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
result . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.AOR2Mutator]MSP[N]
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } @Override public String encode ( final String value ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.ROR5Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[NegateConditionalsMutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { final String target = value . substring ( start , start + length ) ; MST[rv.UOI3Mutator]MSP[N]
result . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[S] index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] break;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.AOR2Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.AOD2Mutator]MSP[N] } private boolean conditionL0 ( final String value , final int index ) {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.ABSMutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } return contains ( value , index - 1 , 3 , lr_136 ) &&
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[ReturnValsMutator]MSP[N]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'S' ) ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ; MST[rv.CRCR2Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.ROR3Mutator]MSP[S] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.AOD2Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[NonVoidMethodCallMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.ROR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] break;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[NegateConditionalsMutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final boolean slavoGermanic ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.UOI4Mutator]MSP[N]
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { result . append ( 'A' ) ; } return index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.AOR2Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[MathMutator]MSP[N] } return index ; }
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { MST[rv.ROR2Mutator]MSP[N] return false ;
if ( index < 0 || index >= value . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR2Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR2Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.UOI3Mutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI2Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else { if ( index > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[NegateConditionalsMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR3Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.AOR2Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI1Mutator]MSP[N] final boolean slavoGermanic ) {
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[MathMutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR1Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR1Mutator]MSP[N] final boolean slavoGermanic ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR4Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( index == value . length () - 3 && MST[rv.ROR2Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] break; case '\u00C7' :
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.AOD1Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
if ( index < 0 || index >= value . length () ) { return Character . MIN_VALUE ; } return value . charAt ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; MST[VoidMethodCallMutator]MSP[N] } return index ; }
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.ROR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR3Mutator]MSP[N]
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR2Mutator]MSP[S] index = handleGH ( value , result , index ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR2Mutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; MST[rv.UOI3Mutator]MSP[N] }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) {
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR3Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.UOI1Mutator]MSP[S] index += 3 ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.UOI3Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.AOD2Mutator]MSP[N]
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.AOR4Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[NegateConditionalsMutator]MSP[N]
if ( index < 0 || index >= value . length () ) { MST[rv.ROR5Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] result . append ( 'K' ) ; } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI1Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR3Mutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } index += 2 ; } return index ; } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } index += 2 ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.UOI3Mutator]MSP[N]
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.ABSMutator]MSP[S]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'X' , 'S' ) ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[S] } return index ; }
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.ROR2Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ABSMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'S' ) ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ; MST[rv.CRCR6Mutator]MSP[N]
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[PrimitiveReturnsMutator]MSP[S] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] } return index ; }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR4Mutator]MSP[N]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[InlineConstantMutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { result . append ( 'K' ) ; } index += 2 ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] } return index ; }
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'K' ) ; index += 2 ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR1Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR2Mutator]MSP[N]
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; MST[rv.CRCR3Mutator]MSP[N] index += 2 ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.ABSMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.AOR2Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.AOR3Mutator]MSP[N]
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] }
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( 'H' ) ;
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.ABSMutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String encode ( final String value ) {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] index += 3 ;
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.UOI2Mutator]MSP[N]
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR4Mutator]MSP[N]
result . append ( 'F' ) ; MST[rv.CRCR1Mutator]MSP[S] index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
if ( index < 0 || index >= value . length () ) { MST[rv.UOI2Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.CRCR4Mutator]MSP[N]
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; MST[ReturnValsMutator]MSP[N] } private boolean conditionC0 ( final String value , final int index ) {
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR1Mutator]MSP[N]
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( lr_37 , lr_36 ) ; } else {
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.UOI1Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
if ( ! ( ( index == value . length () - 1 ) && MST[InlineConstantMutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] }
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.AOD2Mutator]MSP[N] return false ;
if ( ! ( ( index == value . length () - 1 ) && MST[rv.AOR1Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[NegateConditionalsMutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.ROR5Mutator]MSP[S] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[InlineConstantMutator]MSP[N]
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.UOI4Mutator]MSP[S] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.ROR3Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[InlineConstantMutator]MSP[S] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.AOR2Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.ROR4Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] } return index ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR6Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { result . append ( 'J' ) ; index += 2 ; MST[IncrementsMutator]MSP[N] } else {
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.ROR2Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] break;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'S' ) ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.ABSMutator]MSP[N]
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR4Mutator]MSP[S]
case '\u00D1' : result . append ( 'N' ) ; MST[rv.CRCR1Mutator]MSP[S] index ++ ; break; case 'P' : index = handleP ( value , result , index ) ; break; case 'Q' : result . append ( 'K' ) ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; MST[VoidMethodCallMutator]MSP[N] }
result . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } index += 2 ; } return index ; } private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) {
if ( charAt ( value , index + 1 ) == 'J' ) { MST[rv.ROR4Mutator]MSP[S] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
! contains ( value , index - 2 , 4 , lr_5 ) ) { MST[rv.ROR2Mutator]MSP[S] result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.ROR3Mutator]MSP[N]
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.ROR3Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
if ( index == value . length () - 3 && MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.CRCR3Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.UOI1Mutator]MSP[S] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[S] } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.AOR4Mutator]MSP[N]
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.UOI2Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( slavoGermanic ) {
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[InlineConstantMutator]MSP[S] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[MathMutator]MSP[S] index += 3 ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.ROR1Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.UOI4Mutator]MSP[S]
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.AOR4Mutator]MSP[N] return false ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[S] } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR6Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.AOR3Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.UOI3Mutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; MST[ReturnValsMutator]MSP[N] }
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.AOR3Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[InlineConstantMutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.ROR1Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case '\u00C7' :
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[ConditionalsBoundaryMutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { MST[rv.ROR5Mutator]MSP[S] result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[InlineConstantMutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.AOD2Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] } return index ; }
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_98 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'R' ) ; index += 2 ; } else {
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { result . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] index ++ ; } else {
contains ( value , index - 1 , 4 , lr_133 ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.ABSMutator]MSP[S]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.AOR1Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
if ( ! ( ( index == value . length () - 1 ) && MST[rv.UOI3Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR3Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { MST[rv.ROR1Mutator]MSP[S] result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.AOD2Mutator]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) {
final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; MST[rv.CRCR3Mutator]MSP[N] final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen () ) ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} return index ; MST[rv.ABSMutator]MSP[N] } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR4Mutator]MSP[S]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.UOI1Mutator]MSP[N]
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.ROR2Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR3Mutator]MSP[N]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] index = handleGH ( value , result , index ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR6Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] index += 3 ;
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.ROR3Mutator]MSP[S] result . append ( 'S' ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR1Mutator]MSP[S]
for ( final String element : criteria ) { MST[rv.UOI4Mutator]MSP[N] if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.ROR5Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
result . append ( 'S' ) ; } index += 2 ; MST[IncrementsMutator]MSP[N] } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { index += 3 ;
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' , 'A' ) ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' ) ;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR5Mutator]MSP[N]
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'K' , 'J' ) ; index += 2 ;
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.UOI4Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'J' , ' ' ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'K' , 'J' ) ; index += 2 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[InlineConstantMutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
} else if ( ! contains ( value , index + 2 , 2 , lr_38 ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { MST[rv.UOI3Mutator]MSP[S] result . append ( lr_37 , lr_36 ) ; } else {
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.UOI2Mutator]MSP[N] if ( slavoGermanic ) {
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.UOI4Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR4Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.ROR2Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'J' , ' ' ) ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.ABSMutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.ROR2Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[N] index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[rv.ABSMutator]MSP[N] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
if ( ! ( ( index == value . length () - 1 ) && MST[rv.ROR1Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } index += 2 ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { MST[rv.ROR4Mutator]MSP[N] return false ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[NegateConditionalsMutator]MSP[N] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.ROR5Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case '\u00C7' :
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR4Mutator]MSP[N] index += 3 ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.CRCR5Mutator]MSP[S]
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.ROR1Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.UOI2Mutator]MSP[S]
if ( charAt ( value , index + 1 ) == 'L' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[S] break; case '\u00C7' :
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[S]
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR5Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR6Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR5Mutator]MSP[N]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR6Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[NegateConditionalsMutator]MSP[S] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[InlineConstantMutator]MSP[N]
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR6Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD2Mutator]MSP[N] final boolean slavoGermanic ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.CRCR6Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.ROR5Mutator]MSP[N]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'S' ) ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[S] break;
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR6Mutator]MSP[S]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
contains ( value , index - 1 , 4 , lr_133 ) ) { return true ; } else { return false ; MST[rv.CRCR3Mutator]MSP[S] } } private boolean conditionM0 ( final String value , final int index ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( index < 0 || index >= value . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.ROR4Mutator]MSP[N]
result . append ( 'X' ) ; } return index + 2 ; MST[MathMutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.ABSMutator]MSP[N]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOD1Mutator]MSP[N] final boolean slavoGermanic ) {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.ABSMutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { result . append ( 'J' ) ; MST[rv.CRCR1Mutator]MSP[N] index += 2 ; } else {
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[S] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.CRCR3Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR3Mutator]MSP[N]
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ; MST[VoidMethodCallMutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.AOR3Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { MST[rv.CRCR3Mutator]MSP[N] return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.UOI2Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'H' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR1Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR4Mutator]MSP[N]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR2Mutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'S' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ; MST[rv.CRCR3Mutator]MSP[N]
index = handleX ( value , result , index ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR3Mutator]MSP[N]
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.AOR1Mutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( slavoGermanic ) {
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; MST[VoidMethodCallMutator]MSP[N] index ++ ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } return index ; }
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.AOD2Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR5Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
index = handleH ( value , result , index ) ; break; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break; case 'K' : result . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.AOR4Mutator]MSP[N]
index = handleH ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; break; case 'K' : result . append ( 'K' ) ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.ROR2Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; MST[PrimitiveReturnsMutator]MSP[N] }
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR1Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.CRCR2Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.ABSMutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.CRCR6Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'S' ) ; index ++ ; } else {
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.AOD2Mutator]MSP[N]
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[NonVoidMethodCallMutator]MSP[N]
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.CRCR3Mutator]MSP[N]
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { MST[rv.AOR1Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index += 2 ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI4Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR1Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOD2Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[S] break; case '\u00C7' :
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
! contains ( value , index - 4 , 2 , lr_65 , lr_66 ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; MST[rv.CRCR2Mutator]MSP[N] }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[InlineConstantMutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } return index ; }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.AOD1Mutator]MSP[N]
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { MST[NegateConditionalsMutator]MSP[S] result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) {
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR1Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'L' ) { MST[InlineConstantMutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR5Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.CRCR4Mutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.ROR5Mutator]MSP[S] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.ROR5Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
result . append ( lr_28 ) ; } else { result . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] } index += 3 ; } else { result . append ( 'K' ) ; index += 2 ; } return index ; }
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N]
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] } return index ; }
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[InlineConstantMutator]MSP[N]
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[InlineConstantMutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[InlineConstantMutator]MSP[N]
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR6Mutator]MSP[N] index += 3 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
if ( index == value . length () - 3 && MST[rv.AOR2Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.ABSMutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'H' ) ;
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { result . append ( 'A' ) ; MST[rv.CRCR5Mutator]MSP[N] } return index + 1 ; } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR5Mutator]MSP[S] } index += 2 ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[NegateConditionalsMutator]MSP[S] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.UOI4Mutator]MSP[S]
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.UOI4Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR4Mutator]MSP[S]
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; } return index ; MST[rv.ABSMutator]MSP[N] }
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.AOR2Mutator]MSP[S]
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR3Mutator]MSP[N]
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.AOR1Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.UOI4Mutator]MSP[N] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.ROR2Mutator]MSP[S] }
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR6Mutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( slavoGermanic ) {
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'S' :
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR6Mutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR4Mutator]MSP[S] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.CRCR1Mutator]MSP[N]
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[rv.ROR1Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.UOI2Mutator]MSP[N] result . append ( 'S' ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.CRCR3Mutator]MSP[N] }
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.AOR3Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ; }
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.AOR3Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[InlineConstantMutator]MSP[N]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR2Mutator]MSP[N] result . append ( 'S' ) ;
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; MST[VoidMethodCallMutator]MSP[N] index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.UOI1Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR5Mutator]MSP[N]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.ROR5Mutator]MSP[N] if ( slavoGermanic ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[rv.CRCR1Mutator]MSP[N] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[NonVoidMethodCallMutator]MSP[N]
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.CRCR2Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.ROR4Mutator]MSP[N]
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { return false ; } else { return true ; MST[rv.CRCR5Mutator]MSP[N] } } private boolean conditionCH1 ( final String value , final int index ) {
! contains ( value , index + 2 , 2 , lr_25 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen () ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ABSMutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.UOI4Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else { result . append ( 'J' , 'H' ) ; MST[rv.CRCR4Mutator]MSP[S] } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.CRCR6Mutator]MSP[S] }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[NegateConditionalsMutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { result . append ( 'X' , 'K' ) ; } } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOD2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; MST[VoidMethodCallMutator]MSP[N] return index + 2 ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ; MST[InlineConstantMutator]MSP[S]
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] break; case '\u00C7' :
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] } return index ; }
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.AOR3Mutator]MSP[N]
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] } return index ; }
! contains ( value , index - 1 , 1 , lr_23 , lr_22 ) && MST[rv.CRCR1Mutator]MSP[S] ! contains ( value , index - 1 , 3 , lr_46 , lr_47 ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR6Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.ROR4Mutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; MST[VoidMethodCallMutator]MSP[N] index += 3 ;
if ( input . length () == 0 ) { return null ; } return input . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected char charAt ( final String value , final int index ) {
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR3Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[NonVoidMethodCallMutator]MSP[N] index += 3 ;
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.ROR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR4Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { result . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] index += 2 ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; MST[InlineConstantMutator]MSP[N] } else { result . append ( 'K' ) ; } index += 2 ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
result . append ( 'S' ) ; index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
index = handleS ( value , result , index , slavoGermanic ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'T' : index = handleT ( value , result , index ) ; break; case 'V' : result . append ( 'F' ) ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { result . append ( 'K' ) ; } index += 2 ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || MST[rv.AOR4Mutator]MSP[S] charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
result . append ( 'X' ) ; } return index + 2 ; MST[rv.CRCR1Mutator]MSP[N] } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) {
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) { MST[rv.UOI1Mutator]MSP[S]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[rv.ROR1Mutator]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
result . append ( 'F' ) ; MST[VoidMethodCallMutator]MSP[S] index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ;
public String doubleMetaphone ( final String value ) { MST[rv.CRCR1Mutator]MSP[N] return doubleMetaphone ( value , false ) ; } public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value == null ) { return null ; }
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOD2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[NegateConditionalsMutator]MSP[S]
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; MST[ReturnValsMutator]MSP[N] } input = input . trim () ;
if ( charAt ( value , index + 1 ) == 'J' ) { MST[MathMutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.UOI2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; MST[rv.CRCR2Mutator]MSP[S] } index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[NegateConditionalsMutator]MSP[N] index = handleGH ( value , result , index ) ;
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; MST[ReturnValsMutator]MSP[N] } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.ABSMutator]MSP[N]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
} else { result . append ( 'J' , 'H' ) ; } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ; MST[InlineConstantMutator]MSP[S]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'S' ) ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { MST[rv.UOI4Mutator]MSP[N] return false ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.ABSMutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isSlavoGermanic ( final String value ) {
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[ConditionalsBoundaryMutator]MSP[S] }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR6Mutator]MSP[N] final boolean slavoGermanic ) {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.AOR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.AOR4Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.UOI4Mutator]MSP[N]
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR4Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR4Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.CRCR4Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
index ++ ; result . append ( 'L' ) ; } return index ; MST[rv.UOI3Mutator]MSP[N] } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
} else { result . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] } return index ; }
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] } return index ; }
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; MST[rv.CRCR2Mutator]MSP[N] index += 2 ; } else { index ++ ;
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.AOR2Mutator]MSP[N]
contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; MST[rv.CRCR3Mutator]MSP[N] } index += 2 ;
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
result . append ( 'F' ) ; MST[rv.CRCR2Mutator]MSP[N] index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
return doubleMetaphone ( value ) ; } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) {
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; MST[IncrementsMutator]MSP[N] } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[InlineConstantMutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; index ++ ;
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[rv.CRCR3Mutator]MSP[N] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.UOI1Mutator]MSP[S] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.UOI2Mutator]MSP[N]
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[NegateConditionalsMutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] } return index ; }
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.CRCR1Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[NonVoidMethodCallMutator]MSP[S]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[MathMutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[rv.ROR2Mutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } return index ; }
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 2 , lr_7 ) && MST[InlineConstantMutator]MSP[N] ! ( index == 1 && charAt ( value , 0 ) == 'M' ) ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR3Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.AOR4Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.AOR1Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.CRCR3Mutator]MSP[N]
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.CRCR6Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR6Mutator]MSP[N]
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; } return index ; MST[rv.UOI3Mutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.CRCR2Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.UOI1Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.ROR4Mutator]MSP[S] } return index ; }
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) || MST[rv.CRCR1Mutator]MSP[N]
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.CRCR4Mutator]MSP[N]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] } return index ; }
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.ROR5Mutator]MSP[N] break; case '\u00C7' :
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.ROR3Mutator]MSP[N]
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[rv.UOI2Mutator]MSP[N] result . append ( 'K' ) ; return index + 2 ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[NegateConditionalsMutator]MSP[N] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[InlineConstantMutator]MSP[S] result . append ( 'H' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[InlineConstantMutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOD2Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR4Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR3Mutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR2Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.AOR1Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[rv.AOR3Mutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.ROR1Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.CRCR2Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
} else { if ( index > 0 ) { MST[rv.UOI2Mutator]MSP[N] if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; } else { result . append ( 'X' , 'K' ) ; } } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR4Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( index == value . length () - 3 && MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[rv.ROR5Mutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[NonVoidMethodCallMutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] } return index ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.ROR5Mutator]MSP[S]
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[rv.CRCR5Mutator]MSP[S] } index += 3 ;
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } return index ; }
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.UOI2Mutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'J' ) ; MST[rv.CRCR4Mutator]MSP[N] index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
if ( ! ( ( index == value . length () - 1 ) && MST[rv.CRCR4Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ; MST[rv.CRCR3Mutator]MSP[S]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.ABSMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
if ( value . startsWith ( element ) ) { result = true ; MST[rv.CRCR2Mutator]MSP[N] break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
result . append ( 'A' , 'F' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[InlineConstantMutator]MSP[S]
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[NegateConditionalsMutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
result . append ( 'X' , 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
index = charAt ( value , index + 1 ) == 'Q' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'R' : index = handleR ( value , result , index , slavoGermanic ) ; break; case 'S' :
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR2Mutator]MSP[S] final boolean slavoGermanic ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[MathMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[MathMutator]MSP[N] result . appendAlternate ( 'S' ) ;
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[rv.UOI3Mutator]MSP[S] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} else if ( ( index == 0 && contains ( value , index + 1 , 1 , lr_78 , lr_37 , lr_41 , lr_79 ) ) || contains ( value , index + 1 , 1 , lr_80 ) ) { MST[rv.ROR2Mutator]MSP[N]
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.UOI4Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) {
if ( ! ( ( index == value . length () - 1 ) && MST[rv.AOR4Mutator]MSP[N] ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) {
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.ROR5Mutator]MSP[N] } return index ; }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.AOD2Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) ) { result . append ( 'T' ) ; } else { result . append ( '0' , 'T' ) ; } index += 2 ;
} else if ( index == 0 ) { if ( charAt ( value , index + 2 ) == 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[S] } index += 2 ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ; }
return handleCC ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_8 , lr_9 , lr_10 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.CRCR5Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , index - 1 , 5 , lr_100 , lr_101 , lr_102 , lr_103 ) || contains ( value , 0 , 3 , lr_52 ) ) { result . appendAlternate ( 'F' ) ; MST[rv.CRCR1Mutator]MSP[N] index ++ ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.ABSMutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
result . append ( 'X' , 'S' ) ; MST[InlineConstantMutator]MSP[N] } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { result . append ( 'S' ) ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; MST[rv.CRCR1Mutator]MSP[N] index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; break; case '\u00C7' :
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.AOR1Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR6Mutator]MSP[N]
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.UOI4Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[NegateConditionalsMutator]MSP[N] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[S] break;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR1Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.UOI2Mutator]MSP[N] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.ROR2Mutator]MSP[S]
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; MST[rv.UOI2Mutator]MSP[N] break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; }
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[InlineConstantMutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.ROR4Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; } return doubleMetaphone ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } @Override public String encode ( final String value ) {
if ( index == value . length () - 3 && MST[rv.AOR1Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.CRCR3Mutator]MSP[N] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
index ++ ; result . append ( 'L' ) ; MST[rv.CRCR3Mutator]MSP[N] } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
! contains ( value , index + 2 , 2 , lr_25 ) ) { MST[rv.ROR5Mutator]MSP[N] if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[ReturnValsMutator]MSP[N] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { MST[rv.CRCR6Mutator]MSP[S] index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) &&
result . append ( lr_89 , lr_90 ) ; } else { result . append ( lr_90 ) ; } } else { if ( index == 0 && ! isVowel ( charAt ( value , 3 ) ) && charAt ( value , 3 ) != 'W' ) { MST[rv.UOI1Mutator]MSP[N]
if ( index == value . length () - 3 && MST[InlineConstantMutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.AOD2Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
index ++ ; result . append ( 'L' ) ; } return index ; } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.AOD2Mutator]MSP[S]
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] } return index ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.AOR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.CRCR5Mutator]MSP[N]
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.UOI1Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.ABSMutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR4Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[InlineConstantMutator]MSP[N]
if ( index == value . length () - 3 && MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
! contains ( value , index - 2 , 4 , lr_5 ) ) { result . append ( 'S' , 'X' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 3 , lr_6 ) ) { MST[rv.AOR2Mutator]MSP[S]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.AOR2Mutator]MSP[N] } return index ; }
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOD2Mutator]MSP[N]
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'S' ) ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[S] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR1Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.AOR3Mutator]MSP[N]
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR4Mutator]MSP[N]
result . append ( 'S' ) ; index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; MST[rv.ABSMutator]MSP[N] break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.ROR2Mutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[rv.CRCR5Mutator]MSP[N]
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.AOD1Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[InlineConstantMutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.ROR3Mutator]MSP[N]
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[InlineConstantMutator]MSP[N]
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'S' ) ;
result . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { result . append ( 'X' ) ; index += 3 ;
if ( charAt ( value , index + 1 ) == 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { result . append ( 'L' ) ; } index += 2 ; } else {
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'K' ) ; return index + 2 ;
index = handleAEIOUY ( result , index ) ; break; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) == 'B' ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[S] break; case '\u00C7' :
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index == 0 ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'S' ) ; index ++ ; } else {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && isVowel ( charAt ( value , index + 1 ) ) ) { MST[rv.ROR3Mutator]MSP[N] result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( lr_62 , lr_105 ) ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( slavoGermanic ) {
@Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } return doubleMetaphone ( ( String ) obj ) ; } @Override public String encode ( final String value ) {
if ( conditionC0 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[S] index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.UOI3Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.ROR5Mutator]MSP[S] } private boolean isSlavoGermanic ( final String value ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR4Mutator]MSP[N] final boolean slavoGermanic ) {
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
if ( charAt ( value , index + 1 ) == 'J' ) { MST[rv.CRCR2Mutator]MSP[N] index += 2 ; } else { index ++ ; } } return index ; } private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( contains ( value , index , 2 , lr_98 ) ) { result . append ( 'R' ) ; index += 2 ; } else {
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ; MST[ReturnValsMutator]MSP[S]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[InlineConstantMutator]MSP[N]
} else { if ( index > 0 ) { if ( contains ( value , 0 , 2 , lr_30 ) ) { result . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { result . append ( 'X' , 'K' ) ; } } else {
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR5Mutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
result . append ( 'S' ) ; index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; break; case 'D' : index = handleD ( value , result , index ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'F' :
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.AOD1Mutator]MSP[S] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; MST[rv.ROR1Mutator]MSP[N] break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; break;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.UOI3Mutator]MSP[S]
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[NonVoidMethodCallMutator]MSP[N]
result . append ( 'X' ) ; index += 3 ; } else if ( contains ( value , index , 3 , lr_92 , lr_93 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'X' ) ; index += 3 ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_12]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_13]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_14]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[rv.CRCR3Mutator]MSP[N]
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_15]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.AOR3Mutator]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_10]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_11]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.UOI2Mutator]MSP[N] } return index ; }
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; MST[rv.AOD2Mutator]MSP[S] return ( c != 'I' && c != 'E' ) ||
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.AOR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[NegateConditionalsMutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
if ( index == value . length () - 3 && MST[rv.CRCR5Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.UOI1Mutator]MSP[S]
result . append ( 'F' ) ; index += 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , lr_63 , lr_55 ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } return index ;
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'H' ) ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[NonVoidMethodCallMutator]MSP[S] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[NonVoidMethodCallMutator]MSP[N]
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] } return index ; }
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_17]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_18]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_19]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_23]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
! contains ( value , index + 2 , 2 , lr_25 ) ) { MST[NegateConditionalsMutator]MSP[N] if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_24]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_25]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[MathMutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_26]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || MST[rv.UOI1Mutator]MSP[S] ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) &&
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_20]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_21]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_22]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR4Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
if ( index == value . length () - 3 && MST[rv.UOI3Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
result . append ( 'F' ) ; index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.CRCR5Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N]
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[rv.AOR1Mutator]MSP[S] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR3Mutator]MSP[N] result . append ( 'S' ) ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[rv.UOI3Mutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[S] } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; MST[PrimitiveReturnsMutator]MSP[N] }
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) { MST[rv.CRCR2Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR4Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
} else { result . append ( lr_90 ) ; } return index + 3 ; MST[rv.UOI1Mutator]MSP[N] } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && MST[rv.CRCR6Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_64 ) &&
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR6Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
while ( ! result . isComplete () && index <= value . length () - 1 ) { switch ( value . charAt ( index ) ) { MST[experimental.RemoveSwitchMutator_27]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.ROR2Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
result . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[S] index ++ ; break; case 'C' : index = handleC ( value , result , index ) ; break; case 'D' : index = handleD ( value , result , index ) ; break; case 'F' :
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[InlineConstantMutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
if ( charAt ( value , index + 1 ) == 'M' ) { MST[rv.CRCR5Mutator]MSP[N] return true ; } return contains ( value , index - 1 , 3 , lr_136 ) &&
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) { MST[NegateConditionalsMutator]MSP[N]
result . append ( 'A' , 'F' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { result . append ( 'A' ) ; } index ++ ; } else if ( ( index == value . length () - 1 && isVowel ( charAt ( value , index - 1 ) ) ) ||
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ABSMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( index < 0 || index >= value . length () ) { MST[rv.ROR4Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[NegateConditionalsMutator]MSP[S]
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.ROR3Mutator]MSP[N]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; } else if ( contains ( value , index , 2 , lr_81 ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( index == value . length () - 3 && contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { MST[rv.ROR3Mutator]MSP[N] return true ;
if ( index == value . length () - 3 && MST[rv.ROR1Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR5Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; MST[rv.UOI4Mutator]MSP[S] } public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
index += 2 ; } else if ( contains ( value , index , 2 , lr_3 ) ) { index = handleCH ( value , result , index ) ; } else if ( contains ( value , index , 2 , lr_4 ) && MST[rv.CRCR5Mutator]MSP[N]
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.CRCR2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.UOI3Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index == 0 ) { MST[rv.UOI1Mutator]MSP[N] result . append ( 'A' ) ; } return index + 1 ; } private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) {
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[rv.AOD1Mutator]MSP[S] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
if ( index == value . length () - 3 && MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} else { result . append ( lr_90 ) ; MST[VoidMethodCallMutator]MSP[S] } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI4Mutator]MSP[N] final boolean slavoGermanic ) {
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'S' ) ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
private boolean isVowel ( final char ch ) { return VOWELS . indexOf ( ch ) != - 1 ; MST[rv.ABSMutator]MSP[N] } private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[S] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; }
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.AOR3Mutator]MSP[N] break;
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[ConditionalsBoundaryMutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
result . append ( lr_28 ) ; } index = contains ( value , index + 1 , 1 , lr_19 , lr_89 ) ? index + 2 : index + 1 ; MST[rv.AOR1Mutator]MSP[N] } return index ; }
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; MST[rv.CRCR4Mutator]MSP[N] index += 2 ;
if ( contains ( value , index , 4 , lr_114 ) ) { return true ; } else if ( index <= 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.ROR3Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
contains ( value , index - 3 , 1 , lr_19 , lr_57 , lr_41 , lr_58 , lr_59 ) ) { result . append ( 'F' ) ; } else if ( index > 0 && charAt ( value , index - 1 ) != 'I' ) { MST[rv.UOI1Mutator]MSP[S]
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.UOI4Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
if ( conditionC0 ( value , index ) ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ; } else if ( index == 0 && contains ( value , index , 6 , lr_2 ) ) { result . append ( 'S' ) ;
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( 'X' , 'S' ) ;
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.CRCR6Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.CRCR5Mutator]MSP[N]
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.CRCR5Mutator]MSP[S]
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[rv.UOI4Mutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
} else if ( ( index > 1 && contains ( value , index - 2 , 1 , lr_55 , lr_24 , lr_56 ) ) || ( index > 2 && contains ( value , index - 3 , 1 , lr_55 , lr_24 , lr_56 ) ) || MST[rv.AOR1Mutator]MSP[S]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'S' ) ;
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[InlineConstantMutator]MSP[N] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOR2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR4Mutator]MSP[N]
} else if ( charAt ( value , index + 1 ) == 'G' ) { MST[rv.CRCR3Mutator]MSP[S] index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
} return index ; MST[rv.UOI1Mutator]MSP[N] } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[rv.AOR2Mutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.ROR1Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR3Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || MST[rv.ROR4Mutator]MSP[S] contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) {
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( slavoGermanic ) {
} else { result . append ( 'T' ) ; MST[VoidMethodCallMutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; } return index ; }
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR6Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
result . append ( 'X' ) ; } return index + 2 ; } } private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , lr_31 ) ) { MST[rv.CRCR5Mutator]MSP[N]
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; MST[rv.CRCR6Mutator]MSP[S] } index += 2 ;
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR4Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.AOR4Mutator]MSP[S]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.AOD1Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[BooleanTrueReturnValsMutator]MSP[S]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
if ( index == value . length () - 3 && MST[rv.UOI4Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR3Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { MST[rv.CRCR3Mutator]MSP[N] index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[S] result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; }
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR6Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.UOI3Mutator]MSP[N]
if ( charAt ( value , index + 1 ) == 'L' ) { MST[rv.UOI1Mutator]MSP[N] if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index += 2 ; } else {
if ( ( index == 0 || isVowel ( charAt ( value , index - 1 ) ) ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isVowel ( charAt ( value , index + 1 ) ) ) { result . append ( 'H' ) ; index += 2 ; } else { index ++ ;
} else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } return index ; }
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR1Mutator]MSP[N] index += 3 ;
} else { result . append ( lr_90 ) ; } return index + 3 ; } private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , lr_91 ) ) { MST[rv.ROR4Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR3Mutator]MSP[N]
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.CRCR4Mutator]MSP[N]
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] return index + 2 ;
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.UOI4Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
index = charAt ( value , index + 1 ) == 'V' ? index + 2 : index + 1 ; MST[rv.CRCR4Mutator]MSP[N] break; case 'W' : index = handleW ( value , result , index ) ; break; case 'X' :
result . append ( 'X' , 'S' ) ; } else { result . append ( 'X' ) ; } } } else if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.ABSMutator]MSP[N] result . append ( 'S' ) ;
} else if ( conditionCH0 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ; MST[InlineConstantMutator]MSP[N] } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[rv.ROR2Mutator]MSP[S]
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR5Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.ROR2Mutator]MSP[N] final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) {
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR6Mutator]MSP[N]
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_32 ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'J' ) ; index += 3 ; } else { result . append ( lr_33 ) ; index += 2 ; }
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[rv.AOR1Mutator]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
} else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { MST[NonVoidMethodCallMutator]MSP[N] result . append ( lr_36 , lr_37 ) ;
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; MST[rv.CRCR2Mutator]MSP[S] } else {
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , MST[InlineConstantMutator]MSP[N] final boolean slavoGermanic ) {
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR6Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result . append ( 'X' , 'S' ) ;
index = charAt ( value , index + 1 ) == 'K' ? index + 2 : index + 1 ; MST[rv.UOI1Mutator]MSP[N] break; case 'L' : index = handleL ( value , result , index ) ; break; case 'M' : result . append ( 'M' ) ;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.AOD1Mutator]MSP[N]
contains ( value , index - 1 , 4 , lr_133 ) ) { MST[rv.ROR1Mutator]MSP[N] return true ; } else { return false ; } } private boolean conditionM0 ( final String value , final int index ) {
if ( index < 0 || index >= value . length () ) { MST[rv.UOI1Mutator]MSP[N] return Character . MIN_VALUE ; } return value . charAt ( index ) ; } protected static boolean contains ( final String value , final int start , final int length ,
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[InlineConstantMutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.CRCR1Mutator]MSP[N] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . appendAlternate ( 'S' ) ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[InlineConstantMutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.ROR1Mutator]MSP[S]
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { MST[rv.ROR3Mutator]MSP[N] if ( slavoGermanic ) {
return index ; } private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , lr_22 , lr_23 , lr_24 ) && MST[rv.CRCR5Mutator]MSP[N]
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) { MST[rv.ROR5Mutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) && MST[rv.CRCR6Mutator]MSP[N]
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; MST[rv.UOI3Mutator]MSP[N] } private String cleanInput ( String input ) { if ( input == null ) { return null ; } input = input . trim () ;
if ( contains ( value , index , 4 , lr_114 ) ) { MST[rv.CRCR3Mutator]MSP[N] return true ; } else if ( index <= 1 ) { return false ; } else if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ;
} else if ( ! contains ( value , index + 1 , 5 , lr_118 , lr_119 ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index + 1 , 3 , lr_120 , lr_121 , lr_122 , lr_123 ) ) { return false ;
} else if ( isVowel ( charAt ( value , index - 1 ) ) && ! slavoGermanic && ( charAt ( value , index + 1 ) == 'A' || charAt ( value , index + 1 ) == 'O' ) ) { MST[rv.ROR1Mutator]MSP[S]
final String ... criteria ) { boolean result = false ; if ( start >= 0 && start + length <= value . length () ) { MST[rv.ROR5Mutator]MSP[N] final String target = value . substring ( start , start + length ) ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] index = handleGH ( value , result , index ) ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) &&
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean isSlavoGermanic ( final String value ) {
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { MST[rv.CRCR1Mutator]MSP[N] return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) ||
index = handleH ( value , result , index ) ; break; case 'J' : index = handleJ ( value , result , index , slavoGermanic ) ; MST[rv.UOI1Mutator]MSP[N] break; case 'K' : result . append ( 'K' ) ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.UOI3Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.AOD2Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] break;
index = conditionM0 ( value , index ) ? index + 2 : index + 1 ; break; case 'N' : result . append ( 'N' ) ; index = charAt ( value , index + 1 ) == 'N' ? index + 2 : index + 1 ; MST[rv.CRCR1Mutator]MSP[S] break;
contains ( value , index + 2 , 1 , lr_59 , lr_62 ) || ( ( contains ( value , index - 1 , 1 , lr_128 , lr_129 , lr_130 , lr_23 ) || index == 0 ) && MST[rv.AOR4Mutator]MSP[S]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { MST[rv.CRCR4Mutator]MSP[N] result . append ( 'S' ) ;
! contains ( value , index + 2 , 2 , lr_25 ) ) { if ( ( index == 1 && charAt ( value , index - 1 ) == 'A' ) || MST[rv.ROR1Mutator]MSP[N] contains ( value , index - 1 , 5 , lr_26 , lr_27 ) ) {
result . append ( lr_36 ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , lr_39 ) && ! slavoGermanic ) { MST[rv.CRCR6Mutator]MSP[N] result . append ( lr_40 , lr_41 ) ; index += 2 ;
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , MST[rv.UOI2Mutator]MSP[S] final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ;
index = handleX ( value , result , index ) ; break; case 'Z' : index = handleZ ( value , result , index , slavoGermanic ) ; break; default: index ++ ; break; } } return alternate ? result . getAlternate () : result . getPrimary () ; MST[rv.UOI2Mutator]MSP[N] }
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 && contains ( value , index , 4 , lr_29 ) ) { MST[rv.CRCR1Mutator]MSP[N] result . append ( 'K' , 'X' ) ; return index + 2 ;
} else if ( ! contains ( value , index - 1 , 3 , lr_115 ) ) { return false ; } else { final char c = charAt ( value , index + 2 ) ; return ( c != 'I' && c != 'E' ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; } return index ; MST[rv.UOI3Mutator]MSP[N] }
if ( value . startsWith ( element ) ) { result = true ; break; } } return result ; } private String cleanInput ( String input ) { if ( input == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } input = input . trim () ;
} else if ( ( contains ( value , index + 1 , 2 , lr_42 ) || charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , lr_43 , lr_44 , lr_45 ) && MST[InlineConstantMutator]MSP[N]
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { MST[rv.ROR4Mutator]MSP[N] result . append ( 'K' ) ; index += 2 ;
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( isVowel ( charAt ( value , index + 1 ) ) ) {
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) { MST[rv.ROR4Mutator]MSP[S]
if ( contains ( value , index + 1 , 2 , lr_111 , lr_112 , lr_113 ) || MST[rv.ROR2Mutator]MSP[N] ( slavoGermanic && ( index > 0 && charAt ( value , index - 1 ) != 'T' ) ) ) { result . append ( lr_62 , lr_105 ) ;
contains ( value , index - 2 , 6 , lr_116 , lr_117 ) ; MST[InlineConstantMutator]MSP[N] } } private boolean conditionCH0 ( final String value , final int index ) { if ( index != 0 ) { return false ;
if ( ! ( ( index == value . length () - 1 ) && ( contains ( value , index - 3 , 3 , lr_107 , lr_108 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] contains ( value , index - 2 , 2 , lr_109 , lr_110 ) ) ) ) {
} else if ( conditionCH0 ( value , index ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( 'K' ) ; return index + 2 ; } else if ( conditionCH1 ( value , index ) ) { result . append ( 'K' ) ; return index + 2 ;
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR3Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else { result . append ( 'S' ) ; } index = contains ( value , index + 1 , 1 , lr_62 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.CRCR3Mutator]MSP[N] } return index ; }
( index > 3 && contains ( value , index - 4 , 1 , lr_55 , lr_24 ) ) ) { index += 2 ; } else { if ( index > 2 && charAt ( value , index - 1 ) == 'U' && MST[rv.CRCR4Mutator]MSP[N]
index ++ ; } else if ( contains ( value , index , 2 , lr_70 ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( contains ( value , index + 1 , 4 , lr_71 , lr_72 , lr_73 , lr_74 ) ) { result . append ( 'S' ) ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.AOR3Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[InlineConstantMutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR1Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else if ( contains ( value , index , 2 , lr_94 ) || contains ( value , index , 3 , lr_95 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( contains ( value , index + 2 , 2 , lr_96 , lr_97 ) ||
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { MST[InlineConstantMutator]MSP[N] if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { result . append ( 'S' , 'X' ) ; } else {
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR5Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
} else { result . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[N] index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; } return index ; }
return charAt ( value , index + 1 ) == 'R' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] } private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) {
} else { result . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; } return index ; } private boolean conditionC0 ( final String value , final int index ) {
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { MST[rv.ROR2Mutator]MSP[N] result . append ( 'J' ) ; index += 2 ; } else {
if ( ( index == 0 && ( charAt ( value , index + 4 ) == ' ' ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] value . length () == 4 ) || contains ( value , 0 , 4 , lr_61 ) ) { result . append ( 'H' ) ;
index ++ ; result . append ( 'L' ) ; } return index ; MST[rv.UOI2Mutator]MSP[N] } private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) == 'H' ) {
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
} else { result . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) {
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) == 'H' ) { MST[rv.AOR1Mutator]MSP[N]
if ( contains ( value , index + 3 , 2 , lr_84 , lr_42 , lr_85 , lr_86 , lr_87 , lr_88 ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( contains ( value , index + 3 , 2 , lr_42 , lr_85 ) ) {
result . append ( 'S' ) ; } index += 2 ; } else { result . append ( 'K' ) ; if ( contains ( value , index + 1 , 2 , lr_16 , lr_17 , lr_18 ) ) { MST[rv.CRCR5Mutator]MSP[N] index += 3 ;
} else if ( contains ( value , index + 1 , 3 , lr_54 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ;
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { MST[rv.CRCR3Mutator]MSP[N] if ( index > 0 && ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index += 2 ;
final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; MST[rv.ROR1Mutator]MSP[N] final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( this . getMaxCodeLen () ) ;
} else if ( contains ( value , index , 4 , lr_5 , lr_104 ) ) { MST[rv.UOI3Mutator]MSP[N] result . append ( lr_105 , lr_106 ) ; index += 4 ; } else { index ++ ; } } return index ; }
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || MST[InlineConstantMutator]MSP[N] contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ;
result . append ( 'J' , 'H' ) ; } else if ( index == value . length () - 1 ) { MST[InlineConstantMutator]MSP[N] result . append ( 'J' , ' ' ) ;
} else { result . append ( 'J' , 'H' ) ; MST[rv.CRCR4Mutator]MSP[N] } index ++ ; } else { if ( index == 0 && ! contains ( value , index , 4 , lr_60 ) ) { result . append ( 'J' , 'A' ) ;
if ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , 0 , 3 , lr_52 ) || contains ( value , index + 1 , 2 , lr_53 ) ) { result . append ( 'K' ) ;
} else { result . append ( 'S' ) ; } index = charAt ( value , index + 1 ) == 'Z' ? index + 2 : index + 1 ; MST[rv.AOR4Mutator]MSP[N] } return index ; } private boolean conditionC0 ( final String value , final int index ) {
} return index ; } private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , lr_60 ) || contains ( value , 0 , 4 , lr_61 ) ) { MST[rv.CRCR5Mutator]MSP[N]
} else if ( contains ( value , index , 2 , lr_34 , lr_35 ) ) { result . append ( 'T' ) ; index += 2 ; } else { result . append ( 'T' ) ; index ++ ; } return index ; MST[rv.UOI4Mutator]MSP[N] }
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
if ( index == 0 && ( isVowel ( charAt ( value , index + 1 ) ) || contains ( value , index , 2 , lr_99 ) ) ) { if ( isVowel ( charAt ( value , index + 1 ) ) ) { MST[MathMutator]MSP[N]
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[MathMutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
} else if ( contains ( value , 0 , 5 , lr_124 ) ) { MST[rv.CRCR5Mutator]MSP[N] return false ; } else { return true ; } } private boolean conditionCH1 ( final String value , final int index ) {
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) || MST[rv.CRCR5Mutator]MSP[N]
return value . indexOf ( 'W' ) > - 1 || value . indexOf ( 'K' ) > - 1 || MST[InlineConstantMutator]MSP[S] value . indexOf ( lr_4 ) > - 1 || value . indexOf ( lr_104 ) > - 1 ; }
} else if ( charAt ( value , index + 1 ) == 'N' ) { MST[rv.CRCR5Mutator]MSP[S] if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( lr_36 , lr_37 ) ;
} else { result . append ( 'T' ) ; index = contains ( value , index + 1 , 1 , lr_59 , lr_56 ) ? index + 2 : index + 1 ; MST[rv.ROR3Mutator]MSP[N] } return index ; }
( contains ( value , index + 2 , 1 , L_R_N_M_B_H_F_V_W_SPACE ) || index + 1 == value . length () - 1 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean conditionL0 ( final String value , final int index ) {
if ( index == value . length () - 3 && MST[rv.AOR4Mutator]MSP[N] contains ( value , index - 1 , 4 , lr_131 , lr_132 , lr_133 ) ) { return true ;
if ( charAt ( value , index + 1 ) == 'M' ) { return true ; } return contains ( value , index - 1 , 3 , lr_136 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
result . append ( 'S' , 'X' ) ; index = contains ( value , index + 1 , 1 , lr_80 ) ? index + 2 : index + 1 ; MST[rv.UOI3Mutator]MSP[S] } else if ( contains ( value , index , 2 , lr_81 ) ) {
} else if ( contains ( value , index + 1 , 1 , lr_19 , lr_20 , lr_21 ) && MST[rv.CRCR5Mutator]MSP[N] ! contains ( value , index + 1 , 2 , lr_12 , lr_11 ) ) { index += 2 ; } else { index ++ ; } }
} else if ( contains ( value , index , 2 , lr_11 , lr_12 , lr_13 ) ) { if ( contains ( value , index , 3 , lr_14 , lr_15 , lr_6 ) ) { MST[InlineConstantMutator]MSP[N] result . append ( 'S' , 'X' ) ; } else {
} private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index == value . length () - 1 && ! slavoGermanic && contains ( value , index - 2 , 2 , lr_64 ) && MST[rv.CRCR2Mutator]MSP[N]
} else if ( ! contains ( value , index + 1 , 1 , L_T_K_S_N_M_B_Z ) && MST[InlineConstantMutator]MSP[N] ! contains ( value , index - 1 , 1 , lr_62 , lr_20 , lr_41 ) ) { result . append ( 'J' ) ; }
result . append ( 'S' ) ; } else { result . append ( 'S' , 'X' ) ; MST[InlineConstantMutator]MSP[S] } index += 3 ;
} else if ( ( contains ( value , value . length () - 2 , 2 , lr_134 , lr_135 ) || MST[rv.CRCR2Mutator]MSP[N] contains ( value , value . length () - 1 , 1 , lr_128 , lr_129 ) ) &&
result . append ( 'F' ) ; MST[rv.CRCR1Mutator]MSP[N] index = charAt ( value , index + 1 ) == 'F' ? index + 2 : index + 1 ; break; case 'G' : index = handleG ( value , result , index , slavoGermanic ) ; break; case 'H' :
} else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' || contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { MST[rv.ROR5Mutator]MSP[N] result . append ( 'K' , 'J' ) ; index += 2 ;
} else { result . append ( 'X' ) ; } index += 2 ; } else if ( contains ( value , index , 3 , lr_75 , lr_76 ) || contains ( value , index , 4 , lr_77 ) ) { if ( slavoGermanic ) { MST[rv.ROR5Mutator]MSP[S]
( ( index + 1 ) == value . length () - 1 || contains ( value , index + 2 , 2 , lr_42 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isSlavoGermanic ( final String value ) {
while ( ! result . isComplete () && index <= value . length () - 1 ) { MST[rv.AOR3Mutator]MSP[N] switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' :
index = handleSC ( value , result , index ) ; } else { if ( index == value . length () - 1 && contains ( value , index - 2 , 2 , lr_82 , lr_83 ) ) { result . appendAlternate ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( contains ( value , index - 1 , 3 , lr_67 , lr_68 ) ) { index ++ ; } else if ( index == 0 && contains ( value , index , 5 , lr_69 ) ) { result . append ( 'X' , 'S' ) ; MST[rv.CRCR4Mutator]MSP[N]
return ( ( contains ( value , 0 , 4 , lr_50 , lr_51 ) || contains ( value , 0 , 3 , lr_52 ) ) || MST[rv.CRCR3Mutator]MSP[N] contains ( value , index - 2 , 6 , lr_125 , lr_126 , lr_127 ) ||
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public String getPrimary () {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[VoidMethodCallMutator]MSP[N] } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
this . alternate . length () >= this . maxLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[ConditionalsBoundaryMutator]MSP[N] this . primary . append ( value ) ; } else {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.ROR2Mutator]MSP[N] this . primary . append ( value ) ; } else {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.AOD1Mutator]MSP[N]
public void append ( final String value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } public void append ( final String primary , final String alternate ) { appendPrimary ( primary ) ; MST[VoidMethodCallMutator]MSP[N] appendAlternate ( alternate ) ; }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.ROR4Mutator]MSP[N] this . primary . append ( value ) ; } else {
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public String getPrimary () {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.AOR4Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
if ( value . length () <= addChars ) { MST[rv.ROR5Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.UOI1Mutator]MSP[N] this . alternate . append ( value ) ; } }
this . alternate . length () >= this . maxLength ; MST[rv.CRCR6Mutator]MSP[N] }
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.ABSMutator]MSP[N] } } public String getPrimary () {
if ( value . length () <= addChars ) { MST[rv.ROR1Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
if ( value . length () <= addChars ) { MST[rv.ROR3Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.UOI3Mutator]MSP[N] this . primary . append ( value ) ; } else {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.UOI4Mutator]MSP[N]
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.AOR3Mutator]MSP[N]
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[ReturnValsMutator]MSP[N]
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public String getPrimary () {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.UOI2Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
this . primary . append ( value ) ; MST[rv.UOI2Mutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR1Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; MST[rv.UOI2Mutator]MSP[N] appendAlternate ( value ) ;
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.UOI3Mutator]MSP[N] this . alternate . append ( value ) ; } }
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR5Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[NonVoidMethodCallMutator]MSP[S] this . alternate . append ( value ) ; } }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] this . primary . append ( value ) ; } else {
this . alternate . length () >= this . maxLength ; MST[InlineConstantMutator]MSP[N] }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { this . primary . append ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
if ( value . length () <= addChars ) { MST[NegateConditionalsMutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI2Mutator]MSP[N] } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[rv.UOI4Mutator]MSP[S] }
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; MST[rv.ABSMutator]MSP[N] appendAlternate ( value ) ;
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[MathMutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.UOI1Mutator]MSP[N]
this . primary . append ( value ) ; MST[rv.ABSMutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI3Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[rv.ABSMutator]MSP[N] } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.UOI4Mutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[rv.CRCR3Mutator]MSP[N] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; MST[rv.UOI2Mutator]MSP[N] appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; MST[VoidMethodCallMutator]MSP[N] appendAlternate ( value ) ;
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return this . primary . toString () ; MST[ReturnValsMutator]MSP[N] } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; MST[rv.UOI3Mutator]MSP[N]
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; MST[rv.UOI2Mutator]MSP[N] } }
this . alternate . length () >= this . maxLength ; MST[rv.ROR4Mutator]MSP[N] }
this . alternate . length () >= this . maxLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] this . alternate . append ( value ) ; } }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.ROR2Mutator]MSP[N]
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.ROR4Mutator]MSP[N]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; MST[rv.UOI1Mutator]MSP[N]
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[InlineConstantMutator]MSP[N] } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[rv.ROR2Mutator]MSP[S] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.ROR1Mutator]MSP[N]
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.ROR3Mutator]MSP[N]
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[ConditionalsBoundaryMutator]MSP[N] this . alternate . append ( value ) ; } }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[rv.UOI2Mutator]MSP[N] } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
if ( value . length () <= addChars ) { MST[rv.UOI2Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; MST[rv.UOI3Mutator]MSP[N] appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[NonVoidMethodCallMutator]MSP[N]
this . primary . append ( value ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { this . primary . append ( value ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[rv.UOI4Mutator]MSP[N] } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
this . primary . append ( value ) ; MST[rv.UOI3Mutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
public void append ( final String value ) { appendPrimary ( value ) ; MST[VoidMethodCallMutator]MSP[N] appendAlternate ( value ) ; } public void append ( final String primary , final String alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; }
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR1Mutator]MSP[N] } } public String getPrimary () {
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; MST[rv.UOI4Mutator]MSP[N] appendAlternate ( value ) ;
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR6Mutator]MSP[N] } } public String getPrimary () {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.UOI3Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.ROR2Mutator]MSP[N] this . alternate . append ( value ) ; } }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.UOI1Mutator]MSP[N] this . primary . append ( value ) ; } else {
public void append ( final String value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } public void append ( final String primary , final String alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[VoidMethodCallMutator]MSP[N] }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.ROR5Mutator]MSP[N] this . alternate . append ( value ) ; } }
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI1Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public String getPrimary () {
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.ABSMutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
this . alternate . length () >= this . maxLength ; MST[rv.UOI2Mutator]MSP[S] }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.UOI2Mutator]MSP[N]
if ( value . length () <= addChars ) { MST[rv.ROR2Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.ABSMutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[rv.CRCR5Mutator]MSP[N] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.UOI1Mutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[rv.CRCR1Mutator]MSP[N] }
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.AOD2Mutator]MSP[N]
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.ROR1Mutator]MSP[N] this . primary . append ( value ) ; } else {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.ROR3Mutator]MSP[N] this . primary . append ( value ) ; } else {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; MST[ReturnValsMutator]MSP[N] } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
if ( value . length () <= addChars ) { MST[ConditionalsBoundaryMutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.ROR5Mutator]MSP[N] this . primary . append ( value ) ; } else {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.ABSMutator]MSP[N] this . primary . append ( value ) ; } else {
return this . primary . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
if ( value . length () <= addChars ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[NegateConditionalsMutator]MSP[N] }
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI3Mutator]MSP[N] } } public String getPrimary () {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.UOI2Mutator]MSP[N]
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[NegateConditionalsMutator]MSP[N]
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI4Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI2Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI1Mutator]MSP[N] } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[rv.CRCR6Mutator]MSP[N] }
this . alternate . length () >= this . maxLength ; MST[rv.CRCR4Mutator]MSP[N] }
this . alternate . length () >= this . maxLength ; MST[rv.CRCR2Mutator]MSP[N] }
if ( value . length () <= addChars ) { MST[NonVoidMethodCallMutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.UOI3Mutator]MSP[N]
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.AOR2Mutator]MSP[N]
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.UOI4Mutator]MSP[N] this . primary . append ( value ) ; } else {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[NegateConditionalsMutator]MSP[N]
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[NegateConditionalsMutator]MSP[N] this . primary . append ( value ) ; } else {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.UOI1Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[MathMutator]MSP[N]
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.UOI4Mutator]MSP[N]
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR3Mutator]MSP[N] } } public String getPrimary () {
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] this . alternate . append ( value ) ; } }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.UOI2Mutator]MSP[N] this . alternate . append ( value ) ; } }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; MST[rv.ABSMutator]MSP[N] } }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.ROR3Mutator]MSP[N] this . alternate . append ( value ) ; } }
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.AOR3Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.ROR1Mutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[rv.ROR5Mutator]MSP[S] }
if ( value . length () <= addChars ) { MST[rv.ROR4Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[rv.ROR1Mutator]MSP[N] }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.ROR5Mutator]MSP[S]
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.ABSMutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[InlineConstantMutator]MSP[N] }
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; MST[rv.UOI1Mutator]MSP[N] appendAlternate ( value ) ;
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[NonVoidMethodCallMutator]MSP[S]
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; MST[VoidMethodCallMutator]MSP[N] appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
if ( value . length () <= addChars ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . primary . append ( value ) ; MST[rv.UOI1Mutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[rv.UOI1Mutator]MSP[N] } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
if ( value . length () <= addChars ) { MST[rv.UOI3Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[rv.CRCR3Mutator]MSP[N] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.ROR4Mutator]MSP[N]
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; MST[rv.UOI4Mutator]MSP[N] appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.ABSMutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
public void append ( final String value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; MST[VoidMethodCallMutator]MSP[N] } public void append ( final String primary , final String alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[InlineConstantMutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; MST[rv.UOI4Mutator]MSP[N]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; MST[rv.UOI2Mutator]MSP[N]
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; MST[rv.UOI1Mutator]MSP[N] } }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[NonVoidMethodCallMutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[rv.ABSMutator]MSP[S] }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.ROR4Mutator]MSP[N] this . alternate . append ( value ) ; } }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.ABSMutator]MSP[N] this . alternate . append ( value ) ; } }
this . alternate . length () >= this . maxLength ; MST[NonVoidMethodCallMutator]MSP[N] }
this . primary . append ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[NegateConditionalsMutator]MSP[N] this . alternate . append ( value ) ; } }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
this . alternate . length () >= this . maxLength ; MST[rv.UOI3Mutator]MSP[N] }
this . alternate . length () >= this . maxLength ; MST[rv.UOI1Mutator]MSP[N] }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[ConditionalsBoundaryMutator]MSP[N]
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.UOI3Mutator]MSP[N]
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.UOI1Mutator]MSP[N]
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; MST[rv.UOI1Mutator]MSP[N] appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( value . length () <= addChars ) { MST[rv.UOI4Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.ABSMutator]MSP[N]
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.ROR5Mutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[ConditionalsBoundaryMutator]MSP[N] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; MST[rv.ABSMutator]MSP[N] appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR5Mutator]MSP[N] } } public String getPrimary () {
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.UOI2Mutator]MSP[N]
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[rv.UOI2Mutator]MSP[N] this . primary . append ( value ) ; } else {
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.AOR1Mutator]MSP[N]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; MST[VoidMethodCallMutator]MSP[N]
this . primary . append ( value ) ; MST[rv.UOI4Mutator]MSP[N] } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; } }
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[BooleanTrueReturnValsMutator]MSP[N]
this . primary . append ( value . substring ( 0 , addChars ) ) ; } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ; MST[rv.AOR4Mutator]MSP[N]
for ( final String element : criteria ) { if ( target . equals ( element ) ) { result = true ; break; } } } return result ; } public void append ( final char value ) { appendPrimary ( value ) ; MST[rv.UOI3Mutator]MSP[N] appendAlternate ( value ) ;
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.UOI4Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[NonVoidMethodCallMutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR3Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.AOR2Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.ROR1Mutator]MSP[N] this . alternate . append ( value ) ; } }
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { MST[rv.UOI4Mutator]MSP[N] this . alternate . append ( value ) ; } }
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . primary . append ( value ) ; } } public void appendAlternate ( final char value ) { if ( this . alternate . length () < this . maxLength ) { this . alternate . append ( value ) ; MST[rv.UOI3Mutator]MSP[N] } }
if ( value . length () <= addChars ) { MST[rv.ABSMutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
return this . primary . toString () ; } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength && MST[rv.ROR3Mutator]MSP[N]
if ( value . length () <= addChars ) { MST[rv.UOI1Mutator]MSP[N] this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; } } public String getPrimary () {
this . primary . append ( value . substring ( 0 , addChars ) ) ; MST[rv.CRCR6Mutator]MSP[N] } } public void appendAlternate ( final String value ) { final int addChars = this . maxLength - this . alternate . length () ;
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; MST[rv.AOD2Mutator]MSP[N] if ( value . length () <= addChars ) { this . primary . append ( value ) ; } else {
if ( value . length () <= addChars ) { this . alternate . append ( value ) ; } else { this . alternate . append ( value . substring ( 0 , addChars ) ) ; MST[rv.UOI4Mutator]MSP[N] } } public String getPrimary () {
this . alternate . length () >= this . maxLength ; MST[rv.ROR3Mutator]MSP[N] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) { MST[rv.ROR2Mutator]MSP[N]
this . alternate . length () >= this . maxLength ; MST[rv.CRCR5Mutator]MSP[N] }
} public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; MST[rv.UOI3Mutator]MSP[N] } public void appendPrimary ( final char value ) { if ( this . primary . length () < this . maxLength ) {
return this . primary . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getAlternate () { return this . alternate . toString () ; } public boolean isComplete () { return this . primary . length () >= this . maxLength &&
public void appendPrimary ( final String value ) { final int addChars = this . maxLength - this . primary . length () ; if ( value . length () <= addChars ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] this . primary . append ( value ) ; } else {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; return out ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { throw new DecoderException ( lr_1 ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
final int l = data . length ; final char [] out = new char [ l << 1 ] ; encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; }
private static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final char [] toDigits , final char [] out , final int outOffset ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; } @Override public Object decode ( final Object object ) throws DecoderException {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
byteArray = toByteArray ( ( ByteBuffer ) object ) ; } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; } }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
return super . toString () + lr_5 + this . charset + lr_6 ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR2Mutator]MSP[S]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOR3Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NullReturnValsMutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
byteArray = toByteArray ( ( ByteBuffer ) object ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; } }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; MST[rv.CRCR5Mutator]MSP[N] decodeHex ( data , out , 0 ) ; return out ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ABSMutator]MSP[S] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR2Mutator]MSP[S] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR2Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.CRCR2Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[ReturnValsMutator]MSP[N] }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR3Mutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI2Mutator]MSP[S] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.UOI3Mutator]MSP[N] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR3Mutator]MSP[N]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI2Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[experimental.RemoveIncrementsMutator]MSP[N]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR6Mutator]MSP[N]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR2Mutator]MSP[N]
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; MST[NullReturnValsMutator]MSP[N] } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[ReturnValsMutator]MSP[N] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { throw new DecoderException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String toString () {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[NonVoidMethodCallMutator]MSP[N] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR2Mutator]MSP[S] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI4Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[S] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.UOI4Mutator]MSP[N] if ( digit == - 1 ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.OBBN2Mutator]MSP[N]
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI1Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
if ( object instanceof String ) { MST[rv.ROR4Mutator]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR5Mutator]MSP[S] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR3Mutator]MSP[N]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; MST[NullReturnValsMutator]MSP[N] } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.OBBN3Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI2Mutator]MSP[S] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI2Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI1Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( object instanceof ByteBuffer ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI1Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.ABSMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[NonVoidMethodCallMutator]MSP[S]
return outLen ; MST[rv.UOI2Mutator]MSP[S] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.CRCR5Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[NullReturnValsMutator]MSP[N] } else if ( object instanceof ByteBuffer ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI4Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI1Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[N] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ABSMutator]MSP[N]
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI3Mutator]MSP[N] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR2Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI2Mutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[InlineConstantMutator]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.ABSMutator]MSP[S] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI1Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[NullReturnValsMutator]MSP[N] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[InlineConstantMutator]MSP[N] return out ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[N] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.ABSMutator]MSP[S] }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ConstructorCallMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI2Mutator]MSP[N]
return encodeHex ( byteArray ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI3Mutator]MSP[N] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI4Mutator]MSP[N] byteBuffer . get ( byteArray ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI3Mutator]MSP[S]
return decode ( ( ByteBuffer ) object ) ; MST[NullReturnValsMutator]MSP[N] } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI2Mutator]MSP[N]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI4Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI3Mutator]MSP[N] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI4Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[ArgumentPropagationMutator]MSP[N] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI4Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI3Mutator]MSP[N] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] return out ; }
final int outLen = len >> 1 ; MST[rv.UOI1Mutator]MSP[N] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ; MST[experimental.NakedReceiverMutator]MSP[N]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[N] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.CRCR4Mutator]MSP[N] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( digit == - 1 ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR3Mutator]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR3Mutator]MSP[S]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI3Mutator]MSP[S] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI2Mutator]MSP[S] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI1Mutator]MSP[S] byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR1Mutator]MSP[S] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR2Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI1Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR1Mutator]MSP[N]
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOR2Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[N] }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; MST[NullReturnValsMutator]MSP[N] } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR5Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[ReturnValsMutator]MSP[N]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[NullReturnValsMutator]MSP[N] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR1Mutator]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ABSMutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR1Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[InlineConstantMutator]MSP[N]
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR4Mutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[InlineConstantMutator]MSP[N] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR3Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI2Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR2Mutator]MSP[N]
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI1Mutator]MSP[S] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR2Mutator]MSP[S]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR4Mutator]MSP[N]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR3Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.CRCR1Mutator]MSP[N] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR5Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[ReturnValsMutator]MSP[N] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
final byte [] byteArray = byteBuffer . array () ; MST[NonVoidMethodCallMutator]MSP[N] if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NullReturnValsMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[NonVoidMethodCallMutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
return outLen ; MST[PrimitiveReturnsMutator]MSP[N] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NullReturnValsMutator]MSP[N] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ConstructorCallMutator]MSP[N] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.UOI3Mutator]MSP[N] if ( digit == - 1 ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI2Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI4Mutator]MSP[N] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
if ( object instanceof String ) { MST[rv.ROR5Mutator]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI4Mutator]MSP[N] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR6Mutator]MSP[N]
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI2Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return decode ( ( ByteBuffer ) object ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI1Mutator]MSP[S] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI2Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ReturnValsMutator]MSP[N] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR5Mutator]MSP[N]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.ABSMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[ArgumentPropagationMutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOD1Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI1Mutator]MSP[S] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI3Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[N] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR3Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR6Mutator]MSP[N] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI3Mutator]MSP[N]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI2Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return super . toString () + lr_5 + this . charset + lr_6 ; MST[ConstructorCallMutator]MSP[N] }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; MST[ReturnValsMutator]MSP[N] } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR1Mutator]MSP[N]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[S] }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new DecoderException ( lr_1 ) ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ABSMutator]MSP[N]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[NegateConditionalsMutator]MSP[N]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
if ( object instanceof String ) { MST[NegateConditionalsMutator]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( object instanceof ByteBuffer ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( digit == - 1 ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( object instanceof ByteBuffer ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[S]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[ConstructorCallMutator]MSP[N] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; MST[rv.CRCR6Mutator]MSP[N] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR5Mutator]MSP[N] }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI4Mutator]MSP[N]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI1Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( digit == - 1 ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[ReturnValsMutator]MSP[N] } else if ( object instanceof ByteBuffer ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.UOI2Mutator]MSP[S] if ( digit == - 1 ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.OBBN2Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI1Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
return super . toString () + lr_5 + this . charset + lr_6 ; MST[EmptyObjectReturnValsMutator]MSP[N] }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR2Mutator]MSP[N] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.UOI4Mutator]MSP[N]
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR5Mutator]MSP[N]
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[N] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[ReturnValsMutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NegateConditionalsMutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI3Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI4Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI3Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.UOI2Mutator]MSP[N] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI3Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.ABSMutator]MSP[N]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[NonVoidMethodCallMutator]MSP[N] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[ConditionalsBoundaryMutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.ABSMutator]MSP[N] }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[experimental.RemoveIncrementsMutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR4Mutator]MSP[S]
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI1Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[NegateConditionalsMutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR3Mutator]MSP[N]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.CRCR2Mutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[MathMutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR4Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[S] }
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[ReturnValsMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR1Mutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR4Mutator]MSP[N]
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] return out ; }
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR4Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR5Mutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR1Mutator]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI4Mutator]MSP[N] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NullReturnValsMutator]MSP[N]
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.CRCR4Mutator]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR4Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI4Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR5Mutator]MSP[N]
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR4Mutator]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( object instanceof ByteBuffer ) {
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[N] }
return byteArray ; MST[ReturnValsMutator]MSP[N] } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) {
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.UOI1Mutator]MSP[N] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI2Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI4Mutator]MSP[N] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[InlineConstantMutator]MSP[N] if ( digit == - 1 ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[ReturnValsMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI1Mutator]MSP[S] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ABSMutator]MSP[N]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI2Mutator]MSP[S] }
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } @Override
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[N] }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; MST[ReturnValsMutator]MSP[N] } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI3Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR5Mutator]MSP[N]
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] return out ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[ArgumentPropagationMutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[NullReturnValsMutator]MSP[N] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( digit == - 1 ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR4Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; MST[IncrementsMutator]MSP[N] f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI1Mutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.ROR1Mutator]MSP[N]
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[ConstructorCallMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; MST[ConstructorCallMutator]MSP[N] } } } @Override
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI4Mutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final int outLen = len >> 1 ; MST[InlineConstantMutator]MSP[N] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR1Mutator]MSP[N]
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[MathMutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[ReturnValsMutator]MSP[N] } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.ABSMutator]MSP[S] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final int l = data . length ; final char [] out = new char [ l << 1 ] ; MST[rv.CRCR5Mutator]MSP[N] encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; return out ; }
return super . toString () + lr_5 + this . charset + lr_6 ; MST[NonVoidMethodCallMutator]MSP[N] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
byteArray = toByteArray ( ( ByteBuffer ) object ) ; } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; MST[ConstructorCallMutator]MSP[N] } }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
return outLen ; MST[rv.UOI4Mutator]MSP[N] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return outLen ; MST[rv.UOI1Mutator]MSP[N] } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( digit == - 1 ) {
final int l = data . length ; final char [] out = new char [ l << 1 ] ; encodeHex ( data , 0 , data . length , toDigits , out , 0 ) ; MST[VoidMethodCallMutator]MSP[N] return out ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI3Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
byteArray = toByteArray ( ( ByteBuffer ) object ) ; } else { try { byteArray = ( byte [] ) object ; } catch ( final ClassCastException e ) { throw new EncoderException ( e . getMessage () , e ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI4Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ABSMutator]MSP[S] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI2Mutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; MST[ConstructorCallMutator]MSP[N] } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
final int outLen = len >> 1 ; MST[rv.CRCR2Mutator]MSP[N] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[NegateConditionalsMutator]MSP[N]
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[ReturnValsMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI2Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI1Mutator]MSP[S]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[IncrementsMutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; MST[IncrementsMutator]MSP[N] out [ i ] = (byte) ( f & 0xFF ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[S] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR3Mutator]MSP[S] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[ConstructorCallMutator]MSP[N] }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[MathMutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.OBBN1Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.OBBN1Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI2Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR4Mutator]MSP[N]
if ( object instanceof String ) { MST[rv.ROR3Mutator]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; MST[NullReturnValsMutator]MSP[N] } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.ROR1Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[NegateConditionalsMutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI3Mutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI3Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.UOI1Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI3Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; MST[rv.UOI3Mutator]MSP[N] return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.CRCR1Mutator]MSP[N]
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.CRCR3Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.CRCR6Mutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; MST[rv.CRCR3Mutator]MSP[N] decodeHex ( data , out , 0 ) ; return out ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR4Mutator]MSP[N] }
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.ABSMutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; MST[rv.UOI4Mutator]MSP[N] } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; }
return encodeHex ( byteArray ) ; MST[NullReturnValsMutator]MSP[N] } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.ABSMutator]MSP[N] if ( digit == - 1 ) {
return decode ( ( ByteBuffer ) object ) ; MST[ReturnValsMutator]MSP[N] } else { try { return decodeHex ( ( char [] ) object ) ; } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ; MST[rv.UOI1Mutator]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.ABSMutator]MSP[N] byteBuffer . get ( byteArray ) ;
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return byteArray ; MST[NullReturnValsMutator]MSP[N] } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) {
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.ABSMutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOR4Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; MST[ReturnValsMutator]MSP[N] } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; decodeHex ( data , out , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] return out ; }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR5Mutator]MSP[N]
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[rv.ROR3Mutator]MSP[N]
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR3Mutator]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[InlineConstantMutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.ROR2Mutator]MSP[S] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI4Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI1Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.CRCR4Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI3Mutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI3Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; MST[ReturnValsMutator]MSP[S] } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
public static byte [] decodeHex ( final char [] data ) throws DecoderException { final byte [] out = new byte [ data . length >> 1 ] ; MST[rv.CRCR4Mutator]MSP[N] decodeHex ( data , out , 0 ) ; return out ; }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ABSMutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[NegateConditionalsMutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.CRCR3Mutator]MSP[S] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ROR1Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.AOR1Mutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
return encodeHex ( byteArray ) ; MST[ReturnValsMutator]MSP[N] } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; } @Override public String toString () {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[ConstructorCallMutator]MSP[N] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
if ( object instanceof String ) { MST[rv.ROR1Mutator]MSP[N] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[NullReturnValsMutator]MSP[N] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.AOD2Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.CRCR2Mutator]MSP[N]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI4Mutator]MSP[N] }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI4Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[rv.UOI1Mutator]MSP[N]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[rv.CRCR4Mutator]MSP[S] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
public byte [] decode ( final ByteBuffer buffer ) throws DecoderException { return decodeHex ( new String ( toByteArray ( buffer ) , getCharset () ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public Object decode ( final Object object ) throws DecoderException {
return decode ( ( ByteBuffer ) object ) ; } else { try { return decodeHex ( ( char [] ) object ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassCastException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } } @Override
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
final int outLen = len >> 1 ; MST[MathMutator]MSP[N] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[rv.UOI1Mutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR2Mutator]MSP[N] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI3Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) { MST[rv.ROR2Mutator]MSP[S]
public static char [] encodeHex ( final byte [] data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } protected static char [] encodeHex ( final byte [] data , final char [] toDigits ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[rv.ROR5Mutator]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; MST[ReturnValsMutator]MSP[N] } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] out [ i ] = (byte) ( f & 0xFF ) ; }
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final int outLen = len >> 1 ; MST[rv.UOI3Mutator]MSP[N] if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ABSMutator]MSP[S] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI3Mutator]MSP[N] byteBuffer . get ( byteArray ) ;
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; MST[rv.UOI3Mutator]MSP[N] j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.OBBN3Mutator]MSP[N] }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI3Mutator]MSP[N] }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI4Mutator]MSP[N] }
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[NegateConditionalsMutator]MSP[N]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[VoidMethodCallMutator]MSP[N] }
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
out [ j ++ ] = toDigits [ 0x0F & data [ i ] ] ; } } public static char [] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , true ) ; MST[ReturnValsMutator]MSP[N] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { MST[NegateConditionalsMutator]MSP[N] byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI4Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[ReturnValsMutator]MSP[N] }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.ABSMutator]MSP[S] } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N]
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[InlineConstantMutator]MSP[N]
return new String ( encodeHex ( data , toLowerCase ) ) ; } public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; MST[ConstructorCallMutator]MSP[N] } public static String encodeHexString ( final ByteBuffer data , final boolean toLowerCase ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( digit == - 1 ) {
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[rv.CRCR3Mutator]MSP[N] }
return new String ( encodeHex ( data , toLowerCase ) ) ; } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; MST[NonVoidMethodCallMutator]MSP[N] if ( byteBuffer . hasArray () ) {
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[IncrementsMutator]MSP[N]
return super . toString () + lr_5 + this . charset + lr_6 ; MST[experimental.NakedReceiverMutator]MSP[S] }
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; MST[rv.UOI2Mutator]MSP[S] byteBuffer . get ( byteArray ) ;
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
return encodeHex ( toByteArray ( byteBuffer ) , toDigits ) ; } public static String encodeHexString ( final byte [] data ) { return new String ( encodeHex ( data ) ) ; MST[ReturnValsMutator]MSP[N] } public static String encodeHexString ( final byte [] data , final boolean toLowerCase ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[VoidMethodCallMutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[MathMutator]MSP[N]
for ( int i = dataOffset , j = outOffset ; i < dataOffset + dataLen ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] out [ j ++ ] = toDigits [ ( 0xF0 & data [ i ] ) >>> 4 ] ;
if ( object instanceof String ) { MST[rv.ROR2Mutator]MSP[S] return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; MST[InlineConstantMutator]MSP[N] }
return new String ( encodeHex ( data , toLowerCase ) ) ; MST[rv.UOI2Mutator]MSP[S] } private static byte [] toByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining () ; if ( byteBuffer . hasArray () ) {
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) { MST[InlineConstantMutator]MSP[N]
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI4Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI3Mutator]MSP[N] }
int f = toDigit ( data [ j ] , j ) << 4 ; MST[rv.UOI3Mutator]MSP[N] j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.ABSMutator]MSP[S] }
} @Override public Object encode ( final Object object ) throws EncoderException { byte [] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( this . getCharset () ) ; } else if ( object instanceof ByteBuffer ) { MST[NegateConditionalsMutator]MSP[N]
final int outLen = len >> 1 ; if ( out . length - outOffset < outLen ) { throw new DecoderException ( lr_2 ) ; } for ( int i = outOffset , j = 0 ; j < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
return outLen ; } public static byte [] decodeHex ( final String data ) throws DecoderException { return decodeHex ( data . toCharArray () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static char [] encodeHex ( final byte [] data ) { return encodeHex ( data , true ) ; }
public static char [] encodeHex ( final ByteBuffer data , final boolean toLowerCase ) { return encodeHex ( data , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; MST[rv.UOI4Mutator]MSP[N] } protected static char [] encodeHex ( final ByteBuffer byteBuffer , final char [] toDigits ) {
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; MST[NullReturnValsMutator]MSP[N] }
final boolean toLowerCase , final char [] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; MST[rv.UOI2Mutator]MSP[S] }
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.UOI4Mutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
return byteArray ; } protected static int toDigit ( final char ch , final int index ) throws DecoderException { final int digit = Character . digit ( ch , 16 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( digit == - 1 ) {
public byte [] encode ( final byte [] array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; } public byte [] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( this . getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N]
public static char [] encodeHex ( final byte [] data , final int dataOffset , final int dataLen , final boolean toLowerCase ) { final char [] out = new char [ dataLen << 1 ] ; MST[rv.UOI1Mutator]MSP[N]
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.ROR5Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
final byte [] byteArray = byteBuffer . array () ; if ( remaining == byteArray . length ) { MST[rv.UOI2Mutator]MSP[N] byteBuffer . position ( remaining ) ; return byteArray ; } } final byte [] byteArray = new byte [ remaining ] ; byteBuffer . get ( byteArray ) ;
encodeHex ( data , dataOffset , dataLen , toLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; MST[rv.ABSMutator]MSP[N] return out ; } public static void encodeHex ( final byte [] data , final int dataOffset , final int dataLen ,
int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f = f | toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = (byte) ( f & 0xFF ) ; MST[rv.UOI1Mutator]MSP[N] }
return encodeHex ( byteArray ) ; } public Charset getCharset () { return this . charset ; } public String getCharsetName () { return this . charset . name () ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () {
public static int decodeHex ( final char [] data , final byte [] out , final int outOffset ) throws DecoderException { final int len = data . length ; if ( ( len & 0x01 ) != 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; }
throw new DecoderException ( lr_3 + ch + lr_4 + index ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return digit ; } @Override public byte [] decode ( final byte [] array ) throws DecoderException { return decodeHex ( new String ( array , getCharset () ) . toCharArray () ) ; }
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[N] return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) {
if ( object instanceof String ) { return decode ( ( ( String ) object ) . toCharArray () ) ; } else if ( object instanceof byte [] ) { return decode ( ( byte [] ) object ) ; } else if ( object instanceof ByteBuffer ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; }
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList <> () ; try ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , ResourceConstants . ENCODING ) ) {
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; } public Languages . LanguageSet guessLanguages ( final String input ) {
final String text = input . toLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet <> ( this . languages . getLanguages () ) ; for ( final LangRule rule : this . rules ) {
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; MST[ReturnValsMutator]MSP[N] } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; MST[NonVoidMethodCallMutator]MSP[S] } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; MST[NonVoidMethodCallMutator]MSP[N] } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[NonVoidMethodCallMutator]MSP[S] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
line = line . substring ( 0 , cmtI ) ; MST[rv.ABSMutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[NonVoidMethodCallMutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.ROR1Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[rv.ROR4Mutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[rv.ROR4Mutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[rv.ROR2Mutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[rv.ROR2Mutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; MST[NonVoidMethodCallMutator]MSP[N] } } }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[NullReturnValsMutator]MSP[N] }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[rv.CRCR3Mutator]MSP[N]
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.ROR5Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.UOI2Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.ROR3Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.UOI4Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[rv.CRCR3Mutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
if ( parts . length != 3 ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
if ( parts . length != 3 ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[rv.CRCR5Mutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[rv.CRCR5Mutator]MSP[N]
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[rv.CRCR1Mutator]MSP[N]
line = line . substring ( 0 , cmtI ) ; MST[rv.UOI4Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.UOI2Mutator]MSP[N]
if ( parts . length != 3 ) { MST[rv.CRCR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
line = line . substring ( 0 , cmtI ) ; MST[experimental.NakedReceiverMutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[rv.ROR5Mutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[rv.ROR1Mutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
if ( parts . length != 3 ) { MST[rv.CRCR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[rv.UOI3Mutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] inExtendedComment = false ; }
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
if ( rule . matches ( text ) ) { MST[NegateConditionalsMutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ; MST[rv.CRCR3Mutator]MSP[N]
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR2Mutator]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
if ( rule . matches ( text ) ) { MST[rv.ROR4Mutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; MST[rv.CRCR1Mutator]MSP[N] }
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { langs . removeAll ( rule . languages ) ; } } }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR6Mutator]MSP[N] } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.ROR3Mutator]MSP[N]
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.ROR2Mutator]MSP[N]
if ( rule . matches ( text ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.ROR5Mutator]MSP[N]
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR1Mutator]MSP[N] inExtendedComment = false ; }
final Languages . LanguageSet ls = guessLanguages ( text ) ; MST[NonVoidMethodCallMutator]MSP[N] return ls . isSingleton () ? ls . getAny () : Languages . ANY ; } public Languages . LanguageSet guessLanguages ( final String input ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR3Mutator]MSP[N] } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[rv.ROR5Mutator]MSP[N] }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[rv.ROR2Mutator]MSP[N] }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR5Mutator]MSP[N] } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; } } } } return new Lang ( rules , languages ) ; MST[NullReturnValsMutator]MSP[N] } public String guessLanguage ( final String text ) {
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[ConstructorCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; MST[rv.CRCR5Mutator]MSP[N] while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; MST[rv.CRCR3Mutator]MSP[N] while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[rv.UOI1Mutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[ConstructorCallMutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
if ( rule . matches ( text ) ) { MST[rv.ROR1Mutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[ReturnValsMutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[rv.ROR2Mutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
line = line . substring ( 0 , cmtI ) ; MST[rv.CRCR6Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR3Mutator]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
if ( rule . matches ( text ) ) { MST[rv.ROR3Mutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR5Mutator]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { langs . removeAll ( rule . languages ) ; } } }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( parts . length != 3 ) { MST[rv.CRCR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
line = line . substring ( 0 , cmtI ) ; MST[rv.UOI2Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
line = line . substring ( 0 , cmtI ) ; MST[InlineConstantMutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ; MST[rv.CRCR5Mutator]MSP[N]
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[rv.ROR3Mutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
line = line . substring ( 0 , cmtI ) ; MST[NonVoidMethodCallMutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; MST[NonVoidMethodCallMutator]MSP[N] } } }
line = line . substring ( 0 , cmtI ) ; MST[rv.CRCR3Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; MST[NonVoidMethodCallMutator]MSP[N] String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[rv.CRCR2Mutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[NegateConditionalsMutator]MSP[N] inExtendedComment = false ; }
if ( rule . matches ( text ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.ROR2Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR4Mutator]MSP[N] inExtendedComment = false ; }
if ( parts . length != 3 ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[rv.ROR5Mutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; MST[InlineConstantMutator]MSP[N] while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( cmtI >= 0 ) {
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
final String text = input . toLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet <> ( this . languages . getLanguages () ) ; MST[ConstructorCallMutator]MSP[N] for ( final LangRule rule : this . rules ) {
if ( parts . length != 3 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[rv.ROR3Mutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; MST[NullReturnValsMutator]MSP[N] }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[rv.ROR5Mutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[rv.ROR3Mutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[rv.ROR1Mutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[InlineConstantMutator]MSP[N] } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[rv.ROR5Mutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
if ( parts . length != 3 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[rv.ABSMutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[rv.ROR1Mutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( parts . length != 3 ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[NegateConditionalsMutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
line = line . substring ( 0 , cmtI ) ; MST[rv.UOI3Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.UOI1Mutator]MSP[N]
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; } } } } return new Lang ( rules , languages ) ; MST[ReturnValsMutator]MSP[N] } public String guessLanguage ( final String text ) {
if ( parts . length != 3 ) { MST[rv.CRCR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ; MST[NonVoidMethodCallMutator]MSP[N]
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[rv.ROR4Mutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ; MST[rv.CRCR6Mutator]MSP[N]
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[NegateConditionalsMutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[ReturnValsMutator]MSP[N] }
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ; MST[InlineConstantMutator]MSP[N]
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[rv.UOI4Mutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[NegateConditionalsMutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N]
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; MST[NonVoidMethodCallMutator]MSP[N] if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[NegateConditionalsMutator]MSP[N] }
line = line . substring ( 0 , cmtI ) ; MST[rv.CRCR1Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[rv.CRCR4Mutator]MSP[N]
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.ROR4Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
final String text = input . toLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet <> ( this . languages . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final LangRule rule : this . rules ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.UOI3Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[rv.CRCR4Mutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
final String text = input . toLowerCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[N] final Set < String > langs = new HashSet <> ( this . languages . getLanguages () ) ; for ( final LangRule rule : this . rules ) {
if ( parts . length != 3 ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR2Mutator]MSP[N] inExtendedComment = false ; }
if ( parts . length != 3 ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[rv.ROR3Mutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[NonVoidMethodCallMutator]MSP[N] inExtendedComment = false ; }
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
line = line . substring ( 0 , cmtI ) ; MST[rv.CRCR5Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
boolean inExtendedComment = false ; MST[rv.CRCR6Mutator]MSP[N] while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; MST[rv.CRCR3Mutator]MSP[N] }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR1Mutator]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[NegateConditionalsMutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; MST[rv.CRCR5Mutator]MSP[N] }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.ABSMutator]MSP[N]
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[InlineConstantMutator]MSP[N]
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList <> () ; try ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , MST[ConstructorCallMutator]MSP[N] ResourceConstants . ENCODING ) ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.ROR4Mutator]MSP[N]
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.ROR1Mutator]MSP[N]
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[InlineConstantMutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; MST[NonVoidMethodCallMutator]MSP[N] return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[rv.ROR3Mutator]MSP[N] }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[rv.ROR1Mutator]MSP[N] }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR2Mutator]MSP[N] } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; MST[rv.ROR4Mutator]MSP[N] }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[ConstructorCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; MST[rv.CRCR6Mutator]MSP[N] }
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR4Mutator]MSP[N] } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; } } } } return new Lang ( rules , languages ) ; MST[ConstructorCallMutator]MSP[N] } public String guessLanguage ( final String text ) {
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[NegateConditionalsMutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { MST[NonVoidMethodCallMutator]MSP[N] final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; if ( line . length () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] continue; } final String [] parts = line . split ( lr_1 ) ;
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR5Mutator]MSP[N] inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR3Mutator]MSP[N] inExtendedComment = false ; }
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
if ( parts . length != 3 ) { MST[InlineConstantMutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[rv.ROR4Mutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
boolean inExtendedComment = false ; MST[rv.CRCR1Mutator]MSP[N] while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
if ( rule . matches ( text ) ) { MST[rv.ROR5Mutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + MST[NonVoidMethodCallMutator]MSP[N] lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
line = line . substring ( 0 , cmtI ) ; } line = line . trim () ; MST[experimental.NakedReceiverMutator]MSP[N] if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] try ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , ResourceConstants . ENCODING ) ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( parts . length != 3 ) { MST[rv.CRCR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[rv.UOI4Mutator]MSP[N]
line = line . substring ( 0 , cmtI ) ; MST[rv.UOI1Mutator]MSP[N] } line = line . trim () ; if ( line . length () == 0 ) { continue; } final String [] parts = line . split ( lr_1 ) ;
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[rv.ROR2Mutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList <> () ; try ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , MST[NonVoidMethodCallMutator]MSP[N] ResourceConstants . ENCODING ) ) {
if ( parts . length != 3 ) { MST[rv.CRCR6Mutator]MSP[N] throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ;
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
final Languages . LanguageSet ls = guessLanguages ( text ) ; return ls . isSingleton () ? ls . getAny () : Languages . ANY ; MST[NonVoidMethodCallMutator]MSP[N] } public Languages . LanguageSet guessLanguages ( final String input ) {
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[rv.UOI2Mutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; MST[ReturnValsMutator]MSP[N] }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; MST[InlineConstantMutator]MSP[N] }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.ABSMutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
boolean inExtendedComment = false ; while ( scanner . hasNextLine () ) { final String rawLine = scanner . nextLine () ; String line = rawLine ; if ( inExtendedComment ) { MST[rv.UOI1Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; }
if ( parts . length != 3 ) { throw new IllegalArgumentException ( lr_2 + rawLine + lr_3 + languageRulesResourceName + lr_4 ) ; } final Pattern pattern = Pattern . compile ( parts [ 0 ] ) ; MST[rv.CRCR1Mutator]MSP[N]
rules . add ( new LangRule ( pattern , new HashSet <> ( Arrays . asList ( langs ) ) , accept ) ) ; MST[ConstructorCallMutator]MSP[N] } } } } return new Lang ( rules , languages ) ; } public String guessLanguage ( final String text ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[NegateConditionalsMutator]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
if ( rule . matches ( text ) ) { MST[rv.ROR2Mutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
if ( rule . matches ( text ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
public boolean matches ( final String txt ) { return this . pattern . matcher ( txt ) . find () ; } public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; MST[ArgumentPropagationMutator]MSP[N] }
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; MST[rv.CRCR6Mutator]MSP[N] final boolean accept = parts [ 2 ] . equals ( lr_6 ) ;
if ( rule . matches ( text ) ) { if ( rule . acceptOnMatch ) { MST[rv.ROR1Mutator]MSP[N] langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } }
final String text = input . toLowerCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Set < String > langs = new HashSet <> ( this . languages . getLanguages () ) ; for ( final LangRule rule : this . rules ) {
} else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR4Mutator]MSP[N] inExtendedComment = true ; } else { final int cmtI = line . indexOf ( ResourceConstants . CMT ) ; if ( cmtI >= 0 ) {
final String [] langs = parts [ 1 ] . split ( lr_5 ) ; final boolean accept = parts [ 2 ] . equals ( lr_6 ) ; MST[rv.CRCR6Mutator]MSP[N]
public static LanguageSet from ( final Set < String > langs ) { return langs . isEmpty () ? NO_LANGUAGES : new SomeLanguages ( langs ) ; } @Override public boolean contains ( final String language ) { return this . languages . contains ( language ) ; } @Override
public String getAny () { return this . languages . iterator () . next () ; } public Set < String > getLanguages () { return this . languages ; } @Override public boolean isEmpty () { return this . languages . isEmpty () ; } @Override
public boolean isSingleton () { return this . languages . size () == 1 ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { if ( other == NO_LANGUAGES ) { return other ; } else if ( other == ANY_LANGUAGE ) { return this ;
} else { final SomeLanguages sl = ( SomeLanguages ) other ; final Set < String > ls = new HashSet <> ( Math . min ( languages . size () , sl . languages . size () ) ) ; for ( final String lang : languages ) {
if ( sl . languages . contains ( lang ) ) { ls . add ( lang ) ; } } return from ( ls ) ; } } @Override public LanguageSet merge ( final LanguageSet other ) { if ( other == NO_LANGUAGES ) { return this ;
} else if ( other == ANY_LANGUAGE ) { return other ; } else { final SomeLanguages sl = ( SomeLanguages ) other ; final Set < String > ls = new HashSet <> ( languages ) ; for ( final String lang : sl . languages ) {
ls . add ( lang ) ; } return from ( ls ) ; } } @Override public String toString () { return lr_1 + languages . toString () + lr_2 ; } public static Languages getInstance ( final NameType nameType ) {
return LANGUAGES . get ( nameType ) ; } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) ,
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
return new Languages ( Collections . unmodifiableSet ( ls ) ) ; } } private static String langResourceName ( final NameType nameType ) { return String . format ( lr_3 , nameType . getName () ) ; } @Override public boolean contains ( final String language ) {
return false ; } @Override public String getAny () { throw new NoSuchElementException ( lr_4 ) ; } @Override public boolean isEmpty () { return true ; } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) {
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; } @Override public String getAny () {
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_7 ; } public Set < String > getLanguages () { return this . languages ; }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR4Mutator]MSP[S] } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S] ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; MST[NonVoidMethodCallMutator]MSP[N] if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.UOI4Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[InlineConstantMutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public String getAny () {
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String getAny () {
public LanguageSet merge ( final LanguageSet other ) { return other ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { return lr_7 ; } public Set < String > getLanguages () { return this . languages ; }
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String getAny () {
public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_7 ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Set < String > getLanguages () { return this . languages ; }
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[InlineConstantMutator]MSP[S] } @Override public String getAny () {
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } @Override public String getAny () {
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public String getAny () {
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; MST[NullReturnValsMutator]MSP[N] } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String getAny () {
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; MST[ReturnValsMutator]MSP[N] } @Override
return this ; } @Override public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_5 ; } @Override public boolean contains ( final String language ) { return true ; MST[ReturnValsMutator]MSP[S] } @Override public String getAny () {
throw new NoSuchElementException ( lr_6 ) ; MST[ConstructorCallMutator]MSP[S] } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[ReturnValsMutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[ReturnValsMutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[rv.CRCR1Mutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
public LanguageSet merge ( final LanguageSet other ) { return other ; MST[NullReturnValsMutator]MSP[S] } @Override public String toString () { return lr_7 ; } public Set < String > getLanguages () { return this . languages ; }
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[rv.CRCR5Mutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_7 ; MST[ReturnValsMutator]MSP[N] } public Set < String > getLanguages () { return this . languages ; }
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[rv.CRCR6Mutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[rv.CRCR5Mutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; } @Override public boolean isSingleton () { return false ; MST[rv.CRCR3Mutator]MSP[N] } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[InlineConstantMutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[rv.CRCR6Mutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[rv.CRCR3Mutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
throw new NoSuchElementException ( lr_6 ) ; } @Override public boolean isEmpty () { return false ; MST[rv.CRCR1Mutator]MSP[S] } @Override public boolean isSingleton () { return false ; } @Override public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } @Override
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR5Mutator]MSP[S] } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
return LANGUAGES . get ( nameType ) ; MST[NullReturnValsMutator]MSP[S] } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) ,
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR6Mutator]MSP[S] } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
return new Languages ( Collections . unmodifiableSet ( ls ) ) ; MST[ReturnValsMutator]MSP[N] } } private static String langResourceName ( final NameType nameType ) { return String . format ( lr_3 , nameType . getName () ) ; } @Override public boolean contains ( final String language ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[NegateConditionalsMutator]MSP[S]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.UOI2Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.UOI1Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.UOI3Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
return LANGUAGES . get ( nameType ) ; } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; MST[ConstructorCallMutator]MSP[N] try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) ,
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[rv.ROR4Mutator]MSP[S] ls . add ( line ) ; } } }
return new Languages ( Collections . unmodifiableSet ( ls ) ) ; MST[ArgumentPropagationMutator]MSP[S] } } private static String langResourceName ( final NameType nameType ) { return String . format ( lr_3 , nameType . getName () ) ; } @Override public boolean contains ( final String language ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[NegateConditionalsMutator]MSP[N] ls . add ( line ) ; } } }
inExtendedComment = false ; MST[rv.CRCR6Mutator]MSP[S] } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR5Mutator]MSP[N] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR3Mutator]MSP[N] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR1Mutator]MSP[N] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; MST[NonVoidMethodCallMutator]MSP[N] } } }
return LANGUAGES . get ( nameType ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) ,
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[NonVoidMethodCallMutator]MSP[N] ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[rv.ROR2Mutator]MSP[N] ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; MST[rv.CRCR5Mutator]MSP[N] while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; MST[rv.CRCR6Mutator]MSP[N] while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[rv.ROR1Mutator]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[rv.ROR3Mutator]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[NegateConditionalsMutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[rv.ROR2Mutator]MSP[S] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[rv.ROR4Mutator]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
return new Languages ( Collections . unmodifiableSet ( ls ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } } private static String langResourceName ( final NameType nameType ) { return String . format ( lr_3 , nameType . getName () ) ; } @Override public boolean contains ( final String language ) {
inExtendedComment = false ; MST[InlineConstantMutator]MSP[S] } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; MST[rv.CRCR3Mutator]MSP[N] while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[rv.ROR5Mutator]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; MST[rv.CRCR1Mutator]MSP[N] while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR3Mutator]MSP[S]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR1Mutator]MSP[S]
public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_7 ; } public Set < String > getLanguages () { return this . languages ; MST[ReturnValsMutator]MSP[N] }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR2Mutator]MSP[S]
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[InlineConstantMutator]MSP[S] } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR4Mutator]MSP[S]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.ROR3Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.ABSMutator]MSP[S] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
return LANGUAGES . get ( nameType ) ; MST[ReturnValsMutator]MSP[N] } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) ,
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; MST[NonVoidMethodCallMutator]MSP[N] if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
return LANGUAGES . get ( nameType ) ; } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) , MST[NonVoidMethodCallMutator]MSP[N]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[rv.ROR5Mutator]MSP[S]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[NonVoidMethodCallMutator]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.ROR5Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.ROR2Mutator]MSP[S] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.ROR1Mutator]MSP[N] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[rv.ROR4Mutator]MSP[S] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[NonVoidMethodCallMutator]MSP[S] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; MST[rv.CRCR3Mutator]MSP[S] } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[rv.ROR5Mutator]MSP[N] ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { MST[NegateConditionalsMutator]MSP[N] final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
return new Languages ( Collections . unmodifiableSet ( ls ) ) ; MST[NullReturnValsMutator]MSP[N] } } private static String langResourceName ( final NameType nameType ) { return String . format ( lr_3 , nameType . getName () ) ; } @Override public boolean contains ( final String language ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR4Mutator]MSP[S] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; MST[InlineConstantMutator]MSP[N] while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; MST[rv.CRCR1Mutator]MSP[S] } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
return LANGUAGES . get ( nameType ) ; } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) , MST[ConstructorCallMutator]MSP[N]
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { MST[NonVoidMethodCallMutator]MSP[S]
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[rv.ROR2Mutator]MSP[S] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; MST[rv.CRCR5Mutator]MSP[S] } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; if ( inExtendedComment ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { MST[NegateConditionalsMutator]MSP[N] inExtendedComment = true ; } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( lsScanner . hasNextLine () ) { final String line = lsScanner . nextLine () . trim () ; MST[experimental.NakedReceiverMutator]MSP[S] if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) {
return new Languages ( Collections . unmodifiableSet ( ls ) ) ; MST[ConstructorCallMutator]MSP[N] } } private static String langResourceName ( final NameType nameType ) { return String . format ( lr_3 , nameType . getName () ) ; } @Override public boolean contains ( final String language ) {
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[rv.ROR3Mutator]MSP[N] ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; } else if ( line . length () > 0 ) { MST[rv.ROR1Mutator]MSP[S] ls . add ( line ) ; } } }
return LANGUAGES . get ( nameType ) ; MST[ArgumentPropagationMutator]MSP[N] } public static Languages getInstance ( final String languagesResourceName ) { final Set < String > ls = new HashSet <> () ; try ( final Scanner lsScanner = new Scanner ( Resources . getInputStream ( languagesResourceName ) ,
public LanguageSet merge ( final LanguageSet other ) { return other ; } @Override public String toString () { return lr_7 ; } public Set < String > getLanguages () { return this . languages ; MST[EmptyObjectReturnValsMutator]MSP[N] }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR2Mutator]MSP[S] } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
inExtendedComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inExtendedComment = true ; MST[rv.CRCR3Mutator]MSP[S] } else if ( line . length () > 0 ) { ls . add ( line ) ; } } }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
public int getMaxCodeLen () { return this . maxCodeLen ; } public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[InlineConstantMutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR3Mutator]MSP[S] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[NonVoidMethodCallMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI3Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR2Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] break; } code . append ( symb ) ; break; case 'C' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N]
code . append ( 'H' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI3Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ABSMutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[InlineConstantMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; MST[ReturnValsMutator]MSP[N] } if ( txtLength == 1 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI1Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[NegateConditionalsMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_8 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI3Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR1Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR6Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'K' : if ( n > 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR5Mutator]MSP[N]
return n + 1 == wdsz ; MST[NegateConditionalsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[rv.AOD1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ABSMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR1Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR4Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N]
} else { code . append ( 'T' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[ConditionalsBoundaryMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR4Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ABSMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return code . toString () ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR4Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ABSMutator]MSP[N] if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && MST[rv.ROR1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
return n + 1 == wdsz ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI3Mutator]MSP[N] }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: local . append ( inwd ) ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR4Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR1Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR2Mutator]MSP[S] break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR2Mutator]MSP[S] break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[IncrementsMutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI4Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI3Mutator]MSP[N] } return matches ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR4Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[ReturnValsMutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[BooleanTrueReturnValsMutator]MSP[N] }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR2Mutator]MSP[S]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
isNextChar ( local , n , 'H' ) && MST[rv.CRCR2Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S]
if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI4Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[InlineConstantMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[experimental.NakedReceiverMutator]MSP[N] case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] code . append ( 'J' ) ; n += 2 ;
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOD2Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && MST[rv.AOR3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI2Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR1Mutator]MSP[S] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR1Mutator]MSP[N] } return matches ; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR4Mutator]MSP[S] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR5Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR1Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI4Mutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[MathMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR6Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[NegateConditionalsMutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[MathMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR4Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.ROR2Mutator]MSP[S] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.UOI2Mutator]MSP[S] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[NegateConditionalsMutator]MSP[N]
return n + 1 == wdsz ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.CRCR5Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[NegateConditionalsMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR4Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR6Mutator]MSP[N] case 'W' : case 'Y' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR5Mutator]MSP[N] break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR5Mutator]MSP[N] break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[NonVoidMethodCallMutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI3Mutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR2Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR1Mutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR1Mutator]MSP[N] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR2Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR4Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[InlineConstantMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; MST[InlineConstantMutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.ABSMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[NonVoidMethodCallMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[MathMutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
public String metaphone ( final String txt ) { MST[rv.CRCR2Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI3Mutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR4Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; MST[rv.ROR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR5Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'D' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI3Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} return matches ; MST[rv.UOI3Mutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD2Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR1Mutator]MSP[N]
code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR1Mutator]MSP[S] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[InlineConstantMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI1Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[InlineConstantMutator]MSP[S]
boolean matches = false ; if( index > 0 && MST[rv.ABSMutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI4Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR4Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NonVoidMethodCallMutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR5Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[N] if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR2Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR4Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[S] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.CRCR4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR1Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR3Mutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] break; }
if ( regionMatch ( local , n , lr_8 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } @Override
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ABSMutator]MSP[N] break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR3Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR1Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI2Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'T' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'K' : if ( n > 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[InlineConstantMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR3Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ABSMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[ConditionalsBoundaryMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR2Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[S] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR1Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
isNextChar ( local , n , 'H' ) && MST[rv.ROR4Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[InlineConstantMutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ABSMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.AOR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[experimental.NakedReceiverMutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NegateConditionalsMutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR1Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N]
public String metaphone ( final String txt ) { MST[NegateConditionalsMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR3Mutator]MSP[S]
} return matches ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ABSMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR4Mutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR1Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI2Mutator]MSP[S] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N] } return matches ; }
code . append ( 'F' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[NegateConditionalsMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
isNextChar ( local , n , 'H' ) && MST[rv.UOI3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.CRCR6Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[MathMutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOD1Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR2Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR1Mutator]MSP[S]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[NegateConditionalsMutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR5Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[S]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N] if ( n == 0 &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ABSMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR2Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR1Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[NegateConditionalsMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR5Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR5Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[NegateConditionalsMutator]MSP[N] } return matches ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[InlineConstantMutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR4Mutator]MSP[S]
public String metaphone ( final String txt ) { boolean hard = false ; MST[InlineConstantMutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[NegateConditionalsMutator]MSP[N] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[NegateConditionalsMutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI4Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && MST[rv.ROR3Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.ABSMutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[NegateConditionalsMutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'F' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
local . setCharAt ( 0 , 'W' ) ; MST[VoidMethodCallMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR3Mutator]MSP[N]
public String encode ( final String str ) { return metaphone ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR1Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'T' :
code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI2Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR2Mutator]MSP[N] case 'W' : case 'Y' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
local . setCharAt ( 0 , 'W' ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[NegateConditionalsMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[N] } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && MST[NonVoidMethodCallMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ArgumentPropagationMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NonVoidMethodCallMutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.ROR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR4Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR5Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[ReturnValsMutator]MSP[N] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR1Mutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ArgumentPropagationMutator]MSP[N] }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[ArgumentPropagationMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
return n + 1 == wdsz ; MST[MathMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI4Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[NegateConditionalsMutator]MSP[N]
public String metaphone ( final String txt ) { MST[rv.UOI2Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR2Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI2Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI3Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
public String metaphone ( final String txt ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR2Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[InlineConstantMutator]MSP[N] if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR3Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[MathMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR5Mutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR4Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
code . append ( 'S' ) ; break; default: break; } n ++ ; MST[IncrementsMutator]MSP[N] } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
public String metaphone ( final String txt ) { MST[rv.ROR5Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; }
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR4Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR2Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( n == 0 &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[S]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR6Mutator]MSP[N]
boolean matches = false ; MST[rv.CRCR1Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
return n + 1 == wdsz ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[ConditionalsBoundaryMutator]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR6Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( regionMatch ( local , n , lr_8 ) || MST[NonVoidMethodCallMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[S]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[NegateConditionalsMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR4Mutator]MSP[N]
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR4Mutator]MSP[S] matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI3Mutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'H' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR2Mutator]MSP[S] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[NegateConditionalsMutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
public String metaphone ( final String txt ) { MST[rv.CRCR2Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR1Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR5Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR1Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
return n + 1 == wdsz ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] code . append ( 'S' ) ; break; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[ReturnValsMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI1Mutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR4Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOD2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR5Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR2Mutator]MSP[S] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ABSMutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR5Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public String metaphone ( final String txt ) { MST[InlineConstantMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NonVoidMethodCallMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] code . append ( 'J' ) ; n += 2 ;
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
return n + 1 == wdsz ; MST[rv.UOI2Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; MST[NonVoidMethodCallMutator]MSP[N] int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.AOR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR5Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR3Mutator]MSP[S] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] matches = string . charAt ( index + 1 ) == c ;
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'D' :
} return matches ; MST[ReturnValsMutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR4Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[NegateConditionalsMutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR5Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'Z' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR2Mutator]MSP[N]
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR4Mutator]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[InlineConstantMutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR1Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
boolean matches = false ; if( index > 0 && MST[rv.ROR2Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'D' :
code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_4]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_5]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_3]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI2Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR2Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] break; case 'C' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NegateConditionalsMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR5Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI1Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR1Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[InlineConstantMutator]MSP[S]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI2Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[InlineConstantMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR5Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[InlineConstantMutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR3Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
boolean matches = false ; if( index > 0 && MST[rv.ROR5Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_3]MSP[S] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_4]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.RemoveSwitchMutator_5]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NegateConditionalsMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR2Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR6Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.ABSMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
isNextChar ( local , n , 'H' ) && MST[rv.AOD2Mutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI4Mutator]MSP[N] if ( n == 0 &&
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR5Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR5Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI3Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR1Mutator]MSP[N] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR1Mutator]MSP[N] break; }
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR6Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
return n + 1 == wdsz ; MST[rv.ROR1Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI2Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR2Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NegateConditionalsMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR2Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'K' : if ( n > 0 ) {
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR3Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR3Mutator]MSP[S]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI2Mutator]MSP[S] }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[S] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR2Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( n == 0 &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'K' : if ( n > 0 ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'S' ) ; break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR5Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR3Mutator]MSP[S] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR1Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && MST[rv.CRCR6Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'T' :
code . append ( 'F' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOD1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
return n + 1 == wdsz ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[InlineConstantMutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI2Mutator]MSP[S] } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'H' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.ABSMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[BooleanFalseReturnValsMutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR5Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[N] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[NonVoidMethodCallMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI4Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[S]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR5Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR3Mutator]MSP[N] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR4Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[ConditionalsBoundaryMutator]MSP[S] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ABSMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR4Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI3Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[InlineConstantMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR6Mutator]MSP[N]
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI1Mutator]MSP[S] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI4Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[ConditionalsBoundaryMutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR5Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( n == 0 &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'T' :
if ( regionMatch ( local , n , lr_8 ) || MST[NegateConditionalsMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR5Mutator]MSP[S]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[InlineConstantMutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR3Mutator]MSP[N] case 'W' : case 'Y' :
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR2Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI3Mutator]MSP[N]
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR1Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR2Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI2Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR3Mutator]MSP[N] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[S] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . setCharAt ( 0 , 'W' ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR4Mutator]MSP[S] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR4Mutator]MSP[N] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR4Mutator]MSP[N] } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI1Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR5Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[InlineConstantMutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; MST[VoidMethodCallMutator]MSP[N] } } return code . toString () ; }
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR1Mutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { MST[rv.ROR1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[InlineConstantMutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR3Mutator]MSP[S] return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOD1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
boolean matches = false ; MST[rv.CRCR5Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[ConstructorCallMutator]MSP[N] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI2Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[ConditionalsBoundaryMutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_8]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_9]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_6]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR3Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_7]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR3Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR1Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR1Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR2Mutator]MSP[N] } return matches ; }
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR2Mutator]MSP[S] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI1Mutator]MSP[N] break; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[NegateConditionalsMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR2Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
code . append ( 'H' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR2Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ABSMutator]MSP[S] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ABSMutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR1Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[InlineConstantMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR6Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[ConditionalsBoundaryMutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR3Mutator]MSP[S] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR5Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI4Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR2Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI2Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[NonVoidMethodCallMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[NonVoidMethodCallMutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
return n + 1 == wdsz ; MST[rv.CRCR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI2Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR1Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
regionMatch ( local , n , lr_6 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[NonVoidMethodCallMutator]MSP[N] case 'W' : case 'Y' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR5Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI3Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[rv.ROR3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI4Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR1Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR1Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR1Mutator]MSP[S]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[experimental.RemoveIncrementsMutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N]
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR1Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
return n + 1 == wdsz ; MST[rv.ROR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR5Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { code . append ( 'T' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'H' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[ConditionalsBoundaryMutator]MSP[S]
code . append ( 'F' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR4Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI1Mutator]MSP[S] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.CRCR5Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOD2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI1Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR3Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( isPreviousChar ( local , n , 'S' ) && MST[NegateConditionalsMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR4Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR3Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR1Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[rv.CRCR6Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[S]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR5Mutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI4Mutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'C' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
public String encode ( final String str ) { return metaphone ( str ) ; MST[ArgumentPropagationMutator]MSP[N] } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'H' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[NonVoidMethodCallMutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR2Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR3Mutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ArgumentPropagationMutator]MSP[N] }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR5Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[ConditionalsBoundaryMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'S' ) ; break; }
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ABSMutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR2Mutator]MSP[N]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[NegateConditionalsMutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR6Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR1Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI3Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
return n + 1 == wdsz ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N]
code . append ( 'F' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR3Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ABSMutator]MSP[S]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[NegateConditionalsMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] index + test . length () - 1 < string . length () ) {
public String metaphone ( final String txt ) { MST[rv.CRCR4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[S]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI3Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR2Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR2Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[ReturnValsMutator]MSP[N] }
code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[NonVoidMethodCallMutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'H' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR3Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI2Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR3Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
return n + 1 == wdsz ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.ABSMutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ABSMutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { MST[rv.UOI1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR2Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR4Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] break; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR4Mutator]MSP[S] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR5Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR1Mutator]MSP[N] } return matches ; }
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[rv.CRCR6Mutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI1Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
public String metaphone ( final String txt ) { MST[rv.ROR4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI2Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( n == 0 &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'T' :
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'T' :
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR1Mutator]MSP[N] case 'W' : case 'Y' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[NegateConditionalsMutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOD1Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
return n + 1 == wdsz ; MST[rv.AOD2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[experimental.NakedReceiverMutator]MSP[N] final StringBuilder local = new StringBuilder ( 40 ) ;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR1Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR1Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR5Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'D' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[NegateConditionalsMutator]MSP[N] index + test . length () - 1 < string . length () ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[rv.UOI4Mutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR1Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR4Mutator]MSP[N] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR3Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[NonVoidMethodCallMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.ROR3Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI2Mutator]MSP[S] } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( 'H' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && MST[rv.ROR1Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR4Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ABSMutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[S] } return metaphone ( ( String ) obj ) ; } @Override
public String metaphone ( final String txt ) { MST[InlineConstantMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI2Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI4Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR3Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR2Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR6Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR6Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.ABSMutator]MSP[S] } private boolean isLastChar ( final int wdsz , final int n ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[InlineConstantMutator]MSP[S]
boolean matches = false ; if( index > 0 && MST[rv.ABSMutator]MSP[S] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
return n + 1 == wdsz ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } @Override
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR1Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; MST[InlineConstantMutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[NonVoidMethodCallMutator]MSP[N]
} return matches ; MST[BooleanFalseReturnValsMutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR5Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR3Mutator]MSP[S] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR2Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR4Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isLastChar ( wdsz , n ) ) { MST[rv.ABSMutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
code . append ( 'F' ) ; MST[InlineConstantMutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[NegateConditionalsMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
return n + 1 == wdsz ; MST[rv.AOR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR3Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR5Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ABSMutator]MSP[N] } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[InlineConstantMutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[InlineConstantMutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; MST[rv.CRCR3Mutator]MSP[N] if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ABSMutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ABSMutator]MSP[N]
code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[ConditionalsBoundaryMutator]MSP[N] index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR3Mutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI2Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[NegateConditionalsMutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ABSMutator]MSP[N] index + test . length () - 1 < string . length () ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_13]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_14]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
isNextChar ( local , n , 'H' ) && MST[NonVoidMethodCallMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_15]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_16]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_17]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR1Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_18]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI1Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_19]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] break; case 'K' : if ( n > 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[N] code . append ( 'S' ) ; break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR3Mutator]MSP[S]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[InlineConstantMutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'S' ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[S] } return matches ; }
code . append ( 'H' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
boolean matches = false ; if( index > 0 && MST[ConditionalsBoundaryMutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( n == 0 &&
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[ReturnValsMutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ABSMutator]MSP[S]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI1Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_20]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_21]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_22]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR2Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_23]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_24]MSP[S] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_25]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
boolean matches = false ; MST[rv.CRCR6Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
boolean matches = false ; if( index > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
public String metaphone ( final String txt ) { MST[experimental.MemberVariableMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI1Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[InlineConstantMutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOD1Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI2Mutator]MSP[S]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOD2Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[S] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR3Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR6Mutator]MSP[N]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] break; case 'K' : if ( n > 0 ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR4Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR2Mutator]MSP[S] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI2Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR3Mutator]MSP[S] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR6Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_10]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 'Z' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_11]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.RemoveSwitchMutator_12]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; MST[rv.UOI2Mutator]MSP[S] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR5Mutator]MSP[S]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[NonVoidMethodCallMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR2Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR4Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String metaphone ( final String txt ) { MST[rv.UOI4Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
return n + 1 == wdsz ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR2Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
public String metaphone ( final String txt ) { MST[rv.CRCR1Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR2Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR5Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR5Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} return matches ; MST[rv.ABSMutator]MSP[S] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ABSMutator]MSP[S] regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ABSMutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ABSMutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NegateConditionalsMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR5Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.ABSMutator]MSP[S] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR2Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI3Mutator]MSP[N] if ( n == 0 &&
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.UOI1Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[InlineConstantMutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[InlineConstantMutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR2Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR4Mutator]MSP[N] case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOD2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI2Mutator]MSP[S] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'H' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR2Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
return n + 1 == wdsz ; MST[rv.ROR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.ABSMutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NonVoidMethodCallMutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR3Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ABSMutator]MSP[S]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[rv.UOI3Mutator]MSP[N] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.ROR4Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.UOI3Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.ROR3Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[InlineConstantMutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.UOI4Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR4Mutator]MSP[S] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.UOI4Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR3Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR5Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR4Mutator]MSP[N]
boolean matches = false ; if( index > 0 && MST[rv.UOI2Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
code . append ( 'S' ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOD2Mutator]MSP[N] } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR1Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR2Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR5Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR1Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR3Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI4Mutator]MSP[N]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[MathMutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.UOI2Mutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI3Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.ABSMutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR5Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[MathMutator]MSP[S]
boolean matches = false ; if( index > 0 && MST[NegateConditionalsMutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR6Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[S] code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR5Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR4Mutator]MSP[N] } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( n == 0 &&
return n + 1 == wdsz ; MST[rv.UOI1Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return n + 1 == wdsz ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final String substring = string . substring ( index , index + test . length () ) ; MST[MathMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR3Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR4Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOD2Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR5Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[ConditionalsBoundaryMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
isNextChar ( local , n , 'H' ) && MST[rv.AOR2Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && MST[InlineConstantMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI1Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[NonVoidMethodCallMutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI3Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.UOI2Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOD2Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.ROR3Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR3Mutator]MSP[S]
isNextChar ( local , n , 'H' ) && MST[rv.CRCR3Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR3Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR2Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR2Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR2Mutator]MSP[N]
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR2Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR1Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[rv.ROR3Mutator]MSP[N] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.ROR3Mutator]MSP[N] break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR3Mutator]MSP[N] } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NegateConditionalsMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[NegateConditionalsMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ABSMutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[NegateConditionalsMutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR2Mutator]MSP[N]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NonVoidMethodCallMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'S' ) ; MST[rv.CRCR1Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR2Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[S] code . append ( 'J' ) ; n += 2 ;
final StringBuilder code = new StringBuilder ( 10 ) ; MST[rv.CRCR5Mutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI1Mutator]MSP[S]
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR1Mutator]MSP[S] break; } code . append ( symb ) ; break; case 'C' :
code . append ( 'H' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR1Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR2Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[NegateConditionalsMutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.ROR4Mutator]MSP[S] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR5Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI1Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
public String metaphone ( final String txt ) { MST[rv.ROR3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR4Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[ConditionalsBoundaryMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[rv.ROR5Mutator]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR6Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
isNextChar ( local , n , 'H' ) && MST[rv.UOI1Mutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.CRCR4Mutator]MSP[N] } return matches ; }
public String metaphone ( final String txt ) { MST[NonVoidMethodCallMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR1Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[InlineConstantMutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR2Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI4Mutator]MSP[N] } return matches ; }
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[MathMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && MST[rv.ROR2Mutator]MSP[S] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR2Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.UOI2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.UOI3Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI4Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.AOR4Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[ArgumentPropagationMutator]MSP[S] break; } if ( isVowel ( local , n + 1 ) ) {
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR1Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR5Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[ConstructorCallMutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI4Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'S' ) ; break; }
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR6Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI4Mutator]MSP[N] }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR2Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR2Mutator]MSP[N] } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[InlineConstantMutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI1Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.ROR2Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR3Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR1Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI3Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] code . append ( 'S' ) ; break; }
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; MST[rv.CRCR6Mutator]MSP[N] } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR3Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
isNextChar ( local , n , 'H' ) && MST[NegateConditionalsMutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
return n + 1 == wdsz ; MST[rv.CRCR1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ; MST[rv.CRCR4Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N]
} else { code . append ( 'T' ) ; MST[rv.CRCR2Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR5Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.CRCR3Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[NonVoidMethodCallMutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[NegateConditionalsMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.CRCR4Mutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[InlineConstantMutator]MSP[N] break; case 'Z' :
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR4Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[MathMutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[S] index + test . length () - 1 < string . length () ) {
} return matches ; MST[rv.UOI4Mutator]MSP[N] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[S]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S] if ( n == 0 &&
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR3Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; MST[rv.CRCR5Mutator]MSP[N] } if ( ! isLastChar ( wdsz , n ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[S]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'S' ) ; MST[rv.CRCR4Mutator]MSP[N] break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.UOI2Mutator]MSP[S] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI4Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[rv.ROR4Mutator]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[rv.UOI3Mutator]MSP[N] break; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[ReturnValsMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( regionMatch ( local , n , lr_11 ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.ROR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'H' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.ROR5Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.UOI3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
} else { code . append ( 'T' ) ; MST[rv.CRCR5Mutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[NonVoidMethodCallMutator]MSP[S] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[rv.ABSMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.CRCR3Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[MathMutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOR2Mutator]MSP[N]
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && MST[rv.UOI4Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI4Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[rv.ROR5Mutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI1Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR5Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.UOI2Mutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { MST[rv.CRCR6Mutator]MSP[N] matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[rv.CRCR1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ABSMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR2Mutator]MSP[N]
boolean matches = false ; MST[rv.CRCR3Mutator]MSP[N] if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[ConditionalsBoundaryMutator]MSP[N]
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.AOR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.UOI1Mutator]MSP[N]
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.ROR5Mutator]MSP[N] } return matches ; }
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR6Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[rv.CRCR5Mutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR5Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.ROR5Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; MST[rv.CRCR6Mutator]MSP[S] int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'S' ) ; break; }
boolean matches = false ; if( index > 0 && index < string . length () ) { MST[rv.ROR2Mutator]MSP[N] matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.AOD1Mutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI4Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR4Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'D' :
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { MST[rv.ROR3Mutator]MSP[N] code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && MST[rv.ROR5Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[InlineConstantMutator]MSP[N] } return matches ; }
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.AOR3Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR1Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR1Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ABSMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; MST[rv.CRCR4Mutator]MSP[N] } } else { code . append ( 'K' ) ; } break; case 'D' :
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
isNextChar ( local , n , 'H' ) && MST[rv.AOR4Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) { MST[rv.ROR3Mutator]MSP[S]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[NegateConditionalsMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.AOR3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI4Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR2Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
final String substring = string . substring ( index , index + test . length () ) ; MST[rv.UOI3Mutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[InlineConstantMutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR5Mutator]MSP[N]
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI3Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.CRCR4Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI1Mutator]MSP[S]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.AOD1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR3Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[rv.CRCR5Mutator]MSP[N] case 'W' : case 'Y' :
return n + 1 == wdsz ; MST[rv.AOD1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[NegateConditionalsMutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR2Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.ROR4Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR3Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI1Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.CRCR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOR2Mutator]MSP[N] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR3Mutator]MSP[S]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.UOI4Mutator]MSP[N]
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N] if ( n == 0 &&
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR5Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR2Mutator]MSP[N]
final String substring = string . substring ( index , index + test . length () ) ; matches = substring . equals ( test ) ; } return matches ; MST[rv.UOI1Mutator]MSP[S] } private boolean isLastChar ( final int wdsz , final int n ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.AOR3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
code . append ( symb ) ; } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break; } code . append ( symb ) ; break; case 'C' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.CRCR6Mutator]MSP[N]
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[NonVoidMethodCallMutator]MSP[S] break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] break; }
if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[InlineConstantMutator]MSP[N]
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ROR5Mutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR2Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[InlineConstantMutator]MSP[N]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[MathMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.AOD2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; MST[rv.CRCR5Mutator]MSP[S] break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && MST[RemoveConditionalMutator_ORDER_IF]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { MST[experimental.SwitchMutator]MSP[N] case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NegateConditionalsMutator]MSP[N]
isNextChar ( local , n , 'H' ) && MST[rv.CRCR4Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[NegateConditionalsMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.CRCR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N] if ( n == 0 &&
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; MST[rv.CRCR2Mutator]MSP[N] break; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR1Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && ! hard ) { code . append ( 'J' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'K' ) ; } break; case 'H' :
code . append ( 'F' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
public String metaphone ( final String txt ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR6Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.UOI3Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
boolean matches = false ; if( index > 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
code . append ( 'F' ) ; } else { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[N] } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
public String metaphone ( final String txt ) { boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return lr_1 ; } if ( txtLength == 1 ) {
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.AOD1Mutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) { MST[rv.ROR3Mutator]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[rv.CRCR3Mutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
boolean matches = false ; if( index > 0 && MST[rv.ROR4Mutator]MSP[S] index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; }
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 'Z' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[rv.UOI4Mutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ROR1Mutator]MSP[N] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR1Mutator]MSP[N] } break; case 'D' :
public String metaphone ( final String txt ) { MST[rv.UOI3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
final String substring = string . substring ( index , index + test . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] matches = substring . equals ( test ) ; } return matches ; } private boolean isLastChar ( final int wdsz , final int n ) {
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.AOD1Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR2Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.ROR3Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; } return matches ; MST[rv.UOI1Mutator]MSP[S] }
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.ROR4Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.ROR1Mutator]MSP[S]
if ( regionMatch ( local , n , lr_11 ) ) { MST[rv.ROR3Mutator]MSP[N] code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
code . append ( symb ) ; MST[experimental.NakedReceiverMutator]MSP[N] } break; case 'B' : if ( isPreviousChar ( local , n , 'M' ) && isLastChar ( wdsz , n ) ) { break; } code . append ( symb ) ; break; case 'C' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] break; } if ( regionMatch ( local , n , lr_2 ) ) {
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI3Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( isPreviousChar ( local , n , 'S' ) && MST[InlineConstantMutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI1Mutator]MSP[S] } return matches ; }
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.AOR3Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return n + 1 == wdsz ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI1Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR3Mutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && MST[rv.CRCR3Mutator]MSP[N] VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR2Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.CRCR6Mutator]MSP[N]
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; MST[rv.UOI1Mutator]MSP[S] break; case 'K' : if ( n > 0 ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR3Mutator]MSP[N]
return n + 1 == wdsz ; MST[rv.UOI1Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR6Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.CRCR4Mutator]MSP[S]
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR2Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR3Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ABSMutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) { MST[rv.UOI1Mutator]MSP[N]
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[NegateConditionalsMutator]MSP[N]
return n + 1 == wdsz ; MST[rv.CRCR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.UOI1Mutator]MSP[S] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
} if ( isPreviousChar ( local , n , 'G' ) ) { MST[rv.ROR3Mutator]MSP[N] hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) &&
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.CRCR4Mutator]MSP[S] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[NegateConditionalsMutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ABSMutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ; MST[rv.UOI1Mutator]MSP[N]
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.ROR4Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR4Mutator]MSP[N]
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; MST[NonVoidMethodCallMutator]MSP[N] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && MST[NegateConditionalsMutator]MSP[N] ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.ROR2Mutator]MSP[N]
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
return n + 1 == wdsz ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[NegateConditionalsMutator]MSP[N] throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.AOR4Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.ROR2Mutator]MSP[N]
FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 && MST[rv.ABSMutator]MSP[S] ! hard ) { code . append ( 'J' ) ; } else { code . append ( 'K' ) ; } break; case 'H' :
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.ROR5Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[rv.UOI1Mutator]MSP[S]
local . setCharAt ( 0 , 'W' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { MST[NonVoidMethodCallMutator]MSP[S] break; } if ( isVowel ( local , n + 1 ) ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[rv.CRCR3Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] local . append ( inwd , 1 , inwd . length - 1 ) ;
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[N] final StringBuilder local = new StringBuilder ( 40 ) ;
if ( ! isPreviousChar ( local , n , 'C' ) ) { MST[rv.ROR2Mutator]MSP[N] code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[rv.AOR4Mutator]MSP[N]
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[InlineConstantMutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; MST[rv.CRCR5Mutator]MSP[N] if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; MST[rv.ABSMutator]MSP[N] } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI3Mutator]MSP[N] ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
public int getMaxCodeLen () { return this . maxCodeLen ; } MST[PrimitiveReturnsMutator]MSP[N] public void setMaxCodeLen ( final int maxCodeLen ) { this . maxCodeLen = maxCodeLen ; }
} return matches ; MST[rv.UOI1Mutator]MSP[S] } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) {
code . append ( 'F' ) ; } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) || MST[rv.UOI4Mutator]MSP[N]
public String metaphone ( final String txt ) { MST[rv.ABSMutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'F' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { code . append ( symb ) ; } break; case 'Q' : code . append ( 'K' ) ; break; case 'S' : if ( regionMatch ( local , n , lr_5 ) ||
code . append ( 'S' ) ; break; default: break; } n ++ ; } if ( code . length () > this . getMaxCodeLen () ) { MST[NegateConditionalsMutator]MSP[N] code . setLength ( this . getMaxCodeLen () ) ; } } return code . toString () ; }
if ( ! isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ; MST[rv.CRCR5Mutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; MST[InlineConstantMutator]MSP[N] case 'W' : case 'Y' :
return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; MST[ReturnValsMutator]MSP[N] } final char [] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray () ; final StringBuilder local = new StringBuilder ( 40 ) ;
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( ! isLastChar ( wdsz , n ) && isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; MST[NonVoidMethodCallMutator]MSP[N] code . append ( 'S' ) ; break; case 'Z' :
if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
isNextChar ( local , n , 'H' ) && MST[rv.AOR1Mutator]MSP[N] ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { break;
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; MST[rv.CRCR2Mutator]MSP[N] break; } if ( regionMatch ( local , n , lr_10 ) ) { break; }
final StringBuilder code = new StringBuilder ( 10 ) ; MST[InlineConstantMutator]MSP[S] switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( isLastChar ( wdsz , n ) ) { MST[rv.ROR3Mutator]MSP[N] break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) {
public String metaphone ( final String txt ) { MST[rv.CRCR3Mutator]MSP[N] boolean hard = false ; int txtLength ; if ( txt == null || ( txtLength = txt . length () ) == 0 ) { return lr_1 ; } if ( txtLength == 1 ) {
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.ROR5Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.CRCR6Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI4Mutator]MSP[N] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ;
} else { code . append ( 'T' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || MST[rv.UOI4Mutator]MSP[N] regionMatch ( local , n , lr_4 ) ) ) { break;
code . append ( 'X' ) ; break; } if ( ! isLastChar ( wdsz , n ) && MST[MathMutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
code . append ( 'X' ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
return n + 1 == wdsz ; MST[rv.AOR1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
code . append ( 'H' ) ; MST[InlineConstantMutator]MSP[N] } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) {
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { MST[experimental.SwitchMutator]MSP[N] case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) {
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) { MST[rv.ROR5Mutator]MSP[N]
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) {
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) && MST[rv.UOI2Mutator]MSP[N]
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[rv.UOI1Mutator]MSP[S] } return matches ; }
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'A' : if ( inwd [ 1 ] == 'E' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.UOI1Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && MST[rv.ROR2Mutator]MSP[S] isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 &&
boolean matches = false ; if( index > 0 && index < string . length () ) { matches = string . charAt ( index - 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return matches ; }
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && isNextChar ( local , n , 'H' ) ) { MST[rv.ROR1Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
final int wdsz = local . length () ; int n = 0 ; while ( code . length () < this . getMaxCodeLen () && MST[rv.ABSMutator]MSP[N] n < wdsz ) { final char symb = local . charAt ( n ) ;
wdsz >= 3 && isVowel ( local , 2 ) ) { code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; MST[rv.CRCR4Mutator]MSP[N] } break; case 'D' :
if ( regionMatch ( local , n , lr_8 ) || regionMatch ( local , n , lr_9 ) ) { code . append ( 'X' ) ; break; } if ( regionMatch ( local , n , lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; }
local . append ( inwd , 1 , inwd . length - 1 ) ; } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) { MST[rv.CRCR6Mutator]MSP[S]
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( regionMatch ( local , n , lr_11 ) ) { code . append ( '0' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { code . append ( 'T' ) ; } break; case 'V' : code . append ( 'F' ) ; break; case 'W' : case 'Y' :
public String encode ( final String str ) { return metaphone ( str ) ; } public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; MST[ReturnValsMutator]MSP[N] }
isNextChar ( local , n , 'H' ) && ! isVowel ( local , n + 2 ) ) { break; } if ( n > 0 && ( regionMatch ( local , n , lr_3 ) || regionMatch ( local , n , lr_4 ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break;
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && index + test . length () - 1 < string . length () ) { MST[rv.CRCR4Mutator]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.UOI4Mutator]MSP[N]
code . append ( 'X' ) ; MST[rv.CRCR3Mutator]MSP[N] break; } if ( ! isLastChar ( wdsz , n ) && FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { code . append ( 'S' ) ; break; }
} if ( isPreviousChar ( local , n , 'G' ) ) { hard = true ; } else { hard = false ; } if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI1Mutator]MSP[N]
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) { MST[rv.ROR5Mutator]MSP[N]
regionMatch ( local , n , lr_6 ) || MST[rv.UOI3Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
if ( ! isPreviousChar ( local , n , 'C' ) ) { code . append ( symb ) ; } } else { code . append ( symb ) ; MST[rv.UOI4Mutator]MSP[S] } break; case 'P' : if ( isNextChar ( local , n , 'H' ) ) {
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { MST[rv.UOI2Mutator]MSP[N] if ( n == 0 &&
if ( isPreviousChar ( local , n , 'S' ) && isNextChar ( local , n , 'H' ) ) { code . append ( 'K' ) ; break; } if ( isNextChar ( local , n , 'H' ) ) { if ( n == 0 && MST[rv.CRCR6Mutator]MSP[N]
final StringBuilder code = new StringBuilder ( 10 ) ; switch( inwd [ 0 ] ) { case 'K' : case 'G' : case 'P' : if ( inwd [ 1 ] == 'N' ) { MST[rv.ROR3Mutator]MSP[N]
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
regionMatch ( local , n , lr_6 ) || regionMatch ( local , n , lr_7 ) ) { MST[rv.ROR1Mutator]MSP[N] code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index < string . length () - 1 ) { matches = string . charAt ( index + 1 ) == c ;
local . append ( inwd , 1 , inwd . length - 1 ) ; MST[InlineConstantMutator]MSP[N] } else { local . append ( inwd ) ; } break; case 'W' : if ( inwd [ 1 ] == 'R' ) {
local . append ( inwd , 1 , inwd . length - 1 ) ; break; } if ( inwd [ 1 ] == 'H' ) { local . append ( inwd , 1 , inwd . length - 1 ) ; MST[rv.CRCR5Mutator]MSP[S]
local . setCharAt ( 0 , 'W' ) ; } else { local . append ( inwd ) ; } break; case 'X' : inwd [ 0 ] = 'S' ; MST[InlineConstantMutator]MSP[N] local . append ( inwd ) ; break; default: local . append ( inwd ) ; }
if ( ! isLastChar ( wdsz , n + 1 ) && MST[InlineConstantMutator]MSP[S] isNextChar ( local , n , 'G' ) && FRONTV . indexOf ( local . charAt ( n + 2 ) ) >= 0 ) { code . append ( 'J' ) ; n += 2 ;
return n + 1 == wdsz ; MST[rv.CRCR4Mutator]MSP[S] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_12 ) ; } return metaphone ( ( String ) obj ) ; } @Override
if ( isLastChar ( wdsz , n ) ) { break; } if ( n > 0 && VARSON . indexOf ( local . charAt ( n - 1 ) ) >= 0 ) { break; } if ( isVowel ( local , n + 1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( isPreviousChar ( local , n , 'S' ) && ! isLastChar ( wdsz , n ) && MST[rv.ROR1Mutator]MSP[N] FRONTV . indexOf ( local . charAt ( n + 1 ) ) >= 0 ) { break; } if ( regionMatch ( local , n , lr_2 ) ) {
final int wdsz = local . length () ; int n = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( code . length () < this . getMaxCodeLen () && n < wdsz ) { final char symb = local . charAt ( n ) ;
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.ROR4Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
regionMatch ( local , n , lr_6 ) || MST[rv.ROR4Mutator]MSP[N] regionMatch ( local , n , lr_7 ) ) { code . append ( 'X' ) ; } else { code . append ( 'S' ) ; } break; case 'T' :
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.CRCR2Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
} else { code . append ( 'T' ) ; } break; case 'G' : if ( isLastChar ( wdsz , n + 1 ) && MST[rv.UOI3Mutator]MSP[N] isNextChar ( local , n , 'H' ) ) { break; } if ( ! isLastChar ( wdsz , n + 1 ) &&
code . append ( 'H' ) ; } break; case 'F' : case 'J' : case 'L' : case 'M' : case 'N' : case 'R' : code . append ( symb ) ; break; case 'K' : if ( n > 0 ) { MST[rv.ROR5Mutator]MSP[N]
wdsz >= 3 && isVowel ( local , 2 ) ) { MST[rv.ROR4Mutator]MSP[N] code . append ( 'K' ) ; } else { code . append ( 'X' ) ; } } else { code . append ( 'K' ) ; } break; case 'D' :
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.UOI3Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
} return matches ; } private boolean regionMatch ( final StringBuilder string , final int index , final String test ) { boolean matches = false ; if( index >= 0 && MST[rv.UOI1Mutator]MSP[N] index + test . length () - 1 < string . length () ) {
if ( symb != 'C' && isPreviousChar ( local , n , symb ) ) { MST[rv.ROR4Mutator]MSP[N] n ++ ; } else { switch( symb ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : if ( n == 0 ) {
if ( ! isLastChar ( wdsz , n ) && MST[rv.UOI4Mutator]MSP[N] isVowel ( local , n + 1 ) ) { code . append ( symb ) ; } break; case 'X' : code . append ( 'K' ) ; code . append ( 'S' ) ; break; case 'Z' :
public static int hash32 ( final long data1 , final long data2 ) { return hash32 ( data1 , data2 , DEFAULT_SEED ) ; } public static int hash32 ( final long data1 , final long data2 , final int seed ) { int hash = seed ;
final long r0 = Long . reverseBytes ( data1 ) ; final long r1 = Long . reverseBytes ( data2 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( (int) ( r0 >>> 32 ) , hash ) ;
hash = mix32 ( (int) ( r1 ) , hash ) ; hash = mix32 ( (int) ( r1 >>> 32 ) , hash ) ; hash ^= LONG_BYTES * 2 ; return fmix32 ( hash ) ; } public static int hash32 ( final long data ) {
return hash32 ( data , DEFAULT_SEED ) ; } public static int hash32 ( final long data , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( data ) ;
hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( (int) ( r0 >>> 32 ) , hash ) ; hash ^= LONG_BYTES ; return fmix32 ( hash ) ; } @Deprecated public static int hash32 ( final byte [] data ) {
return hash32 ( data , 0 , data . length , DEFAULT_SEED ) ; } @Deprecated public static int hash32 ( final String data ) { final byte [] bytes = StringUtils . getBytesUtf8 ( data ) ;
return hash32 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } @Deprecated public static int hash32 ( final byte [] data , final int length ) { return hash32 ( data , length , DEFAULT_SEED ) ; } @Deprecated
public static int hash32 ( final byte [] data , final int length , final int seed ) { return hash32 ( data , 0 , length , seed ) ; } @Deprecated
public static int hash32 ( final byte [] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = offset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int index = offset + ( nblocks << 2 ) ; int k1 = 0 ; switch ( offset + length - index ) { case 3 : k1 ^= data [ index + 2 ] << 16 ; case 2 :
k1 ^= data [ index + 1 ] << 8 ; case 1 : k1 ^= data [ index ] ; k1 *= C1_32 ; k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; hash ^= k1 ; } hash ^= length ;
return fmix32 ( hash ) ; } public static int hash32x86 ( final byte [] data ) { return hash32x86 ( data , 0 , data . length , 0 ) ; }
public static int hash32x86 ( final byte [] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = offset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int index = offset + ( nblocks << 2 ) ; int k1 = 0 ; switch ( offset + length - index ) { case 3 : k1 ^= ( data [ index + 2 ] & 0xff ) << 16 ; case 2 :
k1 ^= ( data [ index + 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( data [ index ] & 0xff ) ; k1 *= C1_32 ; k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ;
hash ^= k1 ; } hash ^= length ; return fmix32 ( hash ) ; } @Deprecated public static long hash64 ( final long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; final int length = LONG_BYTES ;
k *= C1 ; k = Long . rotateLeft ( k , R1 ) ; k *= C2 ; hash ^= k ; hash = Long . rotateLeft ( hash , R2 ) * M + N1 ; hash ^= length ; hash = fmix64 ( hash ) ;
return hash ; } @Deprecated public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L >>> 32 ) ; final int length = INTEGER_BYTES ; long hash = DEFAULT_SEED ; k1 *= C1 ;
k1 = Long . rotateLeft ( k1 , R1 ) ; k1 *= C2 ; hash ^= k1 ; hash ^= length ; hash = fmix64 ( hash ) ; return hash ; } @Deprecated public static long hash64 ( final short data ) { long hash = DEFAULT_SEED ;
long k1 = 0 ; k1 ^= ( ( long ) data & 0xff ) << 8 ; k1 ^= ( (long) ( ( data & 0xFF00 ) >> 8 ) & 0xff ) ; k1 *= C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ;
k1 *= C2 ; hash ^= k1 ; hash ^= SHORT_BYTES ; hash = fmix64 ( hash ) ; return hash ; } @Deprecated public static long hash64 ( final byte [] data ) { return hash64 ( data , 0 , data . length , DEFAULT_SEED ) ; }
@Deprecated public static long hash64 ( final byte [] data , final int offset , final int length ) { return hash64 ( data , offset , length , DEFAULT_SEED ) ; } @Deprecated
public static long hash64 ( final byte [] data , final int offset , final int length , final int seed ) { long hash = seed ; final int nblocks = length >> 3 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = offset + ( i << 3 ) ; long k = getLittleEndianLong ( data , index ) ; k *= C1 ;
k = Long . rotateLeft ( k , R1 ) ; k *= C2 ; hash ^= k ; hash = Long . rotateLeft ( hash , R2 ) * M + N1 ; } long k1 = 0 ;
final int index = offset + ( nblocks << 3 ) ; switch ( offset + length - index ) { case 7 : k1 ^= ( ( long ) data [ index + 6 ] & 0xff ) << 48 ; case 6 :
k1 ^= ( ( long ) data [ index + 5 ] & 0xff ) << 40 ; case 5 : k1 ^= ( ( long ) data [ index + 4 ] & 0xff ) << 32 ; case 4 :
k1 ^= ( ( long ) data [ index + 3 ] & 0xff ) << 24 ; case 3 : k1 ^= ( ( long ) data [ index + 2 ] & 0xff ) << 16 ; case 2 :
k1 ^= ( ( long ) data [ index + 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( ( long ) data [ index ] & 0xff ) ; k1 *= C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ;
k1 *= C2 ; hash ^= k1 ; } hash ^= length ; hash = fmix64 ( hash ) ; return hash ; } public static long [] hash128 ( final byte [] data ) { return hash128 ( data , 0 , data . length , DEFAULT_SEED ) ;
} public static long [] hash128x64 ( final byte [] data ) { return hash128x64 ( data , 0 , data . length , 0 ) ; } @Deprecated public static long [] hash128 ( final String data ) {
final byte [] bytes = StringUtils . getBytesUtf8 ( data ) ; return hash128 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } @Deprecated
public static long [] hash128 ( final byte [] data , final int offset , final int length , final int seed ) { return hash128x64Internal ( data , offset , length , seed ) ; }
public static long [] hash128x64 ( final byte [] data , final int offset , final int length , final int seed ) { return hash128x64Internal ( data , offset , length , seed & 0xffffffffL ) ; }
private static long [] hash128x64Internal ( final byte [] data , final int offset , final int length , final long seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length >> 4 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = offset + ( i << 4 ) ; long k1 = getLittleEndianLong ( data , index ) ; long k2 = getLittleEndianLong ( data , index + 8 ) ;
k1 *= C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 *= C2 ; h1 ^= k1 ; h1 = Long . rotateLeft ( h1 , R2 ) ; h1 += h2 ; h1 = h1 * M + N1 ; k2 *= C2 ;
k2 = Long . rotateLeft ( k2 , R3 ) ; k2 *= C1 ; h2 ^= k2 ; h2 = Long . rotateLeft ( h2 , R1 ) ; h2 += h1 ; h2 = h2 * M + N2 ; } long k1 = 0 ;
long k2 = 0 ; final int index = offset + ( nblocks << 4 ) ; switch ( offset + length - index ) { case 15 : k2 ^= ( ( long ) data [ index + 14 ] & 0xff ) << 48 ; case 14 :
k2 ^= ( ( long ) data [ index + 13 ] & 0xff ) << 40 ; case 13 : k2 ^= ( ( long ) data [ index + 12 ] & 0xff ) << 32 ; case 12 :
k2 ^= ( ( long ) data [ index + 11 ] & 0xff ) << 24 ; case 11 : k2 ^= ( ( long ) data [ index + 10 ] & 0xff ) << 16 ; case 10 :
k2 ^= ( ( long ) data [ index + 9 ] & 0xff ) << 8 ; case 9 : k2 ^= data [ index + 8 ] & 0xff ; k2 *= C2 ; k2 = Long . rotateLeft ( k2 , R3 ) ;
k2 *= C1 ; h2 ^= k2 ; case 8 : k1 ^= ( ( long ) data [ index + 7 ] & 0xff ) << 56 ; case 7 : k1 ^= ( ( long ) data [ index + 6 ] & 0xff ) << 48 ;
case 6 : k1 ^= ( ( long ) data [ index + 5 ] & 0xff ) << 40 ; case 5 : k1 ^= ( ( long ) data [ index + 4 ] & 0xff ) << 32 ; case 4 :
k1 ^= ( ( long ) data [ index + 3 ] & 0xff ) << 24 ; case 3 : k1 ^= ( ( long ) data [ index + 2 ] & 0xff ) << 16 ; case 2 :
k1 ^= ( ( long ) data [ index + 1 ] & 0xff ) << 8 ; case 1 : k1 ^= data [ index ] & 0xff ; k1 *= C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 *= C2 ;
h1 ^= k1 ; } h1 ^= length ; h2 ^= length ; h1 += h2 ; h2 += h1 ; h1 = fmix64 ( h1 ) ; h2 = fmix64 ( h2 ) ; h1 += h2 ; h2 += h1 ;
return new long [] { h1 , h2 } ; } private static long getLittleEndianLong ( final byte [] data , final int index ) { return ( ( ( long ) data [ index ] & 0xff ) ) |
( ( ( long ) data [ index + 1 ] & 0xff ) << 8 ) | ( ( ( long ) data [ index + 2 ] & 0xff ) << 16 ) |
( ( ( long ) data [ index + 3 ] & 0xff ) << 24 ) | ( ( ( long ) data [ index + 4 ] & 0xff ) << 32 ) |
( ( ( long ) data [ index + 5 ] & 0xff ) << 40 ) | ( ( ( long ) data [ index + 6 ] & 0xff ) << 48 ) |
( ( ( long ) data [ index + 7 ] & 0xff ) << 56 ) ; } private static int getLittleEndianInt ( final byte [] data , final int index ) { return ( ( data [ index ] & 0xff ) ) |
( ( data [ index + 1 ] & 0xff ) << 8 ) | ( ( data [ index + 2 ] & 0xff ) << 16 ) | ( ( data [ index + 3 ] & 0xff ) << 24 ) ; }
private static int mix32 ( int k , int hash ) { k *= C1_32 ; k = Integer . rotateLeft ( k , R1_32 ) ; k *= C2_32 ; hash ^= k ; return Integer . rotateLeft ( hash , R2_32 ) * M_32 + N_32 ; }
private static int fmix32 ( int hash ) { hash ^= ( hash >>> 16 ) ; hash *= 0x85ebca6b ; hash ^= ( hash >>> 13 ) ; hash *= 0xc2b2ae35 ; hash ^= ( hash >>> 16 ) ; return hash ; }
private static long fmix64 ( long hash ) { hash ^= ( hash >>> 33 ) ; hash *= 0xff51afd7ed558ccdL ; hash ^= ( hash >>> 33 ) ; hash *= 0xc4ceb9fe1a85ec53L ; hash ^= ( hash >>> 33 ) ; return hash ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
private static int orBytes ( final byte b1 , final byte b2 , final byte b3 , final byte b4 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; } @Override @Deprecated
int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { case 3 : k1 ^= unprocessed [ 2 ] << 16 ;
case 2 : k1 ^= unprocessed [ 1 ] << 8 ; case 1 : k1 ^= unprocessed [ 0 ] ; k1 *= C1_32 ; k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ;
return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI4Mutator]MSP[N] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR6Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI2Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOD2Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI3Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI2Mutator]MSP[S] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR1Mutator]MSP[S] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI4Mutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR5Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR1Mutator]MSP[N] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR4Mutator]MSP[S] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR5Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 2 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ABSMutator]MSP[S] return;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR3Mutator]MSP[N] return;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[InlineConstantMutator]MSP[S] switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[MathMutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.ABSMutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI4Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR1Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI3Mutator]MSP[S] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN3Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR4Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[MathMutator]MSP[N] break; case 3 :
} totalLen += length ; MST[rv.AOR2Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI1Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[ReturnValsMutator]MSP[N] }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI1Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.ABSMutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[NonVoidMethodCallMutator]MSP[S] hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI4Mutator]MSP[N] } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.SwitchMutator]MSP[S]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI2Mutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.ABSMutator]MSP[N] }
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[N] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOD2Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR4Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.ABSMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[MathMutator]MSP[N] return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI3Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI2Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
int k = - 1 ; MST[rv.CRCR4Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOD2Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD1Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.ABSMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI3Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR4Mutator]MSP[N]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[InlineConstantMutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR1Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.ABSMutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR1Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI2Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[N]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR3Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR5Mutator]MSP[S] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI2Mutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[experimental.MemberVariableMutator]MSP[N] }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[PrimitiveReturnsMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; MST[experimental.MemberVariableMutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR4Mutator]MSP[N] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI4Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR2Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI3Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR1Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOD2Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR1Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR5Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[S] } } public final int end () {
} totalLen += length ; MST[rv.UOI1Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR4Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI1Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI4Mutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[experimental.MemberVariableMutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.ABSMutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR4Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR3Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.ABSMutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI1Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI3Mutator]MSP[N] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[NonVoidMethodCallMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI1Mutator]MSP[S] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.ABSMutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[MathMutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[VoidMethodCallMutator]MSP[S] } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOD1Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] return;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[S] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI4Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR4Mutator]MSP[S]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI2Mutator]MSP[N] return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[experimental.MemberVariableMutator]MSP[S] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI2Mutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI1Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[MathMutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI3Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR3Mutator]MSP[N] } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[MathMutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR3Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[ArgumentPropagationMutator]MSP[N] hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR2Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR3Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOD2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; MST[rv.UOI3Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI4Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI3Mutator]MSP[N] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.ABSMutator]MSP[S] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI3Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOD2Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI1Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD1Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.ABSMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[experimental.MemberVariableMutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[MathMutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.ABSMutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI4Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 2 :
} totalLen += length ; MST[rv.UOI2Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOD2Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI1Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[NegateConditionalsMutator]MSP[S] return;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR2Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI4Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI3Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR1Mutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI3Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.ABSMutator]MSP[N] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR2Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR1Mutator]MSP[S] return;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR3Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ABSMutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[MathMutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR6Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[ArgumentPropagationMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[InlineConstantMutator]MSP[S] k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI4Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[ArgumentPropagationMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI4Mutator]MSP[S]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOD1Mutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.ABSMutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI3Mutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; MST[rv.CRCR2Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[InlineConstantMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI4Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[MathMutator]MSP[S] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR4Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; MST[rv.ABSMutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI2Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI4Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.AOD1Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[NonVoidMethodCallMutator]MSP[N] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR2Mutator]MSP[N]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI1Mutator]MSP[N]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR2Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR4Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.ABSMutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI1Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI1Mutator]MSP[N] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR1Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR2Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR6Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI1Mutator]MSP[S] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR6Mutator]MSP[N] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI3Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; MST[rv.UOI4Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOD1Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
} totalLen += length ; MST[rv.AOR3Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI2Mutator]MSP[N] } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR3Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR4Mutator]MSP[N] break; case 2 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI2Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI1Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR5Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR3Mutator]MSP[S]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI3Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI3Mutator]MSP[S] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR1Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[MathMutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[InlineConstantMutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR1Mutator]MSP[S] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.UOI1Mutator]MSP[N] hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[MathMutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.ABSMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_0]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_2]MSP[S]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[experimental.RemoveSwitchMutator_1]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[InlineConstantMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI3Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[InlineConstantMutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[S] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 2 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR5Mutator]MSP[S] switch ( unprocessedLength ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR4Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[S] }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR6Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[ArgumentPropagationMutator]MSP[N] }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR2Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[S] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOD2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN2Mutator]MSP[N] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR5Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI4Mutator]MSP[S] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI3Mutator]MSP[S] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI4Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR1Mutator]MSP[N] } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR3Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR5Mutator]MSP[S] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ABSMutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR1Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[S] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR5Mutator]MSP[N] } } public final int end () {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI3Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR1Mutator]MSP[N]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[MathMutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR4Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR6Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[InlineConstantMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.UOI2Mutator]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR3Mutator]MSP[N] switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI2Mutator]MSP[N]
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI3Mutator]MSP[S] newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[PrimitiveReturnsMutator]MSP[N] }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI4Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR3Mutator]MSP[N]
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR2Mutator]MSP[S]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI4Mutator]MSP[S]
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI2Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.ABSMutator]MSP[S] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI3Mutator]MSP[S] } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[N] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR2Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[InlineConstantMutator]MSP[S]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI2Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR6Mutator]MSP[S] switch ( unprocessedLength ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.UOI1Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI3Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[MathMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI2Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR4Mutator]MSP[S] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI4Mutator]MSP[N] return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI2Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN2Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI1Mutator]MSP[N] }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.ABSMutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR1Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.ABSMutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.ABSMutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] return;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[experimental.MemberVariableMutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR4Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOD1Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI3Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[ArgumentPropagationMutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[InlineConstantMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[MathMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI1Mutator]MSP[N] } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; MST[rv.CRCR6Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOD1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI3Mutator]MSP[N] return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.UOI2Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.ABSMutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.ABSMutator]MSP[N] } @Override @Deprecated
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI3Mutator]MSP[N] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR1Mutator]MSP[N] break; case 3 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[N] } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR4Mutator]MSP[N] } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI2Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[InlineConstantMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[InlineConstantMutator]MSP[N] } } public final int end () {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOD2Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[MathMutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI4Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; MST[rv.UOI3Mutator]MSP[N] } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[InlineConstantMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR1Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOD1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI4Mutator]MSP[N] }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[InlineConstantMutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ROR5Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR6Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[InlineConstantMutator]MSP[S] k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI1Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR2Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[experimental.MemberVariableMutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N] }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR6Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.ABSMutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN1Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR3Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR4Mutator]MSP[N] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN2Mutator]MSP[S] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.UOI2Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.OBBN1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI4Mutator]MSP[S] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; MST[rv.AOR1Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR6Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI1Mutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR6Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI4Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD2Mutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR3Mutator]MSP[N] break; case 3 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[NonVoidMethodCallMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI3Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.UOI4Mutator]MSP[N] hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 3 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ABSMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI1Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[experimental.MemberVariableMutator]MSP[S] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI3Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR6Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[ReturnValsMutator]MSP[N] } @Override @Deprecated
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; MST[rv.ABSMutator]MSP[N] hash = mix32 ( k , hash ) ; }
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR5Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.ABSMutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[MathMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
int k = - 1 ; MST[rv.CRCR5Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[rv.ROR1Mutator]MSP[N]
int k = - 1 ; MST[rv.CRCR1Mutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.ABSMutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI4Mutator]MSP[S] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOD2Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.ABSMutator]MSP[N] return fmix32 ( result ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI2Mutator]MSP[N] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI4Mutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.CRCR3Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR5Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.CRCR1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI2Mutator]MSP[S] k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.CRCR3Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.CRCR3Mutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 3 :
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[MathMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.UOI1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI3Mutator]MSP[S] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOR4Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI2Mutator]MSP[N] return fmix32 ( result ) ; }
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.ABSMutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI3Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR3Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = ( nblocks << 2 ) ; MST[rv.UOI1Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 3 :
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[ReturnValsMutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.ABSMutator]MSP[N] k1 *= C1_32 ;
} totalLen += length ; MST[MathMutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOD1Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI2Mutator]MSP[N] break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.UOI1Mutator]MSP[N] } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; MST[rv.CRCR5Mutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[MathMutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.ABSMutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI4Mutator]MSP[S] } } public final int end () {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR3Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ABSMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.UOI2Mutator]MSP[N] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI1Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[MathMutator]MSP[N]
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI1Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR5Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI2Mutator]MSP[N] }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) { MST[NegateConditionalsMutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR5Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.ABSMutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI3Mutator]MSP[N] break; case 2 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; MST[rv.ABSMutator]MSP[N] } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR5Mutator]MSP[S] k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.AOR2Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI3Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { MST[rv.ABSMutator]MSP[S]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR4Mutator]MSP[N]
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI1Mutator]MSP[N] } } public final int end () {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI3Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; MST[rv.CRCR1Mutator]MSP[S] switch ( unprocessedLength ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; MST[rv.AOD2Mutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[IncrementsMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI2Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI1Mutator]MSP[N]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI4Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR3Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR4Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.CRCR2Mutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR5Mutator]MSP[S]
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.ABSMutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.UOI1Mutator]MSP[N] return;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; MST[rv.UOI1Mutator]MSP[N] return fmix32 ( result ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { MST[rv.UOI3Mutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOR3Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.ABSMutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN1Mutator]MSP[N] k1 *= C1_32 ;
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 3 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.OBBN3Mutator]MSP[S] k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOD1Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { MST[experimental.SwitchMutator]MSP[N] case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR4Mutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR6Mutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[MathMutator]MSP[N] } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI2Mutator]MSP[N] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOR3Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 3 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.CRCR3Mutator]MSP[S]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.UOI2Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR6Mutator]MSP[N] } @Override @Deprecated
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.UOI3Mutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { MST[rv.ROR2Mutator]MSP[S] return;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; MST[rv.ABSMutator]MSP[S] k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[InlineConstantMutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override @Deprecated
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override @Deprecated
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.UOI1Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.UOI3Mutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[MathMutator]MSP[S] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI2Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.UOI4Mutator]MSP[S] k1 *= C1_32 ;
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.UOI1Mutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; MST[rv.AOR2Mutator]MSP[N] } } public final int end () {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; MST[InlineConstantMutator]MSP[N] switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break; case 2 :
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.AOR2Mutator]MSP[S]
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[MathMutator]MSP[N] } @Override @Deprecated
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { MST[NegateConditionalsMutator]MSP[N] System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI2Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; MST[rv.UOI4Mutator]MSP[N] } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ; MST[rv.UOI3Mutator]MSP[N]
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.CRCR2Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; MST[rv.UOI4Mutator]MSP[N] unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.ABSMutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.CRCR6Mutator]MSP[N]
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI1Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; MST[rv.AOR1Mutator]MSP[N] return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.UOI2Mutator]MSP[S] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; MST[rv.UOI3Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI4Mutator]MSP[N] break; case 2 :
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.UOI4Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.UOI2Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; MST[rv.AOD2Mutator]MSP[N] newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR3Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , unprocessed [ 2 ] , data [ offset ] ) ; MST[rv.UOI4Mutator]MSP[S] break; default: throw new IllegalStateException ( lr_1 + unprocessedLength ) ; } hash = mix32 ( k , hash ) ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.CRCR4Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
return finalise ( hash , unprocessedLength , unprocessed , totalLen ) ; } int finalise ( final int hash , final int unprocessedLength , final byte [] unprocessed , final int totalLen ) { int result = hash ; MST[rv.UOI3Mutator]MSP[N] int k1 = 0 ; switch ( unprocessedLength ) {
} totalLen += length ; MST[rv.AOR4Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; MST[rv.ABSMutator]MSP[S] } result ^= totalLen ; return fmix32 ( result ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; MST[rv.AOR1Mutator]MSP[S] result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.UOI3Mutator]MSP[N] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ; MST[rv.UOI3Mutator]MSP[S]
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; MST[rv.UOI4Mutator]MSP[N] }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[MathMutator]MSP[N] break; case 2 :
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.CRCR3Mutator]MSP[N] break; case 2 :
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.AOR1Mutator]MSP[N] break; case 3 :
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.ABSMutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[InlineConstantMutator]MSP[N] break; case 2 :
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.UOI1Mutator]MSP[N] break; case 2 :
} totalLen += length ; MST[rv.UOI4Mutator]MSP[S] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] k1 *= C1_32 ;
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; MST[rv.OBBN3Mutator]MSP[N] case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[rv.UOI2Mutator]MSP[N] }
public final void start ( final int seed ) { unprocessedLength = totalLen = 0 ; MST[rv.CRCR5Mutator]MSP[N] this . hash = seed ; } public final void add ( final byte [] data , final int offset , final int length ) { if ( length <= 0 ) { return;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ; MST[rv.UOI4Mutator]MSP[S]
final int consumed = ( nblocks << 2 ) ; MST[MathMutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
final int consumed = ( nblocks << 2 ) ; MST[InlineConstantMutator]MSP[N] unprocessedLength = newLength - consumed ; if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
k = orBytes ( unprocessed [ 0 ] , unprocessed [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; MST[rv.CRCR2Mutator]MSP[N] break; case 3 :
} totalLen += length ; MST[rv.ABSMutator]MSP[N] if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
for ( int i = 0 ; i < nblocks ; i ++ ) { final int index = newOffset + ( i << 2 ) ; MST[rv.AOD1Mutator]MSP[N] final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
int k = - 1 ; switch ( unprocessedLength ) { case 1 : k = orBytes ( unprocessed [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; MST[rv.AOR2Mutator]MSP[N] break; case 2 :
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.UOI4Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN2Mutator]MSP[N] } @Override @Deprecated
case 3 : k1 ^= ( unprocessed [ 2 ] & 0xff ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] case 2 : k1 ^= ( unprocessed [ 1 ] & 0xff ) << 8 ; case 1 : k1 ^= ( unprocessed [ 0 ] & 0xff ) ; k1 *= C1_32 ;
} totalLen += length ; if ( unprocessedLength + length - BLOCK_SIZE < 0 ) { MST[rv.ROR4Mutator]MSP[N] System . arraycopy ( data , offset , unprocessed , unprocessedLength , length ) ; unprocessedLength += length ; return; } int newOffset ; int newLength ; if ( unprocessedLength > 0 ) {
return ( b1 & 0xff ) | ( ( b2 & 0xff ) << 8 ) | ( ( b3 & 0xff ) << 16 ) | ( ( b4 & 0xff ) << 24 ) ; MST[rv.OBBN3Mutator]MSP[N] } @Override @Deprecated
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; } else { newOffset = offset ; MST[rv.UOI1Mutator]MSP[N] newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; newLength = length - consumed ; MST[rv.AOR3Mutator]MSP[S] } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
for ( int i = 0 ; i < nblocks ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final int index = newOffset + ( i << 2 ) ; final int k = getLittleEndianInt ( data , index ) ; hash = mix32 ( k , hash ) ; }
k1 = Integer . rotateLeft ( k1 , R1_32 ) ; k1 *= C2_32 ; result ^= k1 ; } result ^= totalLen ; return fmix32 ( result ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final int consumed = BLOCK_SIZE - unprocessedLength ; newOffset = offset + consumed ; MST[rv.AOR1Mutator]MSP[N] newLength = length - consumed ; } else { newOffset = offset ; newLength = length ; } final int nblocks = newLength >> 2 ;
final int consumed = ( nblocks << 2 ) ; unprocessedLength = newLength - consumed ; MST[rv.AOD1Mutator]MSP[N] if ( unprocessedLength != 0 ) { System . arraycopy ( data , newOffset + consumed , unprocessed , 0 , unprocessedLength ) ; } } public final int end () {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; final char [] chars = str . toCharArray () ; final int len = chars . length ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR3Mutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.UOI2Mutator]MSP[N] if ( next == 'N' ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR4Mutator]MSP[S] return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR2Mutator]MSP[N] return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[NegateConditionalsMutator]MSP[N]
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; final char [] chars = str . toCharArray () ; MST[NonVoidMethodCallMutator]MSP[N] final int len = chars . length ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.ROR5Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
} return new char [] { curr } ; MST[rv.CRCR4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[InlineConstantMutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; MST[rv.ABSMutator]MSP[N] } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.ROR4Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR5Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR2Mutator]MSP[S] }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ABSMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'Q' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR2Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR3Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_FF ; }
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; MST[ArgumentPropagationMutator]MSP[N] str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[InlineConstantMutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI3Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[InlineConstantMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR5Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR3Mutator]MSP[N] return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR6Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ROR1Mutator]MSP[N]
} return new char [] { curr } ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ABSMutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR3Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.CRCR6Mutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI2Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
} return new char [] { curr } ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI1Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[experimental.NakedReceiverMutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.CRCR5Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.CRCR6Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[NegateConditionalsMutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.CRCR3Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.UOI4Mutator]MSP[N]
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[NonVoidMethodCallMutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI3Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; MST[ReturnValsMutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR4Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
} return new char [] { curr } ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.ROR1Mutator]MSP[N] if ( next == 'N' ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR3Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR5Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR1Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[MathMutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.AOR1Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ROR2Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[InlineConstantMutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR4Mutator]MSP[N] }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR5Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR3Mutator]MSP[N] }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR1Mutator]MSP[N] }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI3Mutator]MSP[N] }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[rv.ROR5Mutator]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI4Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ROR3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI4Mutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR5Mutator]MSP[N] return new char [] { prev } ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; MST[ReturnValsMutator]MSP[S] } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[NullReturnValsMutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_A ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[InlineConstantMutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.ROR1Mutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.ROR2Mutator]MSP[N]
if ( key . length () > 1 ) { MST[InlineConstantMutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.AOD2Mutator]MSP[S]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR4Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; MST[NullReturnValsMutator]MSP[N] } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[NonVoidMethodCallMutator]MSP[N] return CHARS_A ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[NegateConditionalsMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR5Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR6Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[NegateConditionalsMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI2Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.CRCR4Mutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( curr == 'Q' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.ROR1Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI3Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.CRCR6Mutator]MSP[N] if ( next == 'N' ) {
if ( key . length () > 1 ) { MST[rv.ROR3Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.CRCR2Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR1Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.CRCR2Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI4Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR2Mutator]MSP[S] return CHARS_FF ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.CRCR2Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.CRCR4Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.UOI4Mutator]MSP[N] if ( next == 'N' ) {
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ABSMutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[MathMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI3Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.CRCR2Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
} return new char [] { curr } ; MST[rv.CRCR2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'Q' ) { MST[rv.CRCR1Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[InlineConstantMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.ROR2Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[NegateConditionalsMutator]MSP[N] return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.AOD2Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( key . length () > 1 ) { MST[NegateConditionalsMutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI1Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI2Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.CRCR2Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR4Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ABSMutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR2Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR4Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR5Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.ABSMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR2Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; MST[NullReturnValsMutator]MSP[N] } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.ABSMutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR5Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; }
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI1Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI4Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR1Mutator]MSP[S] return CHARS_FF ; }
} return new char [] { curr } ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOD2Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR4Mutator]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.UOI1Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.CRCR2Mutator]MSP[N] return new char [] { prev } ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR4Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_A ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[NegateConditionalsMutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_FF ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR5Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR5Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.ABSMutator]MSP[S]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.UOI1Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.CRCR1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI4Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR4Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI2Mutator]MSP[N] return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[MathMutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR1Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return CHARS_NN ; } return CHARS_C ; MST[NullReturnValsMutator]MSP[N] } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ABSMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[InlineConstantMutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[NegateConditionalsMutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR6Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI3Mutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.CRCR2Mutator]MSP[S]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.AOD2Mutator]MSP[N]
if ( key . length () > 1 ) { MST[rv.ROR4Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[InlineConstantMutator]MSP[N] return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.CRCR1Mutator]MSP[N] if ( next == 'N' ) {
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[InlineConstantMutator]MSP[N] }
if ( curr == 'Q' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } }
} return new char [] { curr } ; MST[InlineConstantMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI1Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.ABSMutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR6Mutator]MSP[S] return CHARS_FF ; }
lastChar = key . charAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[ReturnValsMutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[InlineConstantMutator]MSP[S] return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ABSMutator]MSP[N] return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.UOI2Mutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] key . append ( chars [ i ] ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI3Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
} return new char [] { curr } ; MST[NullReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ROR3Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
} return new char [] { curr } ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; MST[ArgumentPropagationMutator]MSP[N] } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI4Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ROR4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR4Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR4Mutator]MSP[N] return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.CRCR3Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.CRCR6Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI1Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOD2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.AOD2Mutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[NonVoidMethodCallMutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[InlineConstantMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ABSMutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR6Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR1Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.CRCR6Mutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.CRCR3Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR1Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; MST[ReturnValsMutator]MSP[N] } if ( isVowel ( curr ) ) { return CHARS_A ; }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.ROR3Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.CRCR6Mutator]MSP[S]
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.ROR2Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.CRCR6Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI4Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR6Mutator]MSP[N] }
if ( curr == 'Q' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.AOR4Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI3Mutator]MSP[N] return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.ROR2Mutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ROR4Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[MathMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[BooleanTrueReturnValsMutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ABSMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[MathMutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR2Mutator]MSP[S] }
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[N] }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.ROR4Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR1Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR2Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR4Mutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ABSMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.CRCR3Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR3Mutator]MSP[S] }
if ( key . length () > 1 ) { MST[NonVoidMethodCallMutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; MST[ArgumentPropagationMutator]MSP[N] str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.CRCR4Mutator]MSP[N] if ( next == 'N' ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[InlineConstantMutator]MSP[S]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_FF ; }
lastChar = key . charAt ( key . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.ROR3Mutator]MSP[N] if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.CRCR4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[MathMutator]MSP[N]
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[NonVoidMethodCallMutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final StringBuilder key = new StringBuilder ( str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] key . append ( str . charAt ( 0 ) ) ; final char [] chars = str . toCharArray () ; final int len = chars . length ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.AOR4Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.AOR2Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR1Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI1Mutator]MSP[N]
if ( key . length () > 1 ) { MST[rv.CRCR4Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.ABSMutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOD1Mutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[NegateConditionalsMutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
return this . nysiis ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR1Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_A ; }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; MST[EmptyObjectReturnValsMutator]MSP[N] } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[NegateConditionalsMutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[MathMutator]MSP[N] } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ABSMutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.ABSMutator]MSP[N] return CHARS_A ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[rv.ROR3Mutator]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR2Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR1Mutator]MSP[N] }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR5Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.AOR2Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI1Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI2Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ROR1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.CRCR6Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR3Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI2Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR3Mutator]MSP[S] return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR1Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ABSMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR3Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.CRCR5Mutator]MSP[S]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[NegateConditionalsMutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( str == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR5Mutator]MSP[N] }
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[MathMutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.CRCR5Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.CRCR2Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR5Mutator]MSP[S] return CHARS_FF ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.ROR5Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { MST[rv.CRCR4Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { MST[rv.CRCR3Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR2Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI1Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.UOI1Mutator]MSP[N] if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR1Mutator]MSP[N] return new char [] { prev } ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR2Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.CRCR3Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.CRCR5Mutator]MSP[N] return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[NegateConditionalsMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR3Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ABSMutator]MSP[S] return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR4Mutator]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[MathMutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI2Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_A ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI4Mutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR2Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR4Mutator]MSP[S] return CHARS_FF ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ROR5Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR2Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR5Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.AOR2Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.UOI4Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
} return new char [] { curr } ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI3Mutator]MSP[N] }
} return new char [] { curr } ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ABSMutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.AOR4Mutator]MSP[N]
return this . nysiis ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.UOI3Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.CRCR2Mutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
if ( key . length () > 1 ) { MST[rv.ROR1Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.CRCR3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.UOI3Mutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.CRCR2Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI2Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI4Mutator]MSP[N] return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR6Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR2Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR4Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR3Mutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[NegateConditionalsMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI4Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR6Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR2Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI1Mutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.UOI4Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.CRCR3Mutator]MSP[N] if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
if ( key . length () > 1 ) { MST[rv.ROR2Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.ROR5Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOD1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.CRCR5Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[ConditionalsBoundaryMutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR4Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; MST[NullReturnValsMutator]MSP[N] } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI3Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR2Mutator]MSP[N] return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.ROR1Mutator]MSP[S]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR3Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.CRCR4Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR5Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.AOR2Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[NonVoidMethodCallMutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR2Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR1Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR3Mutator]MSP[N] }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[rv.ROR4Mutator]MSP[S] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.ABSMutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI4Mutator]MSP[S] return CHARS_FF ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR4Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_FF ; }
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR5Mutator]MSP[N] return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[InlineConstantMutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI4Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR1Mutator]MSP[S] return CHARS_FF ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.CRCR1Mutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.CRCR1Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.ROR1Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.CRCR3Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[InlineConstantMutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.UOI3Mutator]MSP[N] if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI2Mutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[NegateConditionalsMutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[MathMutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[NegateConditionalsMutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR6Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.UOI2Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[NegateConditionalsMutator]MSP[N] }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; MST[BooleanFalseReturnValsMutator]MSP[N] } public String nysiis ( String str ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.CRCR1Mutator]MSP[N] return new char [] { prev } ;
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.CRCR3Mutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; MST[ArgumentPropagationMutator]MSP[N] if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.CRCR1Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[ReturnValsMutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR1Mutator]MSP[S] throw new EncoderException ( lr_1 ) ; }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[InlineConstantMutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI3Mutator]MSP[N]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[NonVoidMethodCallMutator]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; MST[ArgumentPropagationMutator]MSP[N] str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ;
} return new char [] { curr } ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
if ( curr == 'Q' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ABSMutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_A ; }
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new EncoderException ( lr_1 ) ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.UOI4Mutator]MSP[S]
for ( int i = 1 ; i < len ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[InlineConstantMutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR3Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ROR1Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR2Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ABSMutator]MSP[N] }
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ; MST[ArgumentPropagationMutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI2Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI1Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR6Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR5Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI3Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ROR2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR2Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.ABSMutator]MSP[N]
if ( str == null ) { return null ; MST[ReturnValsMutator]MSP[S] } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( key . length () > 1 ) { MST[rv.CRCR2Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[InlineConstantMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI1Mutator]MSP[N] return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR4Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( next == 'N' ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR4Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[InlineConstantMutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR5Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ROR2Mutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR3Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_A ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[rv.ROR1Mutator]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[NegateConditionalsMutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ABSMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR5Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { MST[InlineConstantMutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR1Mutator]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI4Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI2Mutator]MSP[N] return new char [] { prev } ;
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR4Mutator]MSP[S] throw new EncoderException ( lr_1 ) ; }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.ROR5Mutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI2Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new char [] { prev } ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[NonVoidMethodCallMutator]MSP[N] return new char [] { prev } ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR6Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.ABSMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return CHARS_NN ; } return CHARS_C ; MST[ReturnValsMutator]MSP[N] } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[NegateConditionalsMutator]MSP[N] return new char [] { prev } ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.UOI2Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.UOI1Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI1Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI2Mutator]MSP[N] }
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR1Mutator]MSP[N] }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.CRCR1Mutator]MSP[S]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR2Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.ROR5Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
final StringBuilder key = new StringBuilder ( str . length () ) ; MST[ConstructorCallMutator]MSP[N] key . append ( str . charAt ( 0 ) ) ; final char [] chars = str . toCharArray () ; final int len = chars . length ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.UOI1Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[InlineConstantMutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; MST[ReturnValsMutator]MSP[N] } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.CRCR1Mutator]MSP[S]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.CRCR1Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ABSMutator]MSP[S] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR3Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI3Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.CRCR5Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.ROR3Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.UOI4Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_A ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[VoidMethodCallMutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI4Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR3Mutator]MSP[N] return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ABSMutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.ROR1Mutator]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.AOD1Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ABSMutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
for ( int i = 1 ; i < len ; i ++ ) { MST[IncrementsMutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.CRCR5Mutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
} return new char [] { curr } ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
return this . nysiis ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI2Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_A ; }
if ( key . length () > 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI3Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR1Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR2Mutator]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_FF ; }
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.ABSMutator]MSP[N] if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR4Mutator]MSP[N] return new char [] { prev } ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR1Mutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ABSMutator]MSP[N] key . append ( chars [ i ] ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR2Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR5Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.ROR3Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[NullReturnValsMutator]MSP[N]
str = PAT_SCH . matcher ( str ) . replaceFirst ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] str = PAT_EE_IE . matcher ( str ) . replaceFirst ( lr_7 ) ; str = PAT_DT_ETC . matcher ( str ) . replaceFirst ( lr_8 ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.UOI3Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[ReturnValsMutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.CRCR6Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR5Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR4Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR3Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; MST[ReturnValsMutator]MSP[N] } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.ROR2Mutator]MSP[N] if ( next == 'N' ) {
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.CRCR4Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.CRCR5Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.AOR3Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[InlineConstantMutator]MSP[S]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; MST[NullReturnValsMutator]MSP[S] } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( key . length () > 1 ) { MST[rv.CRCR3Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOD2Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[N] }
if ( key . length () > 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI2Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.UOI4Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR3Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR2Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.CRCR4Mutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.UOI2Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( key . length () > 1 ) { MST[ConditionalsBoundaryMutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.ROR1Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.CRCR6Mutator]MSP[S]
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.CRCR5Mutator]MSP[N] if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[MathMutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI4Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[InlineConstantMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI1Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ABSMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[rv.ROR3Mutator]MSP[N] throw new EncoderException ( lr_1 ) ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI3Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR5Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR2Mutator]MSP[S] return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR1Mutator]MSP[S] }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[ReturnValsMutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOD1Mutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.UOI3Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ABSMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[ConditionalsBoundaryMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ROR3Mutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ABSMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI4Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.ABSMutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR6Mutator]MSP[S] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI1Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.CRCR3Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOD1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.AOD1Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.ROR4Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.CRCR1Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ABSMutator]MSP[N] key . append ( chars [ i ] ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR6Mutator]MSP[S] return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR3Mutator]MSP[N]
if ( curr == 'Q' ) { MST[rv.CRCR5Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
lastChar = key . charAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; MST[BooleanTrueReturnValsMutator]MSP[N] } public String nysiis ( String str ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR3Mutator]MSP[S] return CHARS_FF ; }
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new EncoderException ( lr_1 ) ; }
} return new char [] { curr } ; MST[rv.CRCR3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
if ( curr == 'Q' ) { MST[rv.CRCR2Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[InlineConstantMutator]MSP[S] return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI3Mutator]MSP[N] }
if ( curr == 'Q' ) { MST[rv.ABSMutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.UOI4Mutator]MSP[N] }
} return new char [] { curr } ; MST[rv.CRCR6Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR4Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR4Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.CRCR5Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.CRCR1Mutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR5Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR1Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[NegateConditionalsMutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.CRCR3Mutator]MSP[N] return new char [] { prev } ;
} return new char [] { curr } ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.CRCR4Mutator]MSP[N]
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ; MST[ArgumentPropagationMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_A ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ABSMutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.AOR3Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.CRCR5Mutator]MSP[S] return CHARS_FF ; }
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; MST[ReturnValsMutator]MSP[N] } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.AOD1Mutator]MSP[N]
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; MST[NullReturnValsMutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[InlineConstantMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[InlineConstantMutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
for ( int i = 1 ; i < len ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.CRCR1Mutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ABSMutator]MSP[S] return CHARS_FF ; }
if ( key . length () > 1 ) { MST[rv.ROR5Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR5Mutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.CRCR2Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR1Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[InlineConstantMutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.CRCR6Mutator]MSP[N] return new char [] { prev } ;
lastChar = key . charAt ( key . length () - 1 ) ; MST[MathMutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[rv.ROR2Mutator]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.CRCR3Mutator]MSP[S]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR3Mutator]MSP[N] }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[InlineConstantMutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR1Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.ROR2Mutator]MSP[N] }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[InlineConstantMutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.CRCR1Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.CRCR2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.ABSMutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[rv.UOI2Mutator]MSP[N]
if ( key . length () > 1 ) { MST[rv.CRCR6Mutator]MSP[N] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI3Mutator]MSP[N] return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ABSMutator]MSP[N] return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.ROR5Mutator]MSP[N] if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
lastChar = key . charAt ( key . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[InlineConstantMutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR3Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR2Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.AOR3Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR5Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.ROR4Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
return this . nysiis ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; } public String nysiis ( String str ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N]
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR3Mutator]MSP[S] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI3Mutator]MSP[S] return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; MST[NullReturnValsMutator]MSP[N] } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.UOI3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.ROR5Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR4Mutator]MSP[S] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return CHARS_FF ; }
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.AOR1Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.ROR1Mutator]MSP[N] return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( curr == 'Q' ) { MST[InlineConstantMutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { MST[rv.ROR4Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR6Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.UOI1Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI2Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; MST[rv.CRCR5Mutator]MSP[N] if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR5Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.CRCR2Mutator]MSP[N] if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[NegateConditionalsMutator]MSP[N] }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[NegateConditionalsMutator]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.CRCR5Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ; MST[InlineConstantMutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; MST[ReturnValsMutator]MSP[N] } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[InlineConstantMutator]MSP[N]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.CRCR4Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI1Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI2Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR1Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI3Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR5Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.CRCR5Mutator]MSP[S] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR4Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR2Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.CRCR4Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.UOI1Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR2Mutator]MSP[N] }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.ROR4Mutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[InlineConstantMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR2Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return new char [] { prev } ;
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.CRCR4Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ROR1Mutator]MSP[S] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.ABSMutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[InlineConstantMutator]MSP[N] if ( next == 'N' ) {
return this . nysiis ( ( String ) obj ) ; } @Override public String encode ( final String str ) { return this . nysiis ( str ) ; } public boolean isStrict () { return this . strict ; MST[ReturnValsMutator]MSP[N] } public String nysiis ( String str ) {
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.UOI1Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; MST[NullReturnValsMutator]MSP[N] }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[rv.CRCR4Mutator]MSP[S] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_FF ; }
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.CRCR6Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'Q' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[InlineConstantMutator]MSP[N] key . append ( chars [ i ] ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOD2Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[ConditionalsBoundaryMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[S] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.UOI1Mutator]MSP[N] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[NegateConditionalsMutator]MSP[N] if ( next == 'N' ) {
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR4Mutator]MSP[N]
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.ROR5Mutator]MSP[N]
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.ROR3Mutator]MSP[N] final char last2Char = key . charAt ( key . length () - 2 ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.CRCR6Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI1Mutator]MSP[N]
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[NegateConditionalsMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI4Mutator]MSP[N] return new char [] { prev } ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR1Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.UOI3Mutator]MSP[S]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR5Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[rv.ROR5Mutator]MSP[N] return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.CRCR6Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[NegateConditionalsMutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.UOI4Mutator]MSP[N]
str = PAT_KN . matcher ( str ) . replaceFirst ( lr_3 ) ; str = PAT_K . matcher ( str ) . replaceFirst ( lr_4 ) ; str = PAT_PH_PF . matcher ( str ) . replaceFirst ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N]
return CHARS_NN ; MST[NullReturnValsMutator]MSP[N] } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( str == null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length () == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return str ; } str = PAT_MAC . matcher ( str ) . replaceFirst ( lr_2 ) ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.ROR3Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.AOD1Mutator]MSP[N]
if ( curr == 'Q' ) { MST[rv.UOI2Mutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR3Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.AOR3Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR1Mutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { MST[rv.ROR4Mutator]MSP[N] if ( next == 'N' ) {
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { final char last2Char = key . charAt ( key . length () - 2 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( key . length () > 1 ) { MST[rv.CRCR5Mutator]MSP[S] char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[InlineConstantMutator]MSP[N] }
return CHARS_NN ; MST[ReturnValsMutator]MSP[N] } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.CRCR5Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.UOI2Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[ArgumentPropagationMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[InlineConstantMutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.ROR3Mutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) { MST[rv.CRCR4Mutator]MSP[S]
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { key . deleteCharAt ( key . length () - 1 ) ; MST[InlineConstantMutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_FF ; }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { MST[rv.ABSMutator]MSP[N] return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[InlineConstantMutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] key . append ( chars [ i ] ) ; } }
final String string = key . toString () ; return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.UOI1Mutator]MSP[N] return new char [] { prev } ;
final String string = key . toString () ; MST[NonVoidMethodCallMutator]MSP[N] return this . isStrict () ? string . substring ( 0 , Math . min ( TRUE_LENGTH , string . length () ) ) : string ; }
final StringBuilder key = new StringBuilder ( str . length () ) ; key . append ( str . charAt ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] final char [] chars = str . toCharArray () ; final int len = chars . length ;
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { key . append ( chars [ i ] ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { MST[rv.UOI4Mutator]MSP[N] return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; }
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ; MST[rv.ABSMutator]MSP[N]
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR2Mutator]MSP[N]
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.AOR4Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
lastChar = key . charAt ( key . length () - 1 ) ; } if ( key . length () > 2 ) { MST[rv.ROR4Mutator]MSP[S] final char last2Char = key . charAt ( key . length () - 2 ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[InlineConstantMutator]MSP[S] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR4Mutator]MSP[N] }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR6Mutator]MSP[N] }
} return new char [] { curr } ; MST[rv.CRCR5Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
} return new char [] { curr } ; MST[rv.CRCR1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( lr_1 ) ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR2Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { MST[rv.ABSMutator]MSP[N] final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR2Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR4Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( last2Char == 'A' && lastChar == 'Y' ) { MST[rv.ROR3Mutator]MSP[N] key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
if ( curr == 'Q' ) { MST[NegateConditionalsMutator]MSP[N] return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI4Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { return CHARS_AF ; } if ( isVowel ( curr ) ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_A ; }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR6Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR1Mutator]MSP[N] }
private static char [] transcodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { if ( curr == 'E' && next == 'V' ) { MST[rv.CRCR3Mutator]MSP[S] return CHARS_AF ; } if ( isVowel ( curr ) ) { return CHARS_A ; }
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.UOI3Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { MST[rv.CRCR4Mutator]MSP[N] return new char [] { prev } ;
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { return CHARS_N ; MST[ReturnValsMutator]MSP[N] } if ( curr == 'K' ) { if ( next == 'N' ) {
final char aNext = i < len - 2 ? chars [ i + 2 ] : SPACE ; MST[rv.AOR1Mutator]MSP[N] final char [] transcoded = transcodeRemaining ( chars [ i - 1 ] , chars [ i ] , next , aNext ) ;
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; MST[rv.AOR1Mutator]MSP[N] } } if ( lastChar == 'A' ) { key . deleteCharAt ( key . length () - 1 ) ; } }
private static boolean isVowel ( final char c ) { return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.UOI3Mutator]MSP[N]
return CHARS_NN ; } return CHARS_C ; } if ( curr == 'S' && next == 'C' && aNext == 'H' ) { return CHARS_SSS ; } if ( curr == 'P' && next == 'H' ) { return CHARS_FF ; MST[ReturnValsMutator]MSP[N] }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.CRCR4Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
System . arraycopy ( transcoded , 0 , chars , i , transcoded . length ) ; if ( chars [ i ] != chars [ i - 1 ] ) { MST[rv.UOI2Mutator]MSP[N] key . append ( chars [ i ] ) ; } }
if ( curr == 'Q' ) { return CHARS_G ; } else if ( curr == 'Z' ) { return CHARS_S ; } else if ( curr == 'M' ) { MST[rv.ROR2Mutator]MSP[N] return CHARS_N ; } if ( curr == 'K' ) { if ( next == 'N' ) {
if ( key . length () > 1 ) { char lastChar = key . charAt ( key . length () - 1 ) ; if ( lastChar == 'S' ) { MST[rv.ROR2Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ;
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR1Mutator]MSP[N]
if ( last2Char == 'A' && lastChar == 'Y' ) { key . deleteCharAt ( key . length () - 2 ) ; } } if ( lastChar == 'A' ) { MST[rv.CRCR6Mutator]MSP[N] key . deleteCharAt ( key . length () - 1 ) ; } }
} return new char [] { curr } ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { MST[NegateConditionalsMutator]MSP[N] throw new EncoderException ( lr_1 ) ; }
for ( int i = 1 ; i < len ; i ++ ) { final char next = i < len - 1 ? chars [ i + 1 ] : SPACE ; MST[rv.AOR4Mutator]MSP[N]
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { MST[rv.ROR5Mutator]MSP[N] return new char [] { prev } ; } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
if ( curr == 'H' && ( ! isVowel ( prev ) || ! isVowel ( next ) ) ) { return new char [] { prev } ; MST[rv.UOI3Mutator]MSP[N] } if ( curr == 'W' && isVowel ( prev ) ) { return new char [] { prev } ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI2Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N]
return buffer . array () ; MST[ReturnValsMutator]MSP[N] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR4Mutator]MSP[N] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[ConstructorCallMutator]MSP[S] } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[InlineConstantMutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI1Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[S] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[NegateConditionalsMutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.ABSMutator]MSP[N] } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[N] return encode ( ( byte [] ) obj ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[InlineConstantMutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR5Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ABSMutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } return byteCount ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[InlineConstantMutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N] } return byteCount ; }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI3Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR4Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR2Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOD2Mutator]MSP[N] }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR5Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR3Mutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI4Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI2Mutator]MSP[N] } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return buffer . array () ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI3Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return c >= 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[MathMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI2Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR2Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NegateConditionalsMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR2Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR5Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return c >= 0 ; MST[ReturnValsMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR5Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[InlineConstantMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ABSMutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[InlineConstantMutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[InlineConstantMutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[N] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[NegateConditionalsMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[MathMutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI4Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.ABSMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR1Mutator]MSP[N] } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR4Mutator]MSP[N] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR4Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.ABSMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[InlineConstantMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR5Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR1Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
} else if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR5Mutator]MSP[N] return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI2Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[MathMutator]MSP[N] }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI2Mutator]MSP[N]
return c >= 0 ; MST[rv.UOI2Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI1Mutator]MSP[N] } } } return buffer . array () ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR4Mutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR4Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI1Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR5Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI4Mutator]MSP[N] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; MST[rv.ABSMutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR2Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return buffer . array () ; MST[NullReturnValsMutator]MSP[N] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[NonVoidMethodCallMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI2Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR1Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI1Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ABSMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[S] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR2Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI4Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.ABSMutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR3Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else { if ( plusForSpace && b == '+' ) { MST[InlineConstantMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[IncrementsMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; MST[rv.ABSMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.ROR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI2Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR4Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI1Mutator]MSP[N] }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI4Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return c >= 0 ; MST[ConditionalsBoundaryMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[InlineConstantMutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI3Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR2Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR1Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.AOR1Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[rv.ROR5Mutator]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR4Mutator]MSP[N] } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR5Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ABSMutator]MSP[S] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI3Mutator]MSP[N]
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI2Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOD1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR4Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR1Mutator]MSP[N] }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return c >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI3Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[experimental.NakedReceiverMutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOD1Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[ArgumentPropagationMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR2Mutator]MSP[N] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[S] return encode ( ( byte [] ) obj ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[ReturnValsMutator]MSP[S]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR3Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR6Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR3Mutator]MSP[N] } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI2Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR2Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI1Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[VoidMethodCallMutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI4Mutator]MSP[N] }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.ABSMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR1Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; MST[rv.ROR1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[ReturnValsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return c >= 0 ; MST[InlineConstantMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI4Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[InlineConstantMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI1Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR2Mutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR4Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR1Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NonVoidMethodCallMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI1Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[N] } return byteCount ; }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOD2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI3Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR2Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI2Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR2Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.ABSMutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[N] } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR1Mutator]MSP[N] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR5Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
this . alwaysEncodeChars . set ( b ) ; MST[VoidMethodCallMutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR5Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR6Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return encode ( ( byte [] ) obj ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR1Mutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR6Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR4Mutator]MSP[N]
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[N] return null ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[NullReturnValsMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.ABSMutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI3Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR6Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[NegateConditionalsMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return c >= 0 ; MST[NegateConditionalsMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI3Mutator]MSP[N] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[PrimitiveReturnsMutator]MSP[N] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR4Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[NegateConditionalsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
} else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[IncrementsMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI2Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return c >= 0 ; MST[rv.CRCR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI4Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return c >= 0 ; MST[rv.ROR3Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NonVoidMethodCallMutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.ABSMutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR3Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR6Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return c >= 0 ; MST[InlineConstantMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR6Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR4Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR1Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[NonVoidMethodCallMutator]MSP[N] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
byteCount ++ ; } return byteCount ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[ConditionalsBoundaryMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[InlineConstantMutator]MSP[N] } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR1Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI4Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[ConditionalsBoundaryMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return buffer . array () ; MST[NonVoidMethodCallMutator]MSP[N] } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR5Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[InlineConstantMutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR1Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR3Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR1Mutator]MSP[S] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR4Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI1Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR1Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR5Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI4Mutator]MSP[N] } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR4Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI2Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI4Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR3Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI4Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } return buffer . array () ; }
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ABSMutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ABSMutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI1Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else if ( obj instanceof byte [] ) { MST[rv.ROR4Mutator]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[ReturnValsMutator]MSP[N] }
return c >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N]
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[InlineConstantMutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR6Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI1Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[ConditionalsBoundaryMutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.ABSMutator]MSP[N] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[S] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI2Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[NegateConditionalsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[experimental.MemberVariableMutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR1Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ReturnValsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR3Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI2Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[ConstructorCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N] } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[NonVoidMethodCallMutator]MSP[N] } } }
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[InlineConstantMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI2Mutator]MSP[N] } } } return buffer . array () ; }
return c >= 0 ; MST[rv.ROR4Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI4Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI3Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ABSMutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
byteCount ++ ; } return byteCount ; MST[ReturnValsMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI3Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.UOI3Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR3Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR4Mutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR1Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR1Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
byteCount ++ ; } return byteCount ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ABSMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR4Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR1Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR5Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR4Mutator]MSP[N] } return byteCount ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI4Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI4Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR3Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI2Mutator]MSP[N] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR6Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.ABSMutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[NonVoidMethodCallMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.ABSMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI1Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR3Mutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI4Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR1Mutator]MSP[S]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI2Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR5Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI1Mutator]MSP[N] } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; MST[rv.CRCR4Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[InlineConstantMutator]MSP[N] } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.UOI1Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOR2Mutator]MSP[N] } return byteCount ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ABSMutator]MSP[S] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR5Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI4Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ABSMutator]MSP[N]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI2Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
} else { if ( plusForSpace && b == '+' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR3Mutator]MSP[N] } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR6Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[N] return null ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI4Mutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR2Mutator]MSP[N] } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[NullReturnValsMutator]MSP[N] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[IncrementsMutator]MSP[N]
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[NegateConditionalsMutator]MSP[S] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI1Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[S]
buffer . put ( ( byte ) hex2 ) ; MST[rv.ABSMutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[NegateConditionalsMutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[ConstructorCallMutator]MSP[S] } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[InlineConstantMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[NegateConditionalsMutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI2Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR1Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; MST[ReturnValsMutator]MSP[N] } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR3Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR3Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.ABSMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR1Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR2Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return c >= 0 ; MST[rv.UOI3Mutator]MSP[S] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI3Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI1Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR5Mutator]MSP[S] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI2Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[NegateConditionalsMutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR4Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR2Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; MST[NullReturnValsMutator]MSP[N] } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ABSMutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI4Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[experimental.MemberVariableMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ABSMutator]MSP[N]
return c >= 0 ; MST[rv.CRCR1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.UOI3Mutator]MSP[N] }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[S] return encode ( ( byte [] ) obj ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR6Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[N] } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR5Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI4Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOR2Mutator]MSP[N] }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.UOI4Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.UOI1Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ABSMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR3Mutator]MSP[N]
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.UOI3Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ABSMutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return c >= 0 ; MST[rv.CRCR6Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR4Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ABSMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buffer . put ( ( byte ) hex2 ) ; MST[rv.UOI1Mutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[InlineConstantMutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR2Mutator]MSP[N]
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; MST[rv.CRCR2Mutator]MSP[N] buffer . put ( ( byte ) hex1 ) ;
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR6Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.CRCR5Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; MST[ConstructorCallMutator]MSP[S] }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N]
return c >= 0 ; MST[rv.UOI4Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; MST[rv.CRCR2Mutator]MSP[N] } else { buffer . put ( b ) ; } } }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[MathMutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI2Mutator]MSP[N]
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ABSMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR5Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return c >= 0 ; MST[rv.ROR2Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
byteCount ++ ; } return byteCount ; MST[rv.ABSMutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
buffer . put ( ( byte ) hex2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI1Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR2Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[InlineConstantMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[NegateConditionalsMutator]MSP[N] } return byteCount ; }
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.ABSMutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
buffer . put ( ( byte ) hex2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[InlineConstantMutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI4Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[ReturnValsMutator]MSP[N] }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.UOI1Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.CRCR5Mutator]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.UOI2Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.ROR4Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.ROR3Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N] } return byteCount ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR6Mutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { MST[NegateConditionalsMutator]MSP[N] for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR3Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI4Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.CRCR3Mutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
byteCount ++ ; MST[IncrementsMutator]MSP[N] } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ABSMutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; MST[rv.CRCR5Mutator]MSP[S] } private void insertAlwaysEncodeChar ( final byte b ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR5Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI4Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI3Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[rv.UOI1Mutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; MST[ReturnValsMutator]MSP[N] } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.AOD1Mutator]MSP[N] }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR5Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[InlineConstantMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR6Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[MathMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; MST[rv.UOI1Mutator]MSP[N] buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR2Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI1Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR1Mutator]MSP[N]
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.UOI2Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.AOR2Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[S] } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } private boolean canEncode ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[MathMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else if ( obj instanceof byte [] ) { return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; MST[rv.CRCR2Mutator]MSP[N] }
} else { if ( plusForSpace && b == '+' ) { MST[rv.CRCR2Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI3Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.UOI3Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI4Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.AOD2Mutator]MSP[N] } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; MST[rv.UOI2Mutator]MSP[N] if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR1Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[rv.ROR5Mutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR3Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR6Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
} else { if ( plusForSpace && b == '+' ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[InlineConstantMutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { MST[rv.ROR2Mutator]MSP[N] bb = (byte) ( 256 + bb ) ; }
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; MST[rv.UOI3Mutator]MSP[N] } } }
return c >= 0 ; MST[rv.CRCR2Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { MST[rv.UOI1Mutator]MSP[N] final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; MST[rv.ABSMutator]MSP[N] final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[NegateConditionalsMutator]MSP[N] return encode ( ( byte [] ) obj ) ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[rv.CRCR5Mutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.UOI3Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return c >= 0 ; MST[rv.UOI1Mutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI3Mutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N] if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { MST[rv.ROR4Mutator]MSP[N] alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; MST[rv.CRCR3Mutator]MSP[N] } else { buffer . put ( b ) ; } } } return buffer . array () ; }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.ROR3Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[N]
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.ROR2Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.ABSMutator]MSP[S] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[rv.ROR3Mutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.UOI3Mutator]MSP[N] } return byteCount ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI1Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { MST[rv.ROR3Mutator]MSP[N] return encode ( ( byte [] ) obj ) ;
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[experimental.MemberVariableMutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ;
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
byteCount ++ ; } return byteCount ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.UOI3Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.UOI3Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[InlineConstantMutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.ROR2Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[NullReturnValsMutator]MSP[S]
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.ABSMutator]MSP[N]
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR1Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { MST[NegateConditionalsMutator]MSP[N] alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.ROR4Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
return c >= 0 ; } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR6Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[NegateConditionalsMutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; } private boolean canEncode ( final byte c ) {
return c >= 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public byte [] decode ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ;
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { MST[rv.UOI4Mutator]MSP[N] insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.ROR3Mutator]MSP[S]
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { MST[rv.CRCR5Mutator]MSP[N] try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.UOI3Mutator]MSP[N] }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.CRCR5Mutator]MSP[N] } return byteCount ; }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[InlineConstantMutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == ' ' ) { return true ; } } return false ; } private boolean canEncode ( final byte c ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) { MST[NegateConditionalsMutator]MSP[N]
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; MST[rv.ABSMutator]MSP[N] }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[InlineConstantMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; MST[rv.UOI1Mutator]MSP[N] } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
this . alwaysEncodeChars . set ( b ) ; MST[rv.UOI1Mutator]MSP[N] if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } private byte [] doEncode ( final byte [] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; MST[rv.UOI3Mutator]MSP[N]
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[S] } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
final char hex1 = Utils . hexDigit ( bb >> 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; MST[rv.ABSMutator]MSP[N]
for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( willEncode && canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
} else { if ( plusForSpace && b == '+' ) { MST[rv.ROR1Mutator]MSP[N] buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array () ; }
} else { throw new EncoderException ( lr_2 + obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ;
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { MST[rv.CRCR5Mutator]MSP[N] if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ;
byteCount ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ;
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N] i += b == ESCAPE_CHAR ? 3 : 1 ;
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; MST[rv.UOI1Mutator]MSP[N] } private boolean isAsciiChar ( final byte c ) {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; MST[rv.UOI4Mutator]MSP[N] } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
this . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; MST[rv.UOI3Mutator]MSP[N] } } @Override public byte [] encode ( final byte [] bytes ) throws EncoderException {
byteCount ++ ; } return byteCount ; } @Override public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof byte [] ) { return encode ( ( byte [] ) obj ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( final byte b : bytes ) { if ( willEncode && canEncode ( b ) ) { MST[rv.UOI1Mutator]MSP[N] byte bb = b ; if ( bb < 0 ) { bb = (byte) ( 256 + bb ) ; }
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; MST[rv.ROR5Mutator]MSP[N] } return byteCount ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ABSMutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[rv.UOI1Mutator]MSP[N]
private boolean containsSpace ( final byte [] bytes ) { for ( final byte b : bytes ) { if ( b == ' ' ) { MST[rv.ROR2Mutator]MSP[S] return true ; } } return false ; } private boolean canEncode ( final byte c ) {
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[rv.UOI2Mutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
if ( bytes == null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes != bytes . length ; MST[NegateConditionalsMutator]MSP[N] if ( willEncode || ( plusForSpace && containsSpace ( bytes ) ) ) {
return buffer . array () ; } private int expectedEncodingBytes ( final byte [] bytes ) { int byteCount = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final byte b : bytes ) { byteCount += canEncode ( b ) ? 3 : 1 ; } return byteCount ; }
} else if ( obj instanceof byte [] ) { MST[rv.ROR1Mutator]MSP[S] return decode ( ( byte [] ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } }
private void insertAlwaysEncodeChars ( final byte [] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray != null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; MST[VoidMethodCallMutator]MSP[N] } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } private void insertAlwaysEncodeChar ( final byte b ) {
final int l = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.ABSMutator]MSP[N] buffer . put ( (byte) ( ( u << 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( lr_1 , e ) ; }
return ! isAsciiChar ( c ) || ( inAlwaysEncodeCharsRange ( c ) && alwaysEncodeChars . get ( c ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax ; } private boolean isAsciiChar ( final byte c ) {
buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace && b == ' ' ) { MST[rv.CRCR1Mutator]MSP[N] buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } }
} else { if ( plusForSpace && b == '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; MST[rv.UOI4Mutator]MSP[N] } } } return buffer . array () ; }
for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; if ( b == ESCAPE_CHAR ) { try { final int u = Utils . digit16 ( bytes [ ++ i ] ) ; MST[rv.UOI1Mutator]MSP[N]
private int expectedDecodingBytes ( final byte [] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i += b == ESCAPE_CHAR ? 3 : 1 ; MST[InlineConstantMutator]MSP[N]
public static PhonemeBuilder empty ( final Languages . LanguageSet languages ) { return new PhonemeBuilder ( new Rule . Phoneme ( lr_1 , languages ) ) ; } public void append ( final CharSequence str ) { for ( final Rule . Phoneme ph : this . phonemes ) {
ph . append ( str ) ; } } public void apply ( final Rule . PhonemeExpr phonemeExpr , final int maxPhonemes ) { final Set < Rule . Phoneme > newPhonemes = new LinkedHashSet <> ( maxPhonemes ) ;
EXPR: for ( final Rule . Phoneme left : this . phonemes ) { for ( final Rule . Phoneme right : phonemeExpr . getPhonemes () ) { final LanguageSet languages = left . getLanguages () . restrictTo ( right . getLanguages () ) ;
if ( ! languages . isEmpty () ) { final Rule . Phoneme join = new Phoneme ( left , right , languages ) ; if ( newPhonemes . size () < maxPhonemes ) { newPhonemes . add ( join ) ;
if ( newPhonemes . size () >= maxPhonemes ) { break EXPR; } } } } } this . phonemes . clear () ; this . phonemes . addAll ( newPhonemes ) ; } public Set < Rule . Phoneme > getPhonemes () { return this . phonemes ; }
public String makeString () { final StringBuilder sb = new StringBuilder () ; for ( final Rule . Phoneme ph : this . phonemes ) { if ( sb . length () > 0 ) { sb . append ( lr_2 ) ; }
sb . append ( ph . getPhonemeText () ) ; } return sb . toString () ; } public int getI () { return this . i ; } public PhonemeBuilder getPhonemeBuilder () { return this . phonemeBuilder ; } public RulesApplication invoke () {
this . found = false ; int patternLength = 1 ; final List < Rule > rules = this . finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules != null ) {
for ( final Rule rule : rules ) { final String pattern = rule . getPattern () ; patternLength = pattern . length () ; if ( rule . patternAndContextMatches ( this . input , this . i ) ) {
this . phonemeBuilder . apply ( rule . getPhoneme () , maxPhonemes ) ; this . found = true ; break; } } } if ( ! this . found ) { patternLength = 1 ; } this . i += patternLength ; return this ; }
public boolean isFound () { return this . found ; } private static String join ( final Iterable < String > strings , final String sep ) { final StringBuilder sb = new StringBuilder () ; final Iterator < String > si = strings . iterator () ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { return phonemeBuilder ; }
final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap <> ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes () ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( this . nameType , RuleType . RULES , languageSet ) ;
final Map < String , List < Rule > > finalRules1 = Rule . getInstanceMap ( this . nameType , this . ruleType , lr_4 ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( final String word : words2 ) { result . append ( lr_14 ) . append ( encode ( word ) ) ; } return result . substring ( 1 ) ; } PhonemeBuilder phonemeBuilder = PhonemeBuilder . empty ( languageSet ) ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] return phonemeBuilder ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR4Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR2Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
input = join ( words2 , lr_10 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[S] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NegateConditionalsMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; MST[BooleanFalseReturnValsMutator]MSP[S] } public int getMaxPhonemes () { return this . maxPhonemes ; }
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR2Mutator]MSP[N]
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI2Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOD1Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR3Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; MST[NonVoidMethodCallMutator]MSP[N] } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[ConditionalsBoundaryMutator]MSP[N] final RulesApplication rulesApplication =
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[EmptyObjectReturnValsMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final RulesApplication rulesApplication =
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ABSMutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[PrimitiveReturnsMutator]MSP[S] }
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.SwitchMutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.ABSMutator]MSP[N] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR1Mutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR4Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR5Mutator]MSP[S] final String remainder = input . substring ( 2 ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[NullReturnValsMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; MST[NonVoidMethodCallMutator]MSP[N] break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
if ( input . startsWith ( l + lr_10 ) ) { MST[experimental.NakedReceiverMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( this . nameType == NameType . GENERIC ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR1Mutator]MSP[S] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) { MST[ArgumentPropagationMutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ConstructorCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI4Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return this . nameType ; MST[ReturnValsMutator]MSP[N] } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI2Mutator]MSP[N] }
if ( si . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[S] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI3Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; MST[ReturnValsMutator]MSP[N] }
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] return phonemeBuilder ; }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR5Mutator]MSP[N] final RulesApplication rulesApplication =
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; MST[NonVoidMethodCallMutator]MSP[N] return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
for ( int i = 0 ; i < input . length () ; ) { MST[InlineConstantMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR5Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return sb . toString () ; }
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; MST[ArgumentPropagationMutator]MSP[N] final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] if ( finalRules . isEmpty () ) { return phonemeBuilder ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[NonVoidMethodCallMutator]MSP[S]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[NegateConditionalsMutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI2Mutator]MSP[N] final RulesApplication rulesApplication =
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { return phonemeBuilder ; MST[NullReturnValsMutator]MSP[S] }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[NonVoidMethodCallMutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case ASHKENAZI : words2 . addAll ( words ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[InlineConstantMutator]MSP[S]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR5Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[MathMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
for ( int i = 0 ; i < input . length () ; ) { MST[NegateConditionalsMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR2Mutator]MSP[N]
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; MST[NonVoidMethodCallMutator]MSP[N] final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[NegateConditionalsMutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[ConstructorCallMutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR4Mutator]MSP[N]
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; MST[ArgumentPropagationMutator]MSP[N] } else { phonemes . put ( newPhoneme , newPhoneme ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ReturnValsMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( input . startsWith ( l + lr_10 ) ) { MST[experimental.NakedReceiverMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[NonVoidMethodCallMutator]MSP[S]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[ConditionalsBoundaryMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR3Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String combined = l + remainder ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR1Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR1Mutator]MSP[S] final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR1Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR4Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( si . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR5Mutator]MSP[N]
final String combined = lr_6 + remainder ; MST[experimental.NakedReceiverMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR3Mutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR3Mutator]MSP[N] final RulesApplication rulesApplication =
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI1Mutator]MSP[N]
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return phonemeBuilder ; }
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; MST[NonVoidMethodCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR2Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR5Mutator]MSP[N] final RulesApplication rulesApplication =
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR4Mutator]MSP[S] final String combined = l + remainder ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR1Mutator]MSP[N]
if ( si . hasNext () ) { MST[rv.ROR1Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR3Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] return phonemeBuilder ; }
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] return phonemeBuilder ; }
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI4Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[ArgumentPropagationMutator]MSP[S] break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR6Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; MST[ReturnValsMutator]MSP[N] } public Lang getLang () { return this . lang ; } public NameType getNameType () {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[NegateConditionalsMutator]MSP[N]
final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap <> ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes () ) { MST[NonVoidMethodCallMutator]MSP[N]
public boolean isFound () { return this . found ; } private static String join ( final Iterable < String > strings , final String sep ) { final StringBuilder sb = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] final Iterator < String > si = strings . iterator () ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; MST[NonVoidMethodCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; MST[NonVoidMethodCallMutator]MSP[N] return encode ( input , languageSet ) ; }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[NonVoidMethodCallMutator]MSP[N] final RulesApplication rulesApplication =
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR1Mutator]MSP[N] final RulesApplication rulesApplication =
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[ReturnValsMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
final String combined = lr_6 + remainder ; MST[experimental.NakedReceiverMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( final String word : words2 ) { result . append ( lr_14 ) . append ( encode ( word ) ) ; } return result . substring ( 1 ) ; } PhonemeBuilder phonemeBuilder = PhonemeBuilder . empty ( languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[S] final String combined = l + remainder ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; MST[NonVoidMethodCallMutator]MSP[N] subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR6Mutator]MSP[N] final RulesApplication rulesApplication =
if ( si . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR5Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[experimental.NakedReceiverMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR6Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; MST[NullReturnValsMutator]MSP[N] } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR6Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String combined = l + remainder ;
final String lastPart = parts [ parts . length - 1 ] ; MST[InlineConstantMutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[ReturnValsMutator]MSP[N] }
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( this . nameType , RuleType . RULES , languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[MathMutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ; MST[NonVoidMethodCallMutator]MSP[S]
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; MST[NonVoidMethodCallMutator]MSP[N] } else { final StringBuilder result = new StringBuilder () ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[ArgumentPropagationMutator]MSP[N] }
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR2Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR2Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR5Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NegateConditionalsMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR6Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { MST[rv.ROR5Mutator]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
return this . nameType ; MST[NullReturnValsMutator]MSP[N] } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
final Map < Rule . Phoneme , Rule . Phoneme > phonemes = MST[ConstructorCallMutator]MSP[N] new TreeMap <> ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes () ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[ReturnValsMutator]MSP[N] }
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR3Mutator]MSP[N]
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; MST[NonVoidMethodCallMutator]MSP[N] phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
final String combined = lr_6 + remainder ; MST[ConstructorCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; MST[ReturnValsMutator]MSP[N] } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; }
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR2Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[ConstructorCallMutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N] input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR4Mutator]MSP[S]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N]
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI4Mutator]MSP[N] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[NegateConditionalsMutator]MSP[N] final RulesApplication rulesApplication =
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI1Mutator]MSP[N] final RulesApplication rulesApplication =
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOD2Mutator]MSP[S] final String combined = l + remainder ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final RulesApplication rulesApplication =
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR4Mutator]MSP[N] final RulesApplication rulesApplication =
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.ABSMutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.ABSMutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[NegateConditionalsMutator]MSP[N] return phonemeBuilder ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR1Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI4Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[ConstructorCallMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ABSMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR6Mutator]MSP[N]
if ( si . hasNext () ) { MST[rv.ROR4Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[InlineConstantMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR4Mutator]MSP[N]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR2Mutator]MSP[N] final RulesApplication rulesApplication =
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR5Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR1Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[InlineConstantMutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[InlineConstantMutator]MSP[S] final String combined = l + remainder ;
final List < String > words2 = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] switch ( this . nameType ) { case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[EmptyObjectReturnValsMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; MST[ArgumentPropagationMutator]MSP[N] return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { MST[NonVoidMethodCallMutator]MSP[N] if ( phonemes . containsKey ( newPhoneme ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
for ( int i = 0 ; i < input . length () ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
for ( int i = 0 ; i < input . length () ; ) { MST[NonVoidMethodCallMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR2Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[NonVoidMethodCallMutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[ArgumentPropagationMutator]MSP[S] break; case ASHKENAZI : words2 . addAll ( words ) ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; MST[experimental.NakedReceiverMutator]MSP[N] i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR5Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR1Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR6Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR5Mutator]MSP[S]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ConstructorCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.ROR1Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR2Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR3Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR4Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR3Mutator]MSP[S] final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR3Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] return phonemeBuilder ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR4Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR5Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[NegateConditionalsMutator]MSP[N]
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR2Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { MST[NegateConditionalsMutator]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR3Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
final String combined = lr_6 + remainder ; MST[NonVoidMethodCallMutator]MSP[S] return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String combined = l + remainder ;
if ( this . nameType == NameType . GENERIC ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR2Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; MST[ConstructorCallMutator]MSP[N] } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] final String combined = l + remainder ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Lang getLang () { return this . lang ; } public NameType getNameType () {
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOD1Mutator]MSP[S] final String combined = l + remainder ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI3Mutator]MSP[N] }
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR4Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR1Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
input = join ( words2 , lr_10 ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( words2 . size () == 1 ) { input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI1Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
public boolean isFound () { return this . found ; } private static String join ( final Iterable < String > strings , final String sep ) { final StringBuilder sb = new StringBuilder () ; final Iterator < String > si = strings . iterator () ; MST[NonVoidMethodCallMutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ReturnValsMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[InlineConstantMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; MST[NonVoidMethodCallMutator]MSP[N] phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { return phonemeBuilder ; MST[ReturnValsMutator]MSP[S] }
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication =
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI4Mutator]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR2Mutator]MSP[N]
if ( si . hasNext () ) { MST[NegateConditionalsMutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N]
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR1Mutator]MSP[N]
if ( si . hasNext () ) { MST[rv.ROR3Mutator]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR3Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[NegateConditionalsMutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; MST[BooleanTrueReturnValsMutator]MSP[N] } public int getMaxPhonemes () { return this . maxPhonemes ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[MathMutator]MSP[S] final String combined = l + remainder ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ROR1Mutator]MSP[N] final RulesApplication rulesApplication =
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[NonVoidMethodCallMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[rv.ROR5Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[experimental.NakedReceiverMutator]MSP[S]
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[rv.UOI3Mutator]MSP[N]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOD2Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( si . hasNext () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final String remainder = input . substring ( 2 ) ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; MST[ReturnValsMutator]MSP[N] } public int getMaxPhonemes () { return this . maxPhonemes ; }
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { phonemes . put ( newPhoneme , newPhoneme ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 0 ; i < input . length () ; ) { MST[rv.CRCR6Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return phonemeBuilder ; }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[ConstructorCallMutator]MSP[S]
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.RemoveSwitchMutator_2]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.RemoveSwitchMutator_0]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[experimental.RemoveSwitchMutator_1]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
} } } return new PhonemeBuilder ( phonemes . keySet () ) ; } public String encode ( final String input ) { final Languages . LanguageSet languageSet = this . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.AOR2Mutator]MSP[S] final String combined = l + remainder ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR5Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI3Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case ASHKENAZI : words2 . addAll ( words ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; if ( finalRules . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] return phonemeBuilder ; }
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI2Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( input . startsWith ( l + lr_10 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[rv.CRCR3Mutator]MSP[N]
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[ArgumentPropagationMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! found ) {
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; MST[experimental.NakedReceiverMutator]MSP[N] phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR6Mutator]MSP[S]
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.AOR4Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[InlineConstantMutator]MSP[N] final RulesApplication rulesApplication =
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String combined = l + remainder ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI3Mutator]MSP[N] final RulesApplication rulesApplication =
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( int i = 0 ; i < input . length () ; ) { MST[rv.ROR5Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.ROR5Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
for ( int i = 0 ; i < input . length () ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
for ( int i = 0 ; i < input . length () ; ) { MST[ConditionalsBoundaryMutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.CRCR3Mutator]MSP[N] final RulesApplication rulesApplication =
final String lastPart = parts [ parts . length - 1 ] ; words2 . add ( lastPart ) ; MST[NonVoidMethodCallMutator]MSP[S] } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ; MST[experimental.NakedReceiverMutator]MSP[S]
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.ABSMutator]MSP[N] final RulesApplication rulesApplication =
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { MST[rv.ROR2Mutator]MSP[N] sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
if ( si . hasNext () ) { sb . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; } return sb . toString () ; }
final Map < String , List < Rule > > finalRules1 = Rule . getInstanceMap ( this . nameType , this . ruleType , lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[rv.CRCR4Mutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { final String remainder = input . substring ( 2 ) ; MST[rv.CRCR1Mutator]MSP[S]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String combined = l + remainder ;
if ( si . hasNext () ) { sb . append ( si . next () ) ; } while ( si . hasNext () ) { sb . append ( sep ) . append ( si . next () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return sb . toString () ; }
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) {
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { MST[rv.UOI4Mutator]MSP[N] final RulesApplication rulesApplication =
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI3Mutator]MSP[N]
if ( input . startsWith ( l + lr_10 ) ) { MST[rv.ROR3Mutator]MSP[N] final String remainder = input . substring ( l . length () + 1 ) ; final String combined = l + remainder ;
return this . nameType ; } public RuleType getRuleType () { return this . ruleType ; } public boolean isConcat () { return this . concat ; } public int getMaxPhonemes () { return this . maxPhonemes ; MST[rv.UOI1Mutator]MSP[N] }
final Map < String , List < Rule > > finalRules2 = Rule . getInstanceMap ( this . nameType , this . ruleType , languageSet ) ; input = input . toLowerCase ( Locale . ENGLISH ) . replace ( '-' , ' ' ) . trim () ; MST[InlineConstantMutator]MSP[N]
return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[experimental.NakedReceiverMutator]MSP[S] } } } final List < String > words = Arrays . asList ( input . split ( lr_11 ) ) ;
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( finalRules . isEmpty () ) { return phonemeBuilder ; }
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; MST[NonVoidMethodCallMutator]MSP[N] } public Lang getLang () { return this . lang ; } public NameType getNameType () {
for ( int i = 0 ; i < input . length () ; ) { MST[rv.UOI2Mutator]MSP[N] final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; MST[NonVoidMethodCallMutator]MSP[N] final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages () ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[InlineConstantMutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR3Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
phonemeBuilder = rulesApplication . getPhonemeBuilder () ; } phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules1 ) ; MST[ArgumentPropagationMutator]MSP[N] phonemeBuilder = applyFinalRules ( phonemeBuilder , finalRules2 ) ; return phonemeBuilder . makeString () ; } public Lang getLang () { return this . lang ; } public NameType getNameType () {
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.CRCR4Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
final String combined = lr_6 + remainder ; return lr_7 + encode ( remainder ) + lr_8 + encode ( combined ) + lr_9 ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final String l : NAME_PREFIXES . get ( this . nameType ) ) {
words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case GENERIC : words2 . addAll ( words ) ; break; default: throw new IllegalStateException ( lr_13 + this . nameType ) ; } if ( this . concat ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( input . startsWith ( l + lr_10 ) ) { final String remainder = input . substring ( l . length () + 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] final String combined = l + remainder ;
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; MST[NonVoidMethodCallMutator]MSP[N] i = rulesApplication . getI () ;
PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages () ) ; final String phonemeText = phoneme . getPhonemeText () . toString () ; for ( int i = 0 ; i < phonemeText . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI2Mutator]MSP[N]
if ( this . nameType == NameType . GENERIC ) { if ( input . length () >= 2 && input . substring ( 0 , 2 ) . equals ( lr_5 ) ) { MST[rv.ROR1Mutator]MSP[N] final String remainder = input . substring ( 2 ) ;
subBuilder . append ( phonemeText . subSequence ( i , i + 1 ) ) ; } i = rulesApplication . getI () ; } for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes () ) { if ( phonemes . containsKey ( newPhoneme ) ) { MST[rv.ROR3Mutator]MSP[N]
for ( int i = 0 ; i < input . length () ; ) { final RulesApplication rulesApplication = MST[rv.UOI1Mutator]MSP[N] new RulesApplication ( rules , input , phonemeBuilder , i , maxPhonemes ) . invoke () ; i = rulesApplication . getI () ;
final String lastPart = parts [ parts . length - 1 ] ; MST[rv.CRCR6Mutator]MSP[S] words2 . add ( lastPart ) ; } words2 . removeAll ( NAME_PREFIXES . get ( this . nameType ) ) ; break; case ASHKENAZI : words2 . addAll ( words ) ;
input = join ( words2 , lr_10 ) ; } else if ( words2 . size () == 1 ) { MST[NonVoidMethodCallMutator]MSP[N] input = words . iterator () . next () ; } else { final StringBuilder result = new StringBuilder () ;
new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke () ; final boolean found = rulesApplication . isFound () ; subBuilder = rulesApplication . getPhonemeBuilder () ; if ( ! found ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final List < String > words2 = new ArrayList <> () ; switch ( this . nameType ) { MST[rv.UOI1Mutator]MSP[N] case SEPHARDIC : for ( final String aWord : words ) { final String [] parts = aWord . split ( lr_12 ) ;
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
if ( sourceStr == null ) { return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
if ( str == null ) { return null ; } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.ABSMutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( sourceStr == null ) { return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; MST[ArgumentPropagationMutator]MSP[S] } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[S] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI4Mutator]MSP[N] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI2Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.ABSMutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR5Mutator]MSP[N] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR3Mutator]MSP[N] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.ABSMutator]MSP[N] } } } return data ; } @Override
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[S] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
@Override protected String getEncoding () { return lr_1 ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[S] } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[N] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
obj . getClass () . getName () + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + MST[NonVoidMethodCallMutator]MSP[S] obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.ROR1Mutator]MSP[N] hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.ROR3Mutator]MSP[N] hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.ROR5Mutator]MSP[N] hasUnderscores = true ; break;
} } if ( hasUnderscores ) { MST[rv.UOI4Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { MST[rv.UOI2Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 + MST[experimental.NakedReceiverMutator]MSP[N]
if ( sourceStr == null ) { return null ; MST[ReturnValsMutator]MSP[N] } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; MST[rv.CRCR5Mutator]MSP[N] break;
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[experimental.NakedReceiverMutator]MSP[N] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.CRCR2Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 + MST[NonVoidMethodCallMutator]MSP[S]
} } if ( hasUnderscores ) { MST[rv.ROR3Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { MST[rv.ROR5Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encode ( sourceStr , getCharset () ) ; MST[ReturnValsMutator]MSP[N] } @Override public String decode ( final String str ) throws DecoderException {
} } if ( hasUnderscores ) { MST[rv.ROR1Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; MST[NullReturnValsMutator]MSP[N] }
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[S] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR1Mutator]MSP[S]
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR3Mutator]MSP[N]
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR5Mutator]MSP[N]
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } else if ( obj instanceof String ) {
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N]
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encode ( sourceStr , getCharset () ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String decode ( final String str ) throws DecoderException {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final byte b = bytes [ i ] ;
if ( str == null ) { return null ; } try { return decodeText ( str ) ; MST[ReturnValsMutator]MSP[N] } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI4Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.CRCR4Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.CRCR6Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + MST[experimental.NakedReceiverMutator]MSP[N] obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N]
if ( b != UNDERSCORE ) { MST[rv.ROR4Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; MST[rv.CRCR3Mutator]MSP[N] break;
if ( str == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
if ( str == null ) { return null ; MST[ReturnValsMutator]MSP[N] } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; MST[rv.ABSMutator]MSP[N] }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[InlineConstantMutator]MSP[S] } } } return data ; } @Override
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } else if ( obj instanceof String ) {
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.ABSMutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[N] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.UOI2Mutator]MSP[N] } } } return data ; } @Override
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; MST[ArgumentPropagationMutator]MSP[N] } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[NegateConditionalsMutator]MSP[N] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; MST[ReturnValsMutator]MSP[N] } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ROR4Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ABSMutator]MSP[N] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[ConstructorCallMutator]MSP[S] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI4Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
} } if ( hasUnderscores ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { MST[InlineConstantMutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.CRCR5Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( b != UNDERSCORE ) { MST[rv.CRCR3Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; MST[experimental.MemberVariableMutator]MSP[N] }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.CRCR6Mutator]MSP[S] } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( sourceStr == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.CRCR2Mutator]MSP[S] } } } return data ; } @Override
if ( str == null ) { return null ; } try { return decodeText ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.CRCR2Mutator]MSP[S] hasUnderscores = true ; break;
} } if ( hasUnderscores ) { MST[rv.ABSMutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; MST[rv.UOI2Mutator]MSP[N] }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final byte b = bytes [ i ] ;
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] final byte b = bytes [ i ] ;
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR1Mutator]MSP[S] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
return this . charset . name () ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; MST[ReturnValsMutator]MSP[N] } public String getDefaultCharset () {
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI4Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( str == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
@Override MST[InlineConstantMutator]MSP[N] protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[NegateConditionalsMutator]MSP[N]
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.CRCR6Mutator]MSP[N] hasUnderscores = true ; break;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI3Mutator]MSP[N]
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] hasUnderscores = true ; break;
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encode ( sourceStr , getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String decode ( final String str ) throws DecoderException {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[S] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.UOI3Mutator]MSP[N] hasUnderscores = true ; break;
if ( sourceStr == null ) { MST[NegateConditionalsMutator]MSP[S] return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
@Override MST[rv.CRCR5Mutator]MSP[N] protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.UOI2Mutator]MSP[N] hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
obj . getClass () . getName () + MST[experimental.NakedReceiverMutator]MSP[N] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final byte b = bytes [ i ] ;
@Override protected String getEncoding () { return lr_1 ; MST[ReturnValsMutator]MSP[N] } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
if ( this . encodeBlanks ) { MST[rv.ROR4Mutator]MSP[S] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( str == null ) { return null ; } try { return decodeText ( str ) ; MST[ArgumentPropagationMutator]MSP[N] } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
if ( this . encodeBlanks ) { MST[rv.ROR2Mutator]MSP[N] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { MST[rv.ROR1Mutator]MSP[N] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; MST[NullReturnValsMutator]MSP[N] } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.CRCR1Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final byte b = bytes [ i ] ;
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[experimental.NakedReceiverMutator]MSP[N] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.CRCR3Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; MST[ReturnValsMutator]MSP[N] } @Override
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encode ( sourceStr , getCharset () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String decode ( final String str ) throws DecoderException {
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } else if ( obj instanceof String ) {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; MST[InlineConstantMutator]MSP[N] break;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N]
if ( b != UNDERSCORE ) { MST[rv.UOI4Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
} } if ( hasUnderscores ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; MST[ArgumentPropagationMutator]MSP[N] }
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; MST[NullReturnValsMutator]MSP[N] } public String getDefaultCharset () {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { MST[rv.ROR1Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( sourceStr == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.UOI1Mutator]MSP[N] } } } return data ; } @Override
if ( b != UNDERSCORE ) { MST[rv.CRCR5Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encodeText ( sourceStr , sourceCharset ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ROR2Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[InlineConstantMutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI2Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[S] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.UOI3Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { MST[NegateConditionalsMutator]MSP[N] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.CRCR6Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.CRCR5Mutator]MSP[S] } } } return data ; } @Override
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; MST[ReturnValsMutator]MSP[N] } return encode ( sourceStr , getCharset () ) ; } @Override public String decode ( final String str ) throws DecoderException {
if ( sourceStr == null ) { return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; MST[NonVoidMethodCallMutator]MSP[S] } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.CRCR4Mutator]MSP[N] hasUnderscores = true ; break;
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[N] } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; MST[rv.UOI4Mutator]MSP[N] }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; MST[ReturnValsMutator]MSP[N] } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; MST[NullReturnValsMutator]MSP[N] } @Override
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; MST[ReturnValsMutator]MSP[N] } else if ( obj instanceof String ) {
if ( str == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI3Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI2Mutator]MSP[N]
if ( b != UNDERSCORE ) { MST[rv.ABSMutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { MST[rv.UOI1Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[NegateConditionalsMutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
return this . charset . name () ; MST[ReturnValsMutator]MSP[N] } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI1Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[S] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[S] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI3Mutator]MSP[N] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI1Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR2Mutator]MSP[N] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR4Mutator]MSP[N] return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final byte b = bytes [ i ] ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.ROR2Mutator]MSP[S] hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.ROR4Mutator]MSP[N] hasUnderscores = true ; break;
} } if ( hasUnderscores ) { MST[rv.UOI3Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.CRCR3Mutator]MSP[N] hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.CRCR3Mutator]MSP[S] } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.CRCR1Mutator]MSP[S] } } } return data ; } @Override
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; MST[rv.UOI1Mutator]MSP[N] }
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; MST[rv.UOI3Mutator]MSP[N] }
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[S] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
if ( b != UNDERSCORE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { MST[NegateConditionalsMutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI3Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encodeText ( sourceStr , sourceCharset ) ; MST[ArgumentPropagationMutator]MSP[N] } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.CRCR1Mutator]MSP[N] hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.CRCR5Mutator]MSP[N] hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.UOI3Mutator]MSP[S] } } } return data ; } @Override
if ( b != UNDERSCORE ) { MST[rv.ROR3Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; MST[ReturnValsMutator]MSP[S] } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
@Override MST[experimental.MemberVariableMutator]MSP[N] protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; MST[rv.CRCR5Mutator]MSP[N] for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { MST[rv.CRCR6Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( b != UNDERSCORE ) { tmp [ i ] = b ; MST[rv.UOI1Mutator]MSP[N] } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ROR5Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ROR1Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[N] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI1Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.UOI1Mutator]MSP[S] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; MST[rv.CRCR1Mutator]MSP[N] for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; MST[ReturnValsMutator]MSP[N] }
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 + MST[ConstructorCallMutator]MSP[S]
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.CRCR4Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( b != UNDERSCORE ) { MST[rv.CRCR2Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
return decode ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; MST[NonVoidMethodCallMutator]MSP[N]
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encodeText ( sourceStr , sourceCharset ) ; MST[ReturnValsMutator]MSP[N] } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
return decode ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
} } if ( hasUnderscores ) { MST[rv.UOI1Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.CRCR1Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
} } if ( hasUnderscores ) { MST[rv.ROR2Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
return this . charset . name () ; } public boolean isEncodeBlanks () { return this . encodeBlanks ; MST[BooleanFalseReturnValsMutator]MSP[S] } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[N] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR4Mutator]MSP[N]
if ( b != UNDERSCORE ) { MST[rv.UOI3Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final byte b = bytes [ i ] ;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.CRCR5Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N]
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + MST[ConstructorCallMutator]MSP[S] obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; MST[ArgumentPropagationMutator]MSP[N] } else { throw new EncoderException ( lr_2 +
if ( sourceStr == null ) { return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; MST[rv.CRCR6Mutator]MSP[N] break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; MST[rv.CRCR2Mutator]MSP[N] break;
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { throw new EncoderException ( lr_2 +
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI3Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.UOI4Mutator]MSP[N] hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
if ( sourceStr == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[InlineConstantMutator]MSP[N] hasUnderscores = true ; break;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final byte b = bytes [ i ] ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.UOI1Mutator]MSP[N] hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI4Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ABSMutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
@Override MST[rv.CRCR3Mutator]MSP[N] protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
@Override MST[rv.CRCR6Mutator]MSP[N] protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI2Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
return decode ( ( String ) obj ) ; } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[S] lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final byte b = bytes [ i ] ;
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } else { throw new EncoderException ( lr_2 +
if ( this . encodeBlanks ) { MST[rv.ROR3Mutator]MSP[N] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
} } if ( hasUnderscores ) { MST[NegateConditionalsMutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
if ( this . encodeBlanks ) { MST[rv.ROR5Mutator]MSP[N] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final byte b = bytes [ i ] ;
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } else { throw new EncoderException ( lr_2 +
obj . getClass () . getName () + MST[ConstructorCallMutator]MSP[S] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; MST[NonVoidMethodCallMutator]MSP[N] } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
return this . charset . name () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean isEncodeBlanks () { return this . encodeBlanks ; } public void setEncodeBlanks ( final boolean b ) { this . encodeBlanks = b ; }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[IncrementsMutator]MSP[N] final byte b = bytes [ i ] ;
obj . getClass () . getName () + MST[NonVoidMethodCallMutator]MSP[S] lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) {
if ( b != UNDERSCORE ) { MST[rv.UOI2Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N]
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI4Mutator]MSP[N]
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.UOI1Mutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { MST[rv.ROR2Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
return decode ( ( String ) obj ) ; MST[ReturnValsMutator]MSP[N] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; MST[rv.CRCR6Mutator]MSP[N] for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.ROR3Mutator]MSP[N] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { MST[rv.ABSMutator]MSP[N] if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[InlineConstantMutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( str == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } try { return decodeText ( str ) ; } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
if ( sourceStr == null ) { MST[rv.ROR5Mutator]MSP[S] return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.UOI3Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[NegateConditionalsMutator]MSP[N] hasUnderscores = true ; break;
if ( b != UNDERSCORE ) { MST[rv.CRCR1Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { MST[rv.ABSMutator]MSP[N] hasUnderscores = true ; break;
if ( sourceStr == null ) { return null ; } try { return encodeText ( sourceStr , sourceCharset ) ; MST[ReturnValsMutator]MSP[S] } catch ( final UnsupportedEncodingException e ) { throw new EncoderException ( e . getMessage () , e ) ; } } @Override
if ( str == null ) { return null ; } try { return decodeText ( str ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } catch ( final UnsupportedEncodingException e ) { throw new DecoderException ( e . getMessage () , e ) ; } } @Override
if ( b != UNDERSCORE ) { MST[rv.CRCR4Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
public Object encode ( final Object obj ) throws EncoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } else if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } else { throw new EncoderException ( lr_2 +
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; MST[rv.CRCR3Mutator]MSP[N] for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; MST[rv.CRCR4Mutator]MSP[S] } } } return data ; } @Override
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; MST[InlineConstantMutator]MSP[N] for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
} } if ( hasUnderscores ) { MST[rv.ROR4Mutator]MSP[N] final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ;
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { return null ; } else if ( obj instanceof String ) { MST[rv.ROR2Mutator]MSP[N]
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } return encodeText ( sourceStr , sourceCharset ) ; } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { MST[rv.CRCR2Mutator]MSP[S] data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( b != UNDERSCORE ) { tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; MST[rv.CRCR3Mutator]MSP[N] } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final byte b = bytes [ i ] ;
if ( this . encodeBlanks ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
public String encode ( final String sourceStr , final Charset sourceCharset ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encodeText ( sourceStr , sourceCharset ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String encode ( final String sourceStr , final String sourceCharset ) throws EncoderException {
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; break;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final byte b = bytes [ i ] ;
return decode ( ( String ) obj ) ; MST[NullReturnValsMutator]MSP[N] } else { throw new DecoderException ( lr_2 + obj . getClass () . getName () + lr_4 ) ; } } public Charset getCharset () { return this . charset ; } public String getDefaultCharset () {
@Override MST[rv.CRCR1Mutator]MSP[N] protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] final byte b = bytes [ i ] ;
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.UOI1Mutator]MSP[N]
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
if ( this . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( data [ i ] == SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } @Override
} } if ( hasUnderscores ) { final byte [] tmp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { final byte b = bytes [ i ] ; MST[rv.ABSMutator]MSP[N]
obj . getClass () . getName () + lr_3 ) ; } } @Override public Object decode ( final Object obj ) throws DecoderException { if ( obj == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } else if ( obj instanceof String ) {
if ( b != UNDERSCORE ) { MST[rv.ROR5Mutator]MSP[N] tmp [ i ] = b ; } else { tmp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( tmp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; }
public String encode ( final String sourceStr ) throws EncoderException { if ( sourceStr == null ) { return null ; } return encode ( sourceStr , getCharset () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String decode ( final String str ) throws DecoderException {
@Override protected String getEncoding () { return lr_1 ; } @Override protected byte [] doEncoding ( final byte [] bytes ) { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; } final byte [] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ;
protected byte [] doDecoding ( final byte [] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b == UNDERSCORE ) { hasUnderscores = true ; MST[rv.CRCR4Mutator]MSP[N] break;
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.UOI4Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.UOI4Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.UOI2Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.UOI2Mutator]MSP[S] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[InlineConstantMutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.UOI4Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[rv.ROR2Mutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.UOI2Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI1Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[rv.ROR4Mutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR1Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[InlineConstantMutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ABSMutator]MSP[S] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
to = text . indexOf ( SEP , from ) ; MST[rv.CRCR2Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
final String encoding = text . substring ( from , to ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[NonVoidMethodCallMutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.CRCR4Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.CRCR6Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.CRCR6Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
to = text . indexOf ( SEP , from ) ; MST[NonVoidMethodCallMutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.CRCR2Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.ABSMutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.CRCR4Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.CRCR2Mutator]MSP[S] int from = 2 ;
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR1Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.CRCR4Mutator]MSP[S] int from = 2 ;
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.AOD1Mutator]MSP[S] int from = 2 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.UOI4Mutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.CRCR6Mutator]MSP[S] int from = 2 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S] } from = to + 1 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[S] }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[rv.CRCR3Mutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[rv.CRCR1Mutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[rv.CRCR5Mutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.UOI2Mutator]MSP[N]
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
buffer . append ( SEP ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI2Mutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[rv.CRCR2Mutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI1Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[rv.CRCR6Mutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
final String encoding = text . substring ( from , to ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
buffer . append ( SEP ) ; MST[InlineConstantMutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; MST[experimental.NakedReceiverMutator]MSP[N] buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI2Mutator]MSP[S] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[NonVoidMethodCallMutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.ABSMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.ABSMutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.ABSMutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.AOR1Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[rv.ROR2Mutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.ABSMutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.AOR1Mutator]MSP[N]
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR2Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
buffer . append ( POSTFIX ) ; return buffer . toString () ; MST[ReturnValsMutator]MSP[N] } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.AOR3Mutator]MSP[S] int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.AOR1Mutator]MSP[S] int from = 2 ;
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[MathMutator]MSP[S] int from = 2 ;
to = text . indexOf ( SEP , from ) ; MST[InlineConstantMutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI3Mutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[InlineConstantMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.AOR4Mutator]MSP[S] int from = 2 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI1Mutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI4Mutator]MSP[S] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
buffer . append ( SEP ) ; MST[rv.CRCR5Mutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( SEP ) ; MST[rv.CRCR2Mutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.ABSMutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI3Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI4Mutator]MSP[S] throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI1Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.CRCR6Mutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.CRCR3Mutator]MSP[N]
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[experimental.NakedReceiverMutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI1Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; MST[rv.UOI2Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR1Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI4Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.AOD1Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.AOD1Mutator]MSP[N]
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; MST[ReturnValsMutator]MSP[S] } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.CRCR6Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ABSMutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
int to = text . indexOf ( SEP , from ) ; MST[rv.CRCR6Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI3Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; MST[experimental.NakedReceiverMutator]MSP[N] buffer . append ( charset ) ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; MST[ArgumentPropagationMutator]MSP[N] return new String ( data , charset ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[rv.ROR3Mutator]MSP[N]
throw new DecoderException ( lr_4 ) ; MST[ConstructorCallMutator]MSP[S] } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new DecoderException ( lr_5 ) ; }
buffer . append ( POSTFIX ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI1Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI1Mutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI4Mutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[rv.CRCR1Mutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
int to = text . indexOf ( SEP , from ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; MST[NonVoidMethodCallMutator]MSP[N]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI3Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[ConstructorCallMutator]MSP[S] } from = to + 1 ;
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[rv.CRCR4Mutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[ConstructorCallMutator]MSP[S] } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ABSMutator]MSP[S] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI4Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.CRCR3Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.CRCR5Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
buffer . append ( POSTFIX ) ; return buffer . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
to = text . indexOf ( SEP , from ) ; MST[rv.CRCR5Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ABSMutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; MST[ReturnValsMutator]MSP[N] }
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[rv.CRCR4Mutator]MSP[N]
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI3Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.ABSMutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR4Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
final String encoding = text . substring ( from , to ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] } from = to + 1 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.CRCR5Mutator]MSP[N] int from = 2 ;
int to = text . indexOf ( SEP , from ) ; MST[InlineConstantMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] }
int to = text . indexOf ( SEP , from ) ; MST[rv.CRCR3Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.UOI3Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.UOI3Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.UOI1Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[rv.ROR1Mutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.UOI3Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.UOI1Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR2Mutator]MSP[S] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[MathMutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR4Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[MathMutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; MST[rv.ABSMutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI3Mutator]MSP[S] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI4Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ; MST[ArgumentPropagationMutator]MSP[S]
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR1Mutator]MSP[S] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI2Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; MST[experimental.NakedReceiverMutator]MSP[N]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.AOR2Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.AOR4Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[rv.ROR1Mutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR3Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S] } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.AOR4Mutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.AOR2Mutator]MSP[N]
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[rv.ROR5Mutator]MSP[N]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[ArgumentPropagationMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.ABSMutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; MST[ReturnValsMutator]MSP[N] }
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI3Mutator]MSP[S] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI4Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[ArgumentPropagationMutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[InlineConstantMutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } final StringBuilder buffer = new StringBuilder () ; buffer . append ( PREFIX ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . append ( charset ) ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI1Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[rv.CRCR3Mutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
final String encoding = text . substring ( from , to ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.AOD2Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI3Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR4Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.AOD2Mutator]MSP[N]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.CRCR3Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.CRCR5Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; MST[rv.CRCR3Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; MST[ArgumentPropagationMutator]MSP[S] } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR2Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[InlineConstantMutator]MSP[N] int from = 2 ;
int to = text . indexOf ( SEP , from ) ; MST[rv.CRCR5Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI4Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.CRCR3Mutator]MSP[S] int from = 2 ;
protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } final StringBuilder buffer = new StringBuilder () ; MST[ConstructorCallMutator]MSP[S] buffer . append ( PREFIX ) ; buffer . append ( charset ) ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.UOI1Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[NonVoidMethodCallMutator]MSP[S]
int to = text . indexOf ( SEP , from ) ; MST[rv.CRCR1Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[rv.CRCR2Mutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[rv.CRCR6Mutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.UOI1Mutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.AOR2Mutator]MSP[S] int from = 2 ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[NegateConditionalsMutator]MSP[N]
buffer . append ( SEP ) ; MST[rv.CRCR1Mutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[rv.UOI2Mutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
buffer . append ( SEP ) ; MST[rv.CRCR3Mutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( SEP ) ; MST[rv.CRCR4Mutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( SEP ) ; MST[rv.CRCR6Mutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI2Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.CRCR4Mutator]MSP[N]
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.CRCR5Mutator]MSP[N]
int to = text . indexOf ( SEP , from ) ; MST[rv.ABSMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; MST[rv.UOI3Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; MST[rv.UOI4Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.CRCR2Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; MST[ConstructorCallMutator]MSP[N] }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI2Mutator]MSP[N] throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { return null ; MST[ReturnValsMutator]MSP[S] }
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.CRCR2Mutator]MSP[N]
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR5Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
buffer . append ( SEP ) ; MST[experimental.NakedReceiverMutator]MSP[N] buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( POSTFIX ) ; MST[NonVoidMethodCallMutator]MSP[N] return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.CRCR4Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ; MST[InlineConstantMutator]MSP[N]
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
int to = text . indexOf ( SEP , from ) ; MST[rv.CRCR4Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
int to = text . indexOf ( SEP , from ) ; MST[rv.CRCR2Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S] } from = to + 1 ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] data = doDecoding ( data ) ; return new String ( data , charset ) ; }
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) { MST[rv.ROR4Mutator]MSP[S]
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
buffer . append ( POSTFIX ) ; return buffer . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { return null ; }
int to = text . indexOf ( SEP , from ) ; MST[ArgumentPropagationMutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.UOI2Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
buffer . append ( POSTFIX ) ; return buffer . toString () ; } protected String encodeText ( final String text , final String charsetName ) throws EncoderException , UnsupportedEncodingException { if ( text == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; MST[rv.CRCR5Mutator]MSP[N] buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { MST[NegateConditionalsMutator]MSP[N] throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
final String encoding = text . substring ( from , to ) ; MST[rv.ABSMutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
to = text . indexOf ( SEP , from ) ; byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; MST[NonVoidMethodCallMutator]MSP[N] return new String ( data , charset ) ; }
final String encoding = text . substring ( from , to ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
int to = text . indexOf ( SEP , from ) ; MST[rv.UOI1Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; if ( charset . equals ( lr_3 ) ) {
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { MST[rv.ROR2Mutator]MSP[N] throw new DecoderException ( lr_5 ) ; }
final String encoding = text . substring ( from , to ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ;
to = text . indexOf ( SEP , from ) ; MST[rv.CRCR1Mutator]MSP[N] byte [] data = StringUtils . getBytesUsAscii ( text . substring ( from , to ) ) ; data = doDecoding ( data ) ; return new String ( data , charset ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[NonVoidMethodCallMutator]MSP[S] int from = 2 ;
return this . encodeText ( text , Charset . forName ( charsetName ) ) ; } protected String decodeText ( final String text ) throws DecoderException , UnsupportedEncodingException { if ( text == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; }
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; to = text . indexOf ( SEP , from ) ; MST[rv.CRCR1Mutator]MSP[N] if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } final int terminator = text . length () - 2 ; int from = 2 ;
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.CRCR1Mutator]MSP[S] int from = 2 ;
buffer . append ( SEP ) ; buffer . append ( this . getEncoding () ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( this . doEncoding ( text . getBytes ( charset ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[rv.UOI2Mutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; MST[rv.AOD2Mutator]MSP[S] int from = 2 ;
throw new DecoderException ( lr_4 ) ; } from = to + 1 ; MST[rv.AOR3Mutator]MSP[N] to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_5 ) ; }
if ( ! text . startsWith ( PREFIX ) || ! text . endsWith ( POSTFIX ) ) { MST[rv.ROR4Mutator]MSP[N] throw new DecoderException ( lr_1 ) ; } final int terminator = text . length () - 2 ; int from = 2 ;
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.AOR3Mutator]MSP[N]
int to = text . indexOf ( SEP , from ) ; if ( to == terminator ) { throw new DecoderException ( lr_2 ) ; } final String charset = text . substring ( from , to ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( charset . equals ( lr_3 ) ) {
final String encoding = text . substring ( from , to ) ; if ( ! getEncoding () . equalsIgnoreCase ( encoding ) ) { throw new DecoderException ( lr_6 + encoding + lr_7 ) ; } from = to + 1 ; MST[rv.UOI3Mutator]MSP[N]
@Override public int compare ( final Phoneme o1 , final Phoneme o2 ) { for ( int i = 0 ; i < o1 . phonemeText . length () ; i ++ ) { if ( i >= o2 . phonemeText . length () ) { return + 1 ;
} final int c = o1 . phonemeText . charAt ( i ) - o2 . phonemeText . charAt ( i ) ; if ( c != 0 ) { return c ; } }
if ( o1 . phonemeText . length () < o2 . phonemeText . length () ) { return - 1 ; } return 0 ; } public Phoneme append ( final CharSequence str ) { this . phonemeText . append ( str ) ; return this ; }
public Languages . LanguageSet getLanguages () { return this . languages ; } @Override public Iterable < Phoneme > getPhonemes () { return Collections . singleton ( this ) ; } public CharSequence getPhonemeText () { return this . phonemeText ; } @Deprecated
public Phoneme join ( final Phoneme right ) { return new Phoneme ( this . phonemeText . toString () + right . phonemeText . toString () , this . languages . restrictTo ( right . languages ) ) ; } public Phoneme mergeWithLanguage ( final LanguageSet lang ) {
return new Phoneme ( this . phonemeText . toString () , this . languages . merge ( lang ) ) ; } @Override public String toString () { return phonemeText . toString () + lr_1 + languages + lr_2 ; } @Override public List < Phoneme > getPhonemes () {
return this . phonemes ; } @Override public boolean isMatch ( final CharSequence input ) { return true ; } private static boolean contains ( final CharSequence chars , final char input ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
private static String createResourceName ( final NameType nameType , final RuleType rt , final String lang ) { return String . format ( lr_3 , nameType . getName () , rt . getName () , lang ) ; }
private static Scanner createScanner ( final NameType nameType , final RuleType rt , final String lang ) { final String resName = createResourceName ( nameType , rt , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return false ; } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; final List < Rule > allRules = new ArrayList <> () ; for ( final List < Rule > rules : ruleMap . values () ) {
allRules . addAll ( rules ) ; } return allRules ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final String lang ) {
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : getInstanceMap ( nameType , rt , Languages . ANY ) ; }
public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt , final String lang ) {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; } return parsePhoneme ( ph ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
sb . append ( lr_14 ) ; sb . append ( lr_15 ) . append ( myLine ) ; sb . append ( lr_16 ) . append ( loc ) . append ( '\'' ) ;
sb . append ( lr_17 ) . append ( pat ) . append ( '\'' ) ; sb . append ( lr_18 ) . append ( lCon ) . append ( '\'' ) ;
sb . append ( lr_19 ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . toString () ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 0 ; }
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
contains ( bContent , input . charAt ( input . length () - 1 ) ) == shouldMatch ; } @Override public boolean isMatch ( final CharSequence input ) { final Matcher matcher = pattern . matcher ( input ) ; return matcher . find () ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
return this . lContext ; } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
if ( ipl > input . length () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI2Mutator]MSP[N] return true ; } } return false ; }
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[S]
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[NegateConditionalsMutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
return false ; } } return true ; MST[ReturnValsMutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
if ( ! ph . endsWith ( lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[ArgumentPropagationMutator]MSP[N]
return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
if ( ! ph . endsWith ( lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.ROR4Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return endsWith ( input , content ) ; } @Override MST[rv.UOI2Mutator]MSP[S] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.UOI3Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
str = str . substring ( 1 ) ; MST[InlineConstantMutator]MSP[S] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.CRCR3Mutator]MSP[S]
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ABSMutator]MSP[N] return true ; } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; MST[InlineConstantMutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI3Mutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[InlineConstantMutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
if ( ! ph . endsWith ( lr_9 ) ) { MST[rv.ROR5Mutator]MSP[S] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR6Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
if ( ! ph . endsWith ( lr_9 ) ) { MST[NegateConditionalsMutator]MSP[S] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI3Mutator]MSP[N] return false ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ROR3Mutator]MSP[N] return true ; } } return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ROR2Mutator]MSP[N]
str = str . substring ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } } return false ; }
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[S]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.ROR4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return true ; } } return false ; }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; MST[ArgumentPropagationMutator]MSP[N] if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; MST[ReturnValsMutator]MSP[S] } return parsePhoneme ( ph ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[ConstructorCallMutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[NonVoidMethodCallMutator]MSP[S]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; MST[NonVoidMethodCallMutator]MSP[N] final int ipl = i + patternLength ;
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] }
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[NegateConditionalsMutator]MSP[S]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[rv.ROR3Mutator]MSP[S]
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.ABSMutator]MSP[S]
if ( ipl > input . length () ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.ROR3Mutator]MSP[S]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } return str ; } public RPattern getLContext () {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; } public RPattern getLContext () {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[ReturnValsMutator]MSP[N] }
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI4Mutator]MSP[N] return false ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; MST[ReturnValsMutator]MSP[N] } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[ConditionalsBoundaryMutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( final String part : body . split ( lr_11 ) ) { MST[rv.ABSMutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[ReturnValsMutator]MSP[N]
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR1Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
return this . lContext ; MST[NullReturnValsMutator]MSP[N] } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; }
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[ReturnValsMutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR4Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; MST[ConstructorCallMutator]MSP[N] }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ROR5Mutator]MSP[N] return false ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ROR2Mutator]MSP[N] return false ;
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[rv.ROR5Mutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI2Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N]
if ( ipl > input . length () ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : getInstanceMap ( nameType , rt , Languages . ANY ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; }
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.ABSMutator]MSP[N]
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR1Mutator]MSP[N]
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[InlineConstantMutator]MSP[N] }
if ( ! ph . endsWith ( lr_2 ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.AOR3Mutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( ipl > input . length () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( ! ph . endsWith ( lr_2 ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.ABSMutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[NegateConditionalsMutator]MSP[N] return false ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ABSMutator]MSP[N]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; MST[ConstructorCallMutator]MSP[N] } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
if ( ipl > input . length () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR1Mutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR5Mutator]MSP[N]
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR6Mutator]MSP[N]
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } return str ; } public RPattern getLContext () {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR3Mutator]MSP[N]
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( ipl > input . length () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI2Mutator]MSP[N]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.AOD1Mutator]MSP[N]
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[MathMutator]MSP[N] } return str ; } public RPattern getLContext () {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI4Mutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ;
return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[experimental.RemoveIncrementsMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[InlineConstantMutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ROR5Mutator]MSP[N]
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[rv.ROR2Mutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
return this . lContext ; } public String getPattern () { return this . pattern ; MST[EmptyObjectReturnValsMutator]MSP[N] } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.UOI3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR3Mutator]MSP[N]
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[InlineConstantMutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.ROR5Mutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR3Mutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[ReturnValsMutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR3Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR4Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[NegateConditionalsMutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[rv.ROR5Mutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[experimental.NakedReceiverMutator]MSP[N] return false ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[NegateConditionalsMutator]MSP[N] return true ; } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
for ( final String part : body . split ( lr_11 ) ) { MST[rv.ABSMutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.ROR1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI3Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR3Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; MST[NullReturnValsMutator]MSP[N] }
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI4Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
return endsWith ( input , content ) ; } @Override MST[ReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
sb . append ( lr_19 ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . toString () ; } @Override MST[ReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 0 ; }
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[rv.ROR1Mutator]MSP[N] return false ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.UOI3Mutator]MSP[N]
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; } return parsePhoneme ( ph ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[ReturnValsMutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[InlineConstantMutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[rv.CRCR5Mutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR6Mutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
return false ; MST[ReturnValsMutator]MSP[N] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
return endsWith ( input , content ) ; } @Override MST[rv.ABSMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.UOI2Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[InlineConstantMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR2Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( ipl > input . length () ) { MST[rv.UOI1Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
str = str . substring ( 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
if ( ipl > input . length () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ; } public RPattern getLContext () {
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
if ( ipl > input . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
return endsWith ( input , content ) ; } @Override MST[rv.UOI4Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
if ( ipl > input . length () ) { MST[rv.ROR4Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
if ( ! ph . endsWith ( lr_2 ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[NonVoidMethodCallMutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR3Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[NonVoidMethodCallMutator]MSP[N]
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR6Mutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[MathMutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.UOI1Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI2Mutator]MSP[N]
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.CRCR1Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
if ( ! ph . endsWith ( lr_9 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; } return parsePhoneme ( ph ) ; MST[NullReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[ReturnValsMutator]MSP[N] } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR2Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR2Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[ConstructorCallMutator]MSP[N]
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.AOR2Mutator]MSP[N]
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override MST[NullReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.UOI1Mutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
return this . lContext ; } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; MST[NullReturnValsMutator]MSP[N] }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.UOI3Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ROR4Mutator]MSP[N] return false ;
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; MST[ConstructorCallMutator]MSP[N] } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR5Mutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI2Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI4Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR3Mutator]MSP[N]
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; MST[ConstructorCallMutator]MSP[N] } return parsePhoneme ( ph ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR2Mutator]MSP[N]
if ( ! ph . endsWith ( lr_2 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI1Mutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[NegateConditionalsMutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[rv.ROR5Mutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( ipl > input . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; MST[EmptyObjectReturnValsMutator]MSP[N] } public RPattern getLContext () {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI1Mutator]MSP[N] return false ;
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR4Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[NonVoidMethodCallMutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
return this . lContext ; } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; MST[NullReturnValsMutator]MSP[N] } public RPattern getRContext () { return this . rContext ; }
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.ROR5Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ABSMutator]MSP[N] return false ;
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N]
str = str . substring ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; MST[NullReturnValsMutator]MSP[N] } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[MathMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; final List < Rule > allRules = new ArrayList <> () ; for ( final List < Rule > rules : ruleMap . values () ) { MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; MST[NullReturnValsMutator]MSP[N] } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI4Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; }
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[NonVoidMethodCallMutator]MSP[N]
return this . lContext ; } public String getPattern () { return this . pattern ; MST[ReturnValsMutator]MSP[N] } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N]
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR5Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[rv.CRCR3Mutator]MSP[N] }
if ( ! ph . endsWith ( lr_9 ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( open >= 0 ) {
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override MST[ConstructorCallMutator]MSP[N] public boolean isMatch ( final CharSequence input ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } return false ; }
return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; MST[NullReturnValsMutator]MSP[N] } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
return endsWith ( input , content ) ; } @Override MST[rv.UOI1Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.ABSMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.ROR1Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } } return false ; }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ipl > input . length () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.ABSMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( ipl > input . length () ) { MST[rv.ROR1Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR2Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; } public RPattern getLContext () {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[ReturnValsMutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[NonVoidMethodCallMutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[NegateConditionalsMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR3Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[InlineConstantMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR4Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ipl > input . length () ) { MST[rv.UOI3Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
if ( ipl > input . length () ) { MST[rv.ABSMutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
str = str . substring ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[InlineConstantMutator]MSP[N]
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; } public RPattern getLContext () {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI3Mutator]MSP[N] return true ; } } return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[MathMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI3Mutator]MSP[N] return false ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI1Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.UOI2Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR6Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.ROR3Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[ArgumentPropagationMutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[rv.ROR3Mutator]MSP[N] return false ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ABSMutator]MSP[N] return true ; } } return false ; }
if ( ! ph . endsWith ( lr_2 ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOD1Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; MST[NullReturnValsMutator]MSP[N] } return parsePhoneme ( ph ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR5Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[IncrementsMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI2Mutator]MSP[N] return false ;
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[ReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR3Mutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[InlineConstantMutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI2Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[rv.ROR4Mutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.ABSMutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ROR1Mutator]MSP[N] return false ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR1Mutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ROR1Mutator]MSP[N] return true ; } } return false ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI2Mutator]MSP[N]
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI4Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N]
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR1Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( ! ph . endsWith ( lr_2 ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < Rule > allRules = new ArrayList <> () ; for ( final List < Rule > rules : ruleMap . values () ) {
if ( ipl > input . length () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override MST[ConstructorCallMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI1Mutator]MSP[N]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[MathMutator]MSP[N]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; MST[ConstructorCallMutator]MSP[N] } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR4Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
if ( ! ph . endsWith ( lr_9 ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ; } public RPattern getLContext () {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.AOR4Mutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR4Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; } public RPattern getLContext () {
return false ; MST[rv.CRCR6Mutator]MSP[N] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[InlineConstantMutator]MSP[N] }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOD1Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.AOD2Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI1Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; } return new PhonemeList ( phs ) ; } return parsePhoneme ( ph ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
@Override MST[NullReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } return str ; } public RPattern getLContext () {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[ReturnValsMutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ; } public RPattern getLContext () {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } return str ; } public RPattern getLContext () {
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; MST[ConstructorCallMutator]MSP[N] } return new PhonemeList ( phs ) ; } return parsePhoneme ( ph ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[NonVoidMethodCallMutator]MSP[N] return true ; } } return false ; }
nameType . getName () , rt . getName () , lang ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI2Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.UOI2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[ConditionalsBoundaryMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[InlineConstantMutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.UOI3Mutator]MSP[N]
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR3Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[rv.CRCR6Mutator]MSP[N] }
str = str . substring ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[InlineConstantMutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.UOI1Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.UOI4Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[NegateConditionalsMutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI3Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[NegateConditionalsMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.ROR2Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI4Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI1Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI3Mutator]MSP[N]
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[N]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR1Mutator]MSP[N]
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[rv.ROR2Mutator]MSP[N] return false ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[N]
return endsWith ( input , content ) ; } @Override MST[rv.UOI3Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override MST[NullReturnValsMutator]MSP[S] public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[MathMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI4Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[ReturnValsMutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
if ( ipl > input . length () ) { MST[rv.ROR3Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI1Mutator]MSP[N] return true ; } } return false ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[NegateConditionalsMutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[NonVoidMethodCallMutator]MSP[S] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.ROR3Mutator]MSP[S] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } } return false ; }
if ( ipl > input . length () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[InlineConstantMutator]MSP[N]
@Override MST[ConstructorCallMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR4Mutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_5 ,
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.UOI4Mutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[InlineConstantMutator]MSP[N] } } return false ; }
return false ; MST[rv.CRCR1Mutator]MSP[S] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR2Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI4Mutator]MSP[N] return false ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ROR4Mutator]MSP[N] return true ; } } return false ; }
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ABSMutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ROR3Mutator]MSP[N] return false ;
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ROR1Mutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; MST[ReturnValsMutator]MSP[N] } public RPattern getLContext () {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[rv.CRCR1Mutator]MSP[N] }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[ConditionalsBoundaryMutator]MSP[S] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
nameType . getName () , rt . getName () , lang ) ) ; MST[InlineConstantMutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[InlineConstantMutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override MST[ReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) {
if ( ! ph . endsWith ( lr_9 ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI4Mutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR3Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.CRCR1Mutator]MSP[N] }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( String . format ( lr_5 ,
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[experimental.RemoveIncrementsMutator]MSP[S] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.ROR4Mutator]MSP[N]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[rv.ROR2Mutator]MSP[N]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[rv.ROR1Mutator]MSP[N]
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; } public RPattern getLContext () {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI1Mutator]MSP[S] return true ; } } return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.ABSMutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[InlineConstantMutator]MSP[S] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR2Mutator]MSP[N] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI1Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N]
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[rv.ROR1Mutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.UOI4Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR4Mutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; MST[ArgumentPropagationMutator]MSP[N] if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.ABSMutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[MathMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; } public RPattern getLContext () {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ; } public RPattern getLContext () {
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[NullReturnValsMutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } } return false ; }
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI3Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
for ( final String part : body . split ( lr_11 ) ) { MST[rv.ABSMutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ; MST[ConstructorCallMutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR5Mutator]MSP[N]
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR4Mutator]MSP[N]
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[N] final String body = ph . substring ( 1 , ph . length () - 1 ) ;
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; MST[ReturnValsMutator]MSP[N] }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR3Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR5Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[InlineConstantMutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ipl > input . length () ) { MST[ConditionalsBoundaryMutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[N]
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } return false ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.UOI1Mutator]MSP[S] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.ROR2Mutator]MSP[S] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return false ; } } return true ; MST[rv.CRCR3Mutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.ABSMutator]MSP[N] }
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.CRCR5Mutator]MSP[N]
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[NonVoidMethodCallMutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
allRules . addAll ( rules ) ; } return allRules ; MST[ReturnValsMutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final String lang ) {
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[experimental.NakedReceiverMutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ! ph . endsWith ( lr_9 ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR6Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR4Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } } return false ; }
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI3Mutator]MSP[N]
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[rv.ROR3Mutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ABSMutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[NonVoidMethodCallMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.ROR4Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
final Languages . LanguageSet langs ) { return langs . isSingleton () ? getInstanceMap ( nameType , rt , langs . getAny () ) : MST[NonVoidMethodCallMutator]MSP[N] getInstanceMap ( nameType , rt , Languages . ANY ) ; }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.UOI4Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
sb . append ( lr_19 ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . toString () ; } @Override MST[NullReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 0 ; }
return endsWith ( input , content ) ; } @Override MST[NullReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR6Mutator]MSP[N]
@Override public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override MST[ReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { return false ; MST[ReturnValsMutator]MSP[N] }
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR3Mutator]MSP[N]
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( String . format ( lr_5 ,
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.UOI4Mutator]MSP[N] return true ; } } return false ; }
return this . lContext ; MST[ReturnValsMutator]MSP[N] } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; }
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; } public RPattern getLContext () {
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; MST[ReturnValsMutator]MSP[N] } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
return this . lContext ; } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; } public RPattern getRContext () { return this . rContext ; MST[ReturnValsMutator]MSP[N] }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[NonVoidMethodCallMutator]MSP[N]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ROR3Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.ROR2Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
return false ; } } return true ; MST[InlineConstantMutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[InlineConstantMutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[NegateConditionalsMutator]MSP[N]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.UOI1Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI4Mutator]MSP[N] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.UOI1Mutator]MSP[N] }
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.UOI1Mutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
allRules . addAll ( rules ) ; MST[NonVoidMethodCallMutator]MSP[N] } return allRules ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final String lang ) {
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[NonVoidMethodCallMutator]MSP[N]
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
if ( ipl > input . length () ) { MST[rv.UOI2Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
if ( ! ph . endsWith ( lr_2 ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.UOI3Mutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; MST[ReturnValsMutator]MSP[N] } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) {
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.ABSMutator]MSP[N]
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[rv.UOI2Mutator]MSP[N]
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[InlineConstantMutator]MSP[N]
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI1Mutator]MSP[N] return false ;
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ROR5Mutator]MSP[N] return true ; } } return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOD2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR2Mutator]MSP[N] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[rv.CRCR4Mutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.ABSMutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } } return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.UOI3Mutator]MSP[N]
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[ConstructorCallMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR5Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } return str ; } public RPattern getLContext () {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[NonVoidMethodCallMutator]MSP[N]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
if ( ! ph . endsWith ( lr_9 ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ;
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.ABSMutator]MSP[N] return false ;
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
return this . lContext ; } public String getPattern () { return this . pattern ; } public PhonemeExpr getPhoneme () { return this . phoneme ; MST[ReturnValsMutator]MSP[N] } public RPattern getRContext () { return this . rContext ; }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; MST[ArgumentPropagationMutator]MSP[N] if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
if ( ! ph . endsWith ( lr_2 ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ;
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[rv.CRCR2Mutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.AOR1Mutator]MSP[S]
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR5Mutator]MSP[S] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR3Mutator]MSP[S] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.ROR5Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return false ; } } return true ; MST[rv.CRCR6Mutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.UOI4Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.UOI2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOR4Mutator]MSP[S] } return str ; } public RPattern getLContext () {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 , MST[rv.CRCR1Mutator]MSP[N]
final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; final List < Rule > allRules = new ArrayList <> () ; MST[ConstructorCallMutator]MSP[S] for ( final List < Rule > rules : ruleMap . values () ) {
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { MST[rv.ROR2Mutator]MSP[N] return true ; } } return false ; }
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.UOI2Mutator]MSP[N]
sb . append ( lr_19 ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . toString () ; } @Override MST[ConstructorCallMutator]MSP[S] public boolean isMatch ( final CharSequence input ) { return input . length () == 0 ; }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } } return false ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.UOI2Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
return endsWith ( input , content ) ; } @Override MST[ConstructorCallMutator]MSP[S] public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override
if ( ! ph . endsWith ( lr_2 ) ) { throw new IllegalArgumentException ( lr_6 ) ; } final String before = ph . substring ( 0 , open ) ; MST[experimental.NakedReceiverMutator]MSP[S]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOR3Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
@Override MST[ReturnValsMutator]MSP[S] public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) {
for ( final String part : body . split ( lr_11 ) ) { MST[NonVoidMethodCallMutator]MSP[S] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; MST[rv.CRCR2Mutator]MSP[N] } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
for ( final String part : body . split ( lr_11 ) ) { MST[rv.UOI1Mutator]MSP[S] phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[ReturnValsMutator]MSP[N] }
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( lr_4 , lang ) ; MST[rv.CRCR4Mutator]MSP[S] return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; }
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[NullReturnValsMutator]MSP[S]
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ; MST[rv.AOR1Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[InlineConstantMutator]MSP[N] }
for ( int i = 0 ; i < chars . length () ; i ++ ) { if ( chars . charAt ( i ) == input ) { return true ; } } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( rules == null ) { throw new IllegalArgumentException ( String . format ( lr_5 ,
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ;
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[rv.ROR4Mutator]MSP[N] return false ; }
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.CRCR1Mutator]MSP[S] } return str ; } public RPattern getLContext () {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR2Mutator]MSP[S]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[InlineConstantMutator]MSP[N]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOD2Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length () > input . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.CRCR5Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
str = str . substring ( 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
allRules . addAll ( rules ) ; } return allRules ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final String lang ) {
return getInstance ( nameType , rt , LanguageSet . from ( new HashSet <> ( Arrays . asList ( lang ) ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt ,
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[IncrementsMutator]MSP[S] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[rv.AOR1Mutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
nameType . getName () , rt . getName () , lang ) ) ; } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) { MST[rv.ROR2Mutator]MSP[S]
return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( lr_8 ) ) { MST[rv.ROR4Mutator]MSP[S]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[NullReturnValsMutator]MSP[N] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { MST[rv.ROR2Mutator]MSP[N] return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[rv.UOI2Mutator]MSP[N] return false ;
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { MST[rv.ROR5Mutator]MSP[N] return false ; } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[rv.ROR5Mutator]MSP[S] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[S] } return str ; } public RPattern getLContext () {
if ( ipl > input . length () ) { return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { MST[NonVoidMethodCallMutator]MSP[N] return false ;
return endsWith ( input , content ) ; } @Override public boolean isMatch ( final CharSequence input ) { return input . length () == 1 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[ConstructorCallMutator]MSP[S]
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length () > input . length () ) { return false ; } for ( int i = 0 ; i < prefix . length () ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.ROR1Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { MST[rv.UOI3Mutator]MSP[N] return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; MST[rv.UOI3Mutator]MSP[N] }
nameType . getName () , rt . getName () , lang ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return str ; } public RPattern getLContext () {
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( input . charAt ( i ) != prefix . charAt ( i ) ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } } return true ; } private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) {
str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
} else if ( ! this . rContext . isMatch ( input . subSequence ( ipl , input . length () ) ) ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } return this . lContext . isMatch ( input . subSequence ( 0 , i ) ) ; }
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[rv.AOD2Mutator]MSP[S]
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[NonVoidMethodCallMutator]MSP[S]
if ( ipl > input . length () ) { MST[rv.UOI4Mutator]MSP[N] return false ; } if ( ! input . subSequence ( i , ipl ) . equals ( this . pattern ) ) { return false ;
if ( ! ph . endsWith ( lr_9 ) ) { throw new IllegalArgumentException ( lr_10 ) ; } final List < Phoneme > phs = new ArrayList <> () ; final String body = ph . substring ( 1 , ph . length () - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR5Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
public boolean isMatch ( final CharSequence input ) { return input . length () > 0 && contains ( bContent , input . charAt ( 0 ) ) == shouldMatch ; } @Override MST[rv.ABSMutator]MSP[S] public boolean isMatch ( final CharSequence input ) { return input . length () > 0 &&
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
return false ; MST[rv.CRCR3Mutator]MSP[N] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { if ( input . charAt ( i ) != suffix . charAt ( j ) ) { MST[rv.ROR3Mutator]MSP[N]
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { MST[rv.UOI1Mutator]MSP[N] throw new IndexOutOfBoundsException ( lr_20 ) ; } final int patternLength = this . pattern . length () ; final int ipl = i + patternLength ;
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = input . length () - 1 , j = suffix . length () - 1 ; j >= 0 ; i -- , j -- ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( input . charAt ( i ) != suffix . charAt ( j ) ) {
return false ; MST[InlineConstantMutator]MSP[N] } } return true ; } public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) {
final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( String . format ( lr_5 ,
phs . add ( new Phoneme ( lr_13 , Languages . ANY_LANGUAGE ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } return new PhonemeList ( phs ) ; } return parsePhoneme ( ph ) ; } @Override public String toString () { final StringBuilder sb = new StringBuilder () ;
for ( final String part : body . split ( lr_11 ) ) { phs . add ( parsePhoneme ( part ) ) ; } if ( body . startsWith ( lr_12 ) || body . endsWith ( lr_12 ) ) { MST[rv.ROR1Mutator]MSP[S]
for ( int i = 0 ; i < chars . length () ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( chars . charAt ( i ) == input ) { return true ; } } return false ; }
final String in = ph . substring ( open + 1 , ph . length () - 1 ) ; MST[rv.AOD1Mutator]MSP[S] final Set < String > langs = new HashSet <> ( Arrays . asList ( in . split ( lr_7 ) ) ) ;
nameType . getName () , rt . getName () , lang ) ) ; MST[rv.CRCR1Mutator]MSP[N] } return rules ; } private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( lr_1 ) ; if ( open >= 0 ) {
str = str . substring ( 1 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length () - 1 ) ; } return str ; } public RPattern getLContext () {
@Override public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; try { @SuppressWarnings ( lr_1 )
final Comparable < Comparable < ? > > s1 = ( Comparable < Comparable < ? > > ) this . stringEncoder . encode ( o1 ) ; final Comparable < ? > s2 = ( Comparable < ? > ) this . stringEncoder . encode ( o2 ) ;
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; }
final Comparable < Comparable < ? > > s1 = ( Comparable < Comparable < ? > > ) this . stringEncoder . encode ( o1 ) ; MST[ArgumentPropagationMutator]MSP[N] final Comparable < ? > s2 = ( Comparable < ? > ) this . stringEncoder . encode ( o2 ) ;
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; MST[InlineConstantMutator]MSP[S] } return compareCode ; }
@Override public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; MST[InlineConstantMutator]MSP[N] try { @SuppressWarnings ( lr_1 )
final Comparable < Comparable < ? > > s1 = ( Comparable < Comparable < ? > > ) this . stringEncoder . encode ( o1 ) ; MST[NonVoidMethodCallMutator]MSP[S] final Comparable < ? > s2 = ( Comparable < ? > ) this . stringEncoder . encode ( o2 ) ;
final Comparable < Comparable < ? > > s1 = ( Comparable < Comparable < ? > > ) this . stringEncoder . encode ( o1 ) ; final Comparable < ? > s2 = ( Comparable < ? > ) this . stringEncoder . encode ( o2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
final Comparable < Comparable < ? > > s1 = ( Comparable < Comparable < ? > > ) this . stringEncoder . encode ( o1 ) ; final Comparable < ? > s2 = ( Comparable < ? > ) this . stringEncoder . encode ( o2 ) ; MST[ArgumentPropagationMutator]MSP[N]
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[ReturnValsMutator]MSP[N] }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[rv.UOI1Mutator]MSP[N] }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[PrimitiveReturnsMutator]MSP[S] }
compareCode = s1 . compareTo ( s2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[rv.ABSMutator]MSP[N] }
@Override public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; MST[rv.CRCR1Mutator]MSP[N] try { @SuppressWarnings ( lr_1 )
@Override public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; MST[rv.CRCR6Mutator]MSP[N] try { @SuppressWarnings ( lr_1 )
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[rv.UOI3Mutator]MSP[N] }
@Override public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; MST[rv.CRCR3Mutator]MSP[N] try { @SuppressWarnings ( lr_1 )
@Override public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; MST[rv.CRCR5Mutator]MSP[N] try { @SuppressWarnings ( lr_1 )
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[rv.UOI2Mutator]MSP[N] }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; MST[rv.UOI4Mutator]MSP[N] }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; MST[rv.CRCR3Mutator]MSP[S] } return compareCode ; }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; MST[rv.CRCR1Mutator]MSP[S] } return compareCode ; }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; MST[rv.CRCR5Mutator]MSP[S] } return compareCode ; }
compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; MST[rv.CRCR6Mutator]MSP[S] } return compareCode ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; }
if ( cs1 instanceof String && cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
private static byte [] getBytes ( final String string , final Charset charset ) { if ( string == null ) { return null ; } return string . getBytes ( charset ) ; } public static byte [] getBytesIso8859_1 ( final String string ) {
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ;
} catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static byte [] getBytesUsAscii ( final String string ) { return getBytes ( string , StandardCharsets . US_ASCII ) ; }
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; }
public static byte [] getBytesUtf16Le ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16LE ) ; } public static byte [] getBytesUtf8 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_8 ) ; }
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; } private static String newString ( final byte [] bytes , final Charset charset ) {
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
return new String ( bytes , charsetName ) ; } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ;
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; }
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; }
public static String newStringUtf8 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_8 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return new String ( bytes , charsetName ) ; } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ; MST[EmptyObjectReturnValsMutator]MSP[S]
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } try {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return cs1 . equals ( cs2 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR4Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { MST[NegateConditionalsMutator]MSP[N] return true ; } if ( cs1 == null || cs2 == null ) { return false ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; MST[ReturnValsMutator]MSP[S] } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR1Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR1Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
} catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static byte [] getBytesUsAscii ( final String string ) { return getBytes ( string , StandardCharsets . US_ASCII ) ; MST[ReturnValsMutator]MSP[S] }
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; MST[ReturnValsMutator]MSP[S] } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR2Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
} catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static byte [] getBytesUsAscii ( final String string ) { return getBytes ( string , StandardCharsets . US_ASCII ) ; MST[NullReturnValsMutator]MSP[S] }
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR3Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR1Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR4Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR2Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR5Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } try {
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public static byte [] getBytesUtf16Le ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16LE ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static byte [] getBytesUtf8 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_8 ) ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[NegateConditionalsMutator]MSP[S] return cs1 . equals ( cs2 ) ; }
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } if ( cs1 == null || cs2 == null ) { return false ; }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ;
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } try {
if ( string == null ) { return null ; MST[ReturnValsMutator]MSP[S] } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ; MST[ReturnValsMutator]MSP[S]
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return cs1 . equals ( cs2 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; MST[ReturnValsMutator]MSP[S] } try { return string . getBytes ( charsetName ) ;
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; MST[EmptyObjectReturnValsMutator]MSP[S] }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static byte [] getBytesUtf16Le ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16LE ) ; MST[ReturnValsMutator]MSP[S] } public static byte [] getBytesUtf8 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_8 ) ; }
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; MST[ReturnValsMutator]MSP[N] }
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; MST[ReturnValsMutator]MSP[S] } try {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR1Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; MST[ReturnValsMutator]MSP[N] }
private static byte [] getBytes ( final String string , final Charset charset ) { if ( string == null ) { return null ; MST[ReturnValsMutator]MSP[S] } return string . getBytes ( charset ) ; } public static byte [] getBytesIso8859_1 ( final String string ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return bytes == null ? null : new String ( bytes , charset ) ; MST[ConstructorCallMutator]MSP[N] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } if ( cs1 == null || cs2 == null ) { return false ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[rv.CRCR6Mutator]MSP[S] } if ( cs1 == null || cs2 == null ) { return false ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR4Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static String newStringUtf8 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[rv.CRCR5Mutator]MSP[S] } if ( cs1 == null || cs2 == null ) { return false ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } try {
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; MST[NullReturnValsMutator]MSP[S] } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ;
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ; MST[NullReturnValsMutator]MSP[S]
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR5Mutator]MSP[S] return cs1 . equals ( cs2 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR4Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[InlineConstantMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
} catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static byte [] getBytesUsAscii ( final String string ) { return getBytes ( string , StandardCharsets . US_ASCII ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[rv.CRCR2Mutator]MSP[S] } if ( cs1 == null || cs2 == null ) { return false ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR1Mutator]MSP[S] return cs1 . equals ( cs2 ) ; }
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; MST[NullReturnValsMutator]MSP[S] } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; }
if ( string == null ) { MST[rv.ROR5Mutator]MSP[S] return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
return new String ( bytes , charsetName ) ; } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( cs1 instanceof String && cs2 instanceof String ) { MST[NegateConditionalsMutator]MSP[N] return cs1 . equals ( cs2 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } try { return string . getBytes ( charsetName ) ;
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; }
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
} catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static byte [] getBytesUsAscii ( final String string ) { return getBytes ( string , StandardCharsets . US_ASCII ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; MST[NullReturnValsMutator]MSP[S] }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; } try { return string . getBytes ( charsetName ) ;
return bytes == null ? null : new String ( bytes , charset ) ; MST[rv.ROR5Mutator]MSP[N] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR1Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR2Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR4Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[InlineConstantMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; MST[ReturnValsMutator]MSP[N] } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[ReturnValsMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] }
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[experimental.NakedReceiverMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ; MST[NonVoidMethodCallMutator]MSP[N]
return bytes == null ? null : new String ( bytes , charset ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[NegateConditionalsMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return bytes == null ? null : new String ( bytes , charset ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] }
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[NullReturnValsMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
return new String ( bytes , charsetName ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ;
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[InlineConstantMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( cs1 == null || cs2 == null ) { return false ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] }
if ( cs1 instanceof String && cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[InlineConstantMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; MST[ReturnValsMutator]MSP[S] }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; MST[ReturnValsMutator]MSP[N] } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { return null ; } try { return string . getBytes ( charsetName ) ;
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; } try { return string . getBytes ( charsetName ) ;
if ( string == null ) { MST[NegateConditionalsMutator]MSP[S] return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[NegateConditionalsMutator]MSP[N] return false ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[ArgumentPropagationMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return bytes == null ? null : new String ( bytes , charset ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { MST[rv.ROR5Mutator]MSP[N] return true ; } if ( cs1 == null || cs2 == null ) { return false ; }
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; MST[NullReturnValsMutator]MSP[S] }
return bytes == null ? null : new String ( bytes , charset ) ; MST[NegateConditionalsMutator]MSP[N] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
public static String newStringUtf8 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_8 ) ; MST[ReturnValsMutator]MSP[N] }
return getBytes ( string , StandardCharsets . ISO_8859_1 ) ; } public static byte [] getBytesUnchecked ( final String string , final String charsetName ) { if ( string == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } try { return string . getBytes ( charsetName ) ;
return new String ( bytes , charsetName ) ; } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ;
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[ConstructorCallMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return cs1 . equals ( cs2 ) ; }
if ( string == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[InlineConstantMutator]MSP[N] }
return new String ( bytes , charsetName ) ; MST[ReturnValsMutator]MSP[S] } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ;
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR1Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } if ( cs1 == null || cs2 == null ) { return false ; }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR2Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
if ( cs1 instanceof String && cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR1Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[rv.ROR5Mutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[NegateConditionalsMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static String newStringUtf8 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_8 ) ; MST[EmptyObjectReturnValsMutator]MSP[S] }
} public static String newStringUsAscii ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; } public static String newStringUtf16 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; MST[ReturnValsMutator]MSP[N] }
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[ConstructorCallMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[InlineConstantMutator]MSP[S] } if ( cs1 == null || cs2 == null ) { return false ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR2Mutator]MSP[N] return cs1 . equals ( cs2 ) ; }
public static byte [] getBytesUtf16Le ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16LE ) ; } public static byte [] getBytesUtf8 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; MST[ReturnValsMutator]MSP[S] } if ( cs1 == null || cs2 == null ) { return false ; }
return bytes == null ? null : new String ( bytes , charset ) ; } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; } try {
if ( cs1 instanceof String && cs2 instanceof String ) { MST[rv.ROR3Mutator]MSP[S] return cs1 . equals ( cs2 ) ; }
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; MST[EmptyObjectReturnValsMutator]MSP[S] }
return cs1 . length () == cs2 . length () && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length () ) ; MST[InlineConstantMutator]MSP[N] } private static ByteBuffer getByteBuffer ( final String string , final Charset charset ) {
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; }
return bytes == null ? null : new String ( bytes , charset ) ; MST[ReturnValsMutator]MSP[N] } public static String newString ( final byte [] bytes , final String charsetName ) { if ( bytes == null ) { return null ; } try {
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[ReturnValsMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
if ( string == null ) { return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; MST[NullReturnValsMutator]MSP[S] } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[rv.ROR5Mutator]MSP[N] return false ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; }
public static byte [] getBytesUtf16Le ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16LE ) ; MST[NullReturnValsMutator]MSP[S] } public static byte [] getBytesUtf8 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_8 ) ; }
return new String ( bytes , charsetName ) ; MST[ConstructorCallMutator]MSP[N] } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ;
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
return new String ( bytes , charsetName ) ; } catch ( final UnsupportedEncodingException e ) { throw StringUtils . newIllegalStateException ( charsetName , e ) ; } } public static String newStringIso8859_1 ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ; MST[ReturnValsMutator]MSP[N]
public static byte [] getBytesUtf16 ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16 ) ; } public static byte [] getBytesUtf16Be ( final String string ) { return getBytes ( string , StandardCharsets . UTF_16BE ) ; MST[ReturnValsMutator]MSP[N] }
public static String newStringUtf16Be ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; MST[ReturnValsMutator]MSP[N] } public static String newStringUtf16Le ( final byte [] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; }
if ( cs1 instanceof String && cs2 instanceof String ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return cs1 . equals ( cs2 ) ; }
if ( string == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return null ; } return ByteBuffer . wrap ( string . getBytes ( charset ) ) ; } public static ByteBuffer getByteBufferUtf8 ( final String string ) { return getByteBuffer ( string , StandardCharsets . UTF_8 ) ; }
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null || cs2 == null ) { return false ; MST[ReturnValsMutator]MSP[N] }
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + lr_1 + e ) ; MST[NonVoidMethodCallMutator]MSP[N] } private static String newString ( final byte [] bytes , final Charset charset ) {
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] |
SPTRANS [ 7 ] [ t >>> 24 & 0x3f ] | SPTRANS [ 0 ] [ u & 0x3f ] | SPTRANS [ 2 ] [ u >>> 8 & 0x3f ] |
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; } private static int [] desSetKey ( final byte key [] ) {
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 3 ] [ c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ;
results [ 0 ] = a ; results [ 1 ] = b ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[MathMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR3Mutator]MSP[N] return a ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[MathMutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[ReturnValsMutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.OBBN1Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR3Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR4Mutator]MSP[N] final int results [] = new int [ 2 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[IncrementsMutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI3Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR4Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[ConstructorCallMutator]MSP[N] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
right = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR4Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR3Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR1Mutator]MSP[N] }
left = t >>> 1 | t << 31 ; MST[rv.UOI4Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[InlineConstantMutator]MSP[N] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI2Mutator]MSP[N] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI4Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[N] a ^= t << n ; b ^= t ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI3Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
c = c >>> 1 | c << 27 ; MST[rv.CRCR4Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
y ++ ; MST[IncrementsMutator]MSP[N] u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR1Mutator]MSP[N] out [ 1 ] = right ; return out ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[MathMutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.ABSMutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR2Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.ABSMutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI1Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR2Mutator]MSP[N] return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
left = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI3Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR1Mutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[N] a ^= t << n ; b ^= t ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI2Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ABSMutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI4Mutator]MSP[N] right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI4Mutator]MSP[N] } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI1Mutator]MSP[N] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR4Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR6Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; MST[rv.CRCR2Mutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI2Mutator]MSP[N]
y ++ ; u = 128 ; MST[rv.CRCR5Mutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.OBBN3Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI2Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.OBBN3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 0 ] ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI4Mutator]MSP[N] }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.ABSMutator]MSP[N] int u = v & e0 ; v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[MathMutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[N] a ^= t << n ; b ^= t ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[InlineConstantMutator]MSP[N] right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR3Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[experimental.NakedReceiverMutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[IncrementsMutator]MSP[N] return value ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI1Mutator]MSP[N] return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI4Mutator]MSP[N] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[VoidMethodCallMutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] key [ i ] = 0 ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI1Mutator]MSP[N] out [ 1 ] = right ; return out ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; MST[MathMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[ReturnValsMutator]MSP[N] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[InlineConstantMutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR3Mutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[VoidMethodCallMutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI3Mutator]MSP[N] return out ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR3Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI1Mutator]MSP[N] }
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.ABSMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI4Mutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[N] return a ; }
left = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[InlineConstantMutator]MSP[N] }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
results [ 0 ] = a ; MST[rv.UOI4Mutator]MSP[N] results [ 1 ] = b ; }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] key [ i ] = 0 ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[N] return a ; }
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[ConstructorCallMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[InlineConstantMutator]MSP[N]
right = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
c = c >>> 1 | c << 27 ; MST[rv.CRCR1Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[VoidMethodCallMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR1Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[InlineConstantMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.OBBN2Mutator]MSP[N] } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR1Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI1Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
right = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI2Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
results [ 0 ] = a ; MST[InlineConstantMutator]MSP[N] results [ 1 ] = b ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[InlineConstantMutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[InlineConstantMutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR5Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI1Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR6Mutator]MSP[N] return a ; }
s = s << 4 | s >>> 28 ; MST[rv.UOI1Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR6Mutator]MSP[N] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR4Mutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[IncrementsMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
left = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[MathMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR6Mutator]MSP[N] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI2Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[MathMutator]MSP[N] if ( u == 0 ) {
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR1Mutator]MSP[N] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI4Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI1Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[rv.ROR5Mutator]MSP[N] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR1Mutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI4Mutator]MSP[N] return value ; }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[N] a ^= t << n ; b ^= t ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI1Mutator]MSP[N] } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR3Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI3Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR1Mutator]MSP[N] final int results [] = new int [ 2 ] ;
left = t >>> 1 | t << 31 ; MST[rv.OBBN1Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR1Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[ConditionalsBoundaryMutator]MSP[N] }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI2Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI3Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR3Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI4Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.ABSMutator]MSP[N] }
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI4Mutator]MSP[N] }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[InlineConstantMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI4Mutator]MSP[N] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[InlineConstantMutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR3Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[InlineConstantMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.CRCR2Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[NegateConditionalsMutator]MSP[N] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.ABSMutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI3Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; MST[rv.CRCR3Mutator]MSP[N] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR5Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[MathMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI1Mutator]MSP[N] return value ; }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR3Mutator]MSP[N] return out ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR4Mutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI3Mutator]MSP[N] b ^= t ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.OBBN1Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI3Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[MathMutator]MSP[N] return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR6Mutator]MSP[N] } else {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.OBBN1Mutator]MSP[N] }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR6Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR1Mutator]MSP[N] right = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] c = results [ 1 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI3Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[InlineConstantMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI3Mutator]MSP[N] right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI2Mutator]MSP[N] d &= 0xfffffff ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[InlineConstantMutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR5Mutator]MSP[N]
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI3Mutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR6Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR1Mutator]MSP[N] }
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI1Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR3Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[N] a ^= t << n ; b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[N] t = t >>> 4 | t << 28 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI3Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.ABSMutator]MSP[N] b ^= t ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[InlineConstantMutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
left = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR6Mutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.ABSMutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR3Mutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR5Mutator]MSP[N] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI4Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI2Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.ABSMutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR1Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR1Mutator]MSP[N] }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI3Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.OBBN2Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR2Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] c = results [ 1 ] ;
c = c >>> 1 | c << 27 ; MST[rv.ABSMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI3Mutator]MSP[N] return value < 0 ? value + 256 : value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[NegateConditionalsMutator]MSP[N] }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI4Mutator]MSP[N] return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR5Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.ABSMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI2Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ABSMutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[MathMutator]MSP[N] a ^= t << n ; b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.OBBN1Mutator]MSP[N] v &= e1 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[MathMutator]MSP[N] v &= e1 ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI2Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR4Mutator]MSP[N] if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[MathMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR1Mutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[N] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[InlineConstantMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[InlineConstantMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
results [ 0 ] = a ; MST[rv.UOI1Mutator]MSP[N] results [ 1 ] = b ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI2Mutator]MSP[N] } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR6Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.ABSMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; MST[rv.CRCR5Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[MathMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.ABSMutator]MSP[N] v &= e1 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI2Mutator]MSP[N] v &= e1 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[InlineConstantMutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; MST[ReturnValsMutator]MSP[N] } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[N] d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[InlineConstantMutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.OBBN3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI3Mutator]MSP[N] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR6Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR4Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR5Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI4Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.OBBN1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[NonVoidMethodCallMutator]MSP[S] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR4Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR4Mutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ABSMutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.ABSMutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] left = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.OBBN2Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI2Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI2Mutator]MSP[N] b ^= t ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI2Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final char charOne = salt . charAt ( 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; MST[rv.OBBN3Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[N] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI1Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.OBBN3Mutator]MSP[N] d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.ABSMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[N] return a ; }
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR1Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[InlineConstantMutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR4Mutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR1Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR4Mutator]MSP[N] } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI1Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[N] t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI1Mutator]MSP[N] } else {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[InlineConstantMutator]MSP[N] out [ 1 ] = right ; return out ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[N]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR4Mutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.ABSMutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR2Mutator]MSP[N] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI2Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI2Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR5Mutator]MSP[N] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
s = s << 4 | s >>> 28 ; MST[rv.UOI4Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[ArgumentPropagationMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI3Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR3Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI1Mutator]MSP[N] right = left >>> 1 | left << 31 ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR4Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[N] d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN3Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI2Mutator]MSP[N] int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR1Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[N] d = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR5Mutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[VoidMethodCallMutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI4Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR3Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR2Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI4Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR5Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[InlineConstantMutator]MSP[N] right = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI2Mutator]MSP[N] return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
int c = 0 ; MST[rv.CRCR6Mutator]MSP[N] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[MathMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI1Mutator]MSP[N] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI3Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[N] int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[N] d = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[ArgumentPropagationMutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.UOI3Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOD2Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.OBBN3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI4Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[IncrementsMutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR4Mutator]MSP[N] d &= 0xfffffff ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[MathMutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[IncrementsMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI3Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[InlineConstantMutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI1Mutator]MSP[N] }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR5Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[NonVoidMethodCallMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[N] return a ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.OBBN2Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR4Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR2Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR3Mutator]MSP[N] } else {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI1Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.ABSMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR3Mutator]MSP[N] }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI3Mutator]MSP[N] v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR3Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
results [ 0 ] = a ; MST[rv.CRCR1Mutator]MSP[N] results [ 1 ] = b ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[NonVoidMethodCallMutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI1Mutator]MSP[N] }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; MST[MathMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR3Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] int j = 0 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR3Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI4Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; MST[InlineConstantMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI3Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.OBBN3Mutator]MSP[N] int j = 0 ;
right = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[InlineConstantMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR3Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR4Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR2Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR5Mutator]MSP[N] return value ; }
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI2Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR4Mutator]MSP[N] right = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR2Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[InlineConstantMutator]MSP[N] final int results [] = new int [ 2 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR1Mutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.ABSMutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
s = s << 4 | s >>> 28 ; MST[InlineConstantMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI1Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] key [ i ] = 0 ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI4Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[MathMutator]MSP[N] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR1Mutator]MSP[N] } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI4Mutator]MSP[N] d &= 0xfffffff ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR4Mutator]MSP[N] return a ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.ABSMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[VoidMethodCallMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR6Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR6Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.OBBN3Mutator]MSP[N] } else {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI1Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.ABSMutator]MSP[N] return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[N] return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR5Mutator]MSP[N] t = t >>> 4 | t << 28 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.ABSMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[VoidMethodCallMutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR1Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR5Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.ABSMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI2Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR3Mutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[N] d = results [ 0 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI1Mutator]MSP[N] right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[InlineConstantMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI3Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
results [ 0 ] = a ; MST[rv.CRCR3Mutator]MSP[N] results [ 1 ] = b ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI4Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR1Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR4Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI3Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI1Mutator]MSP[N] } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR6Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR5Mutator]MSP[N] }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR6Mutator]MSP[N] right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.ABSMutator]MSP[N] } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[InlineConstantMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI1Mutator]MSP[N] v &= e1 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.ABSMutator]MSP[N] out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI1Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI4Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.OBBN1Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[InlineConstantMutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[InlineConstantMutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI3Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.OBBN2Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR6Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; MST[ConstructorCallMutator]MSP[N] final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] left = results [ 1 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR2Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[MathMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR6Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[VoidMethodCallMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[N] return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[S] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI4Mutator]MSP[N] } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR1Mutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[IncrementsMutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI2Mutator]MSP[N] } t = right ; right = left >>> 1 | left << 31 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI1Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR5Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI4Mutator]MSP[N] v &= e1 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[MathMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.OBBN2Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR5Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR6Mutator]MSP[N] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI2Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR4Mutator]MSP[N] int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.ABSMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[MathMutator]MSP[N] b ^= t ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] int j = 0 ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI1Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI2Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[InlineConstantMutator]MSP[N] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[InlineConstantMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[InlineConstantMutator]MSP[N] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI4Mutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[NonVoidMethodCallMutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI4Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI4Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] key [ i ] = 0 ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[N] a ^= t << n ; b ^= t ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[N] return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
right = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR2Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.OBBN2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI2Mutator]MSP[N] return value ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI4Mutator]MSP[N] b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR2Mutator]MSP[N] return a ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[N] d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR5Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI4Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR4Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR5Mutator]MSP[N] final int results [] = new int [ 2 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String crypt ( final String original ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.ABSMutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.ABSMutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR3Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR1Mutator]MSP[N] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.OBBN3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.ABSMutator]MSP[N] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR5Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR4Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[ArgumentPropagationMutator]MSP[N] final int results [] = new int [ 2 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[N] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] c = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] key [ i ] = 0 ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
c = c >>> 1 | c << 27 ; MST[rv.ABSMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[N] a ^= t << n ; b ^= t ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[N] a ^= t << n ; b ^= t ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI4Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.ABSMutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI4Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.ABSMutator]MSP[N] return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR3Mutator]MSP[N] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
s = s << 4 | s >>> 28 ; MST[MathMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[ConditionalsBoundaryMutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR3Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR5Mutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.ABSMutator]MSP[N] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[PrimitiveReturnsMutator]MSP[N] }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI4Mutator]MSP[N] right = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.ABSMutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR2Mutator]MSP[N] }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR4Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR6Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.CRCR3Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.ABSMutator]MSP[N] int u = v & e0 ; v &= e1 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR4Mutator]MSP[N] }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI3Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.OBBN3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI3Mutator]MSP[N] }
c = c >>> 1 | c << 27 ; MST[rv.UOI4Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[experimental.RemoveIncrementsMutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.ABSMutator]MSP[N] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOD2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; MST[rv.CRCR4Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR2Mutator]MSP[N] return out ; }
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR5Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
y ++ ; u = 128 ; MST[rv.CRCR1Mutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.ABSMutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR4Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ABSMutator]MSP[N] int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[MathMutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI1Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.ABSMutator]MSP[N] int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[MathMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR2Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI1Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR5Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] }
int c = 0 ; MST[InlineConstantMutator]MSP[N] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] int j = 0 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR3Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR5Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI3Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[N] t = t >>> 4 | t << 28 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI4Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR6Mutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[InlineConstantMutator]MSP[N] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] left = results [ 1 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI4Mutator]MSP[N] int j = 0 ;
left = t >>> 1 | t << 31 ; MST[rv.ABSMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[ArgumentPropagationMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.OBBN3Mutator]MSP[N] return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[N] a ^= t << n ; b ^= t ;
left = t >>> 1 | t << 31 ; MST[rv.CRCR5Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI3Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI2Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[N] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[VoidMethodCallMutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] key [ i ] = 0 ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR1Mutator]MSP[N] d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR4Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
left = t >>> 1 | t << 31 ; MST[rv.CRCR4Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[InlineConstantMutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.ABSMutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[MathMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI3Mutator]MSP[N] b ^= t ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI1Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[N]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; MST[NonVoidMethodCallMutator]MSP[S] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI3Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.UOI4Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.OBBN3Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR1Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.OBBN2Mutator]MSP[N] a ^= t << n ; b ^= t ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR2Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.ABSMutator]MSP[N] right = left >>> 1 | left << 31 ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.ABSMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR6Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR1Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR3Mutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI4Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR2Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI2Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR4Mutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
c = c >>> 1 | c << 27 ; MST[rv.UOI1Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.ABSMutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR3Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[InlineConstantMutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI4Mutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI1Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.ABSMutator]MSP[N] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.OBBN2Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI4Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI3Mutator]MSP[N] return value ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR4Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR2Mutator]MSP[N] final int results [] = new int [ 2 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR2Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI1Mutator]MSP[N] return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI3Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI1Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[MathMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI2Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI1Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR1Mutator]MSP[N] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[IncrementsMutator]MSP[N] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI4Mutator]MSP[N] }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI3Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR1Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI2Mutator]MSP[N] v &= e1 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.CRCR4Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI1Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR3Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR3Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI2Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.ABSMutator]MSP[N] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[InlineConstantMutator]MSP[N] d &= 0xfffffff ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR2Mutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[MathMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[MathMutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR1Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR1Mutator]MSP[N] }
s = s << 4 | s >>> 28 ; MST[rv.UOI3Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[N] d = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.ABSMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR6Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
results [ 0 ] = a ; MST[rv.ABSMutator]MSP[N] results [ 1 ] = b ; }
final int schedule [] = desSetKey ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI4Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[MathMutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[ConstructorCallMutator]MSP[N] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR6Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[N] d = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI2Mutator]MSP[N] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI1Mutator]MSP[N] b ^= t ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[experimental.NakedReceiverMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[IncrementsMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI3Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI2Mutator]MSP[N] return value < 0 ? value + 256 : value ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR4Mutator]MSP[N] return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N] }
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ; MST[NonVoidMethodCallMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ABSMutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR1Mutator]MSP[N] int j = 0 ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; MST[NullReturnValsMutator]MSP[N] } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI4Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
left = t >>> 1 | t << 31 ; MST[InlineConstantMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR3Mutator]MSP[N] right = results [ 0 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[N] d = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI1Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOD1Mutator]MSP[N] return a ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[NonVoidMethodCallMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI2Mutator]MSP[N] right = left >>> 1 | left << 31 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR1Mutator]MSP[N] return value ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[InlineConstantMutator]MSP[N] } else {
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ABSMutator]MSP[N] key [ i ] = 0 ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[InlineConstantMutator]MSP[N] for ( int j = 0 ; j < 25 ; j ++ ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI4Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[N] t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.ABSMutator]MSP[N] d &= 0xfffffff ;
s = s << 4 | s >>> 28 ; MST[rv.OBBN3Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int schedule [] = new int [ 32 ] ; MST[InlineConstantMutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI2Mutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; MST[ReturnValsMutator]MSP[N] } public static String crypt ( final String original ) {
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[N] return a ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.OBBN3Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[S]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR6Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI2Mutator]MSP[N] }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI2Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.UOI3Mutator]MSP[N] }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI2Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR5Mutator]MSP[N] return a ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR3Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.ABSMutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI2Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[MathMutator]MSP[N] b ^= t ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI1Mutator]MSP[N] d &= 0xfffffff ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR5Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
c = c >>> 1 | c << 27 ; MST[InlineConstantMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI1Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[MathMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.ABSMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI4Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR4Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR4Mutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR6Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR1Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[S]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI2Mutator]MSP[N] out [ 1 ] = right ; return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR2Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR4Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI4Mutator]MSP[N] return out ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI3Mutator]MSP[N] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[InlineConstantMutator]MSP[N] return a ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI1Mutator]MSP[N] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.ABSMutator]MSP[N] } else {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI4Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR6Mutator]MSP[N] return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[N] d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR2Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.ABSMutator]MSP[N] v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[InlineConstantMutator]MSP[N] t = t >>> 4 | t << 28 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI3Mutator]MSP[N] if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; MST[rv.CRCR4Mutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR3Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.OBBN2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI1Mutator]MSP[N] }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.OBBN1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR2Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; MST[rv.UOI2Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR6Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
s = s << 4 | s >>> 28 ; MST[rv.CRCR1Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR4Mutator]MSP[N] right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
c = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.ABSMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI3Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( int j = 0 ; j < 25 ; j ++ ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[InlineConstantMutator]MSP[N] int j = 0 ;
int c = 0 ; MST[rv.CRCR5Mutator]MSP[N] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[InlineConstantMutator]MSP[N] int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[InlineConstantMutator]MSP[N] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI2Mutator]MSP[N] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI3Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[experimental.NakedReceiverMutator]MSP[S] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[MathMutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.OBBN2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR6Mutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI1Mutator]MSP[N] int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.ABSMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] int j = 0 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
left = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR5Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[N] a ^= t << n ; b ^= t ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[N] return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR3Mutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[N] a ^= t << n ; b ^= t ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[VoidMethodCallMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[N] a ^= t << n ; b ^= t ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[InlineConstantMutator]MSP[N] }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR1Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI1Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI1Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] c = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI1Mutator]MSP[N] right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[InlineConstantMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[ReturnValsMutator]MSP[N] }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] key [ i ] = 0 ; }
c = c >>> 1 | c << 27 ; MST[MathMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR2Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[InlineConstantMutator]MSP[N] return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI1Mutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR3Mutator]MSP[N] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = c >>> 1 | c << 27 ; MST[rv.UOI3Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI3Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR4Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR3Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[NonVoidMethodCallMutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR6Mutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[MathMutator]MSP[N] }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[N] return a ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[MathMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR6Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.ABSMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI1Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[N] a ^= t << n ; b ^= t ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR2Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI1Mutator]MSP[N] return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.UOI2Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI3Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.ABSMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.ABSMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR6Mutator]MSP[N] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR4Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR5Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR5Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI1Mutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.UOI3Mutator]MSP[N] int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR5Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI4Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR1Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.ABSMutator]MSP[N] t = t >>> 4 | t << 28 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 0 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[N] return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.OBBN1Mutator]MSP[N] int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI3Mutator]MSP[N] return a ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR2Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR3Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR4Mutator]MSP[N] } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR5Mutator]MSP[N] } else {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[N] t = t >>> 4 | t << 28 ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.UOI1Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR5Mutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[InlineConstantMutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR2Mutator]MSP[N] right = results [ 0 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.UOI3Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOD1Mutator]MSP[N] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[N] d = results [ 0 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[N] d = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.OBBN1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[MathMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.ABSMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR5Mutator]MSP[N] d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN2Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI2Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR6Mutator]MSP[N] if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[NegateConditionalsMutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[experimental.RemoveIncrementsMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI4Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
left = t >>> 1 | t << 31 ; MST[rv.CRCR4Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI4Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.ABSMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR4Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR3Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[ArgumentPropagationMutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR3Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR5Mutator]MSP[N] right = results [ 0 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI1Mutator]MSP[N] v &= e1 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI4Mutator]MSP[N] b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI4Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI1Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI1Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI4Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR2Mutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( int j = 0 ; j < 25 ; j ++ ) {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[MathMutator]MSP[N] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR5Mutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] left = results [ 1 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ROR2Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.ABSMutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR1Mutator]MSP[N] d = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR1Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR4Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[NonVoidMethodCallMutator]MSP[N] return value ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR1Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ABSMutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.ABSMutator]MSP[N] a ^= t << n ; b ^= t ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR6Mutator]MSP[N] t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR1Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.CRCR4Mutator]MSP[N] }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI4Mutator]MSP[N] v &= e1 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] int j = 0 ;
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR2Mutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.ABSMutator]MSP[N] right = results [ 0 ] ;
s = s << 4 | s >>> 28 ; MST[MathMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.UOI4Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] key [ i ] = 0 ; }
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[MathMutator]MSP[N] a ^= t << n ; b ^= t ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[InlineConstantMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI4Mutator]MSP[N] right = results [ 0 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI2Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[MathMutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[InlineConstantMutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR6Mutator]MSP[N] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI3Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[NonVoidMethodCallMutator]MSP[N] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI3Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR2Mutator]MSP[N] } else {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR6Mutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.UOI3Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.OBBN1Mutator]MSP[N] d &= 0xfffffff ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[InlineConstantMutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.UOI2Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI3Mutator]MSP[N] b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[InlineConstantMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR6Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR1Mutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI2Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[MathMutator]MSP[N]
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI4Mutator]MSP[N] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR4Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI3Mutator]MSP[N] }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR1Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[IncrementsMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI2Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[MathMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
left = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[NonVoidMethodCallMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR6Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR1Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
results [ 0 ] = a ; MST[rv.UOI2Mutator]MSP[N] results [ 1 ] = b ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[N] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[ArgumentPropagationMutator]MSP[N] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.OBBN1Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[InlineConstantMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.OBBN2Mutator]MSP[N] v &= e1 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[MathMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR3Mutator]MSP[N] if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[InlineConstantMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR3Mutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = c >>> 1 | c << 27 ; MST[rv.UOI4Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.OBBN2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI2Mutator]MSP[N] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR6Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI3Mutator]MSP[N] }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR1Mutator]MSP[N]
c = c >>> 1 | c << 27 ; MST[rv.CRCR5Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.OBBN1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.UOI4Mutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.OBBN3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR6Mutator]MSP[N] right = results [ 0 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[InlineConstantMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR5Mutator]MSP[N] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR3Mutator]MSP[N] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI3Mutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[NonVoidMethodCallMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR3Mutator]MSP[N] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI2Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN1Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR3Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR1Mutator]MSP[N] } else {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR5Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[N] d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI4Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI2Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; MST[rv.OBBN1Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.ABSMutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR2Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR5Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[experimental.RemoveIncrementsMutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR4Mutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI3Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR3Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI4Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI1Mutator]MSP[N] if ( u == 0 ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR6Mutator]MSP[N] out [ 1 ] = right ; return out ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR5Mutator]MSP[N]
right = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
left = t >>> 1 | t << 31 ; MST[InlineConstantMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR1Mutator]MSP[N] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR6Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR6Mutator]MSP[N] final int results [] = new int [ 2 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.ABSMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[MathMutator]MSP[N] a ^= t << n ; b ^= t ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI1Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR2Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR5Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[InlineConstantMutator]MSP[N] } else {
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR2Mutator]MSP[N] return a ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[VoidMethodCallMutator]MSP[N] right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[MathMutator]MSP[N] } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.OBBN1Mutator]MSP[N] } else {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR6Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOD2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[N] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[InlineConstantMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI1Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI4Mutator]MSP[N] if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR3Mutator]MSP[N] out [ 1 ] = right ; return out ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[N] a ^= t << n ; b ^= t ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.ABSMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[InlineConstantMutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.ABSMutator]MSP[N] } else {
c = c >>> 1 | c << 27 ; MST[rv.CRCR6Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR5Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOD1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[experimental.RemoveIncrementsMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[MathMutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI3Mutator]MSP[N] out [ 1 ] = right ; return out ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.ABSMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] int j = 0 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR4Mutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR5Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI3Mutator]MSP[N] }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.OBBN3Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI2Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR3Mutator]MSP[N] right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR2Mutator]MSP[N] int j = 0 ;
c = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR5Mutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR5Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
y ++ ; u = 128 ; MST[rv.CRCR3Mutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR2Mutator]MSP[N] d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.OBBN2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI4Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR4Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
left = t >>> 1 | t << 31 ; MST[rv.ABSMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; MST[rv.CRCR5Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI1Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[ArgumentPropagationMutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR4Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR6Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[InlineConstantMutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N]
int c = 0 ; MST[rv.CRCR1Mutator]MSP[N] for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI3Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI4Mutator]MSP[N] a ^= t << n ; b ^= t ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.ABSMutator]MSP[N] b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[InlineConstantMutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR4Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.ABSMutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI4Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR2Mutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR5Mutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; MST[rv.CRCR3Mutator]MSP[N] int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
left = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI3Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[NegateConditionalsMutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.OBBN1Mutator]MSP[N]
c = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI1Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI1Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.OBBN2Mutator]MSP[N] return value ; }
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR3Mutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI4Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR6Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[InlineConstantMutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI4Mutator]MSP[N] return value ; }
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI4Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR6Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; MST[rv.UOI3Mutator]MSP[N] right = t ; } t = right ; right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI4Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.CRCR3Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.OBBN2Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
left = t >>> 1 | t << 31 ; MST[MathMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[NegateConditionalsMutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.OBBN1Mutator]MSP[N] a ^= t << n ; b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ABSMutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR3Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR1Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.OBBN1Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR5Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.ABSMutator]MSP[N] return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[MathMutator]MSP[N] } else {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR2Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI4Mutator]MSP[N] return a ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[MathMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final char charOne = salt . charAt ( 1 ) ; MST[InlineConstantMutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR3Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[ArgumentPropagationMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI2Mutator]MSP[N] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] key [ i ] = 0 ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI3Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR2Mutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR3Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.ABSMutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI2Mutator]MSP[N] a ^= t << n ; b ^= t ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI3Mutator]MSP[N] } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.ABSMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[NonVoidMethodCallMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.CRCR4Mutator]MSP[N] return a ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR4Mutator]MSP[N] }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.OBBN3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI1Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[N] d = results [ 0 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR6Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI1Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI1Mutator]MSP[N] b ^= t ;
c = c >>> 1 | c << 27 ; MST[rv.UOI1Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI2Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[VoidMethodCallMutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N] left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR6Mutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR1Mutator]MSP[N]
y ++ ; u = 128 ; MST[InlineConstantMutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI4Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI2Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[MathMutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI1Mutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI4Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.OBBN2Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[InlineConstantMutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[MathMutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI3Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI2Mutator]MSP[N] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[PrimitiveReturnsMutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR5Mutator]MSP[N] d = results [ 0 ] ;
left = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI2Mutator]MSP[N] }
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR6Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[experimental.RemoveIncrementsMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[MathMutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR5Mutator]MSP[N] return out ; }
results [ 0 ] = a ; results [ 1 ] = b ; MST[InlineConstantMutator]MSP[N] }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR1Mutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR2Mutator]MSP[N] t = t >>> 4 | t << 28 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR2Mutator]MSP[N] }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[NonVoidMethodCallMutator]MSP[N] final int results [] = new int [ 2 ] ;
results [ 0 ] = a ; MST[rv.CRCR6Mutator]MSP[N] results [ 1 ] = b ; }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR5Mutator]MSP[N] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI2Mutator]MSP[N] right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.ABSMutator]MSP[N] return value < 0 ? value + 256 : value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.ABSMutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI2Mutator]MSP[N] return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[MathMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.OBBN3Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; MST[rv.CRCR3Mutator]MSP[N] final int results [] = new int [ 2 ] ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI3Mutator]MSP[N] } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR5Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
c = c >>> 1 | c << 27 ; MST[rv.CRCR2Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
c = c >>> 1 | c << 27 ; MST[rv.CRCR3Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[NegateConditionalsMutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ; MST[rv.CRCR5Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = c >>> 1 | c << 27 ; MST[rv.OBBN2Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[ReturnValsMutator]MSP[S] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR6Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI1Mutator]MSP[N]
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.CRCR5Mutator]MSP[N] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI3Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI2Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.ROR5Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[MathMutator]MSP[N] return a ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; MST[rv.CRCR2Mutator]MSP[N] permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.UOI3Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[IncrementsMutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR2Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.UOI2Mutator]MSP[N] if ( u == 0 ) {
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.CRCR5Mutator]MSP[N] out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.OBBN1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[InlineConstantMutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[InlineConstantMutator]MSP[N] if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; MST[NonVoidMethodCallMutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[InlineConstantMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR5Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
right = results [ 0 ] ; left = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
final byte key [] = new byte [ 8 ] ; MST[rv.CRCR5Mutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI4Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[N] return a ; }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[rv.UOI4Mutator]MSP[N] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] c = results [ 1 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[InlineConstantMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.OBBN2Mutator]MSP[N] d &= 0xfffffff ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI4Mutator]MSP[N] b ^= t ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[MathMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI3Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.UOI1Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR3Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR2Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[NegateConditionalsMutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.UOI3Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI4Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[NonVoidMethodCallMutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.OBBN3Mutator]MSP[N] v &= e1 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI1Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.ABSMutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[InlineConstantMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[IncrementsMutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.OBBN2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[InlineConstantMutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR6Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.OBBN2Mutator]MSP[N] int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI2Mutator]MSP[N]
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI2Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR5Mutator]MSP[N] } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.OBBN2Mutator]MSP[N] }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI1Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR2Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR6Mutator]MSP[N] return value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR6Mutator]MSP[N] }
c = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[rv.UOI4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.OBBN2Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; MST[rv.CRCR3Mutator]MSP[N] out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[ArgumentPropagationMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR2Mutator]MSP[N] right = results [ 0 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.ABSMutator]MSP[N] return value ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.ABSMutator]MSP[N] right = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.UOI2Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR4Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.AOR4Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR6Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR1Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[InlineConstantMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI3Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
for ( int i = 0 ; i < 16 ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ROR2Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN2Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[MathMutator]MSP[N] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.ABSMutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[N] d = results [ 0 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.CRCR4Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI1Mutator]MSP[N] }
c = c >>> 1 | c << 27 ; MST[rv.UOI3Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
s = s << 4 | s >>> 28 ; MST[rv.CRCR1Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; MST[NullReturnValsMutator]MSP[N] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[rv.CRCR5Mutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI3Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR2Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = c >>> 1 | c << 27 ; MST[rv.UOI2Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.ABSMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
c = results [ 1 ] ; MST[rv.UOI4Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.CRCR3Mutator]MSP[N] }
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; MST[ArgumentPropagationMutator]MSP[S] }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI2Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR5Mutator]MSP[N] right = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) { MST[NegateConditionalsMutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI3Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.ABSMutator]MSP[N] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[VoidMethodCallMutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.ROR2Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI2Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.UOI1Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.ABSMutator]MSP[N] }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.OBBN3Mutator]MSP[N] a ^= t << n ; b ^= t ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[ArgumentPropagationMutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR5Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ; MST[rv.UOI4Mutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI1Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.ABSMutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[InlineConstantMutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[InlineConstantMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[MathMutator]MSP[N] return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[InlineConstantMutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR3Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; MST[ReturnValsMutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR5Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR6Mutator]MSP[N] } else {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.ABSMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] key [ i ] = 0 ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; MST[rv.UOI3Mutator]MSP[N] right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI1Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR5Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR6Mutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.UOI2Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOR1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR6Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR5Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.CRCR3Mutator]MSP[N] return value ; }
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public static String crypt ( final String original ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOR1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[IncrementsMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR2Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR4Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; return a ; MST[rv.UOI2Mutator]MSP[N] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.UOI2Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR2Mutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR5Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.UOI1Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[rv.ABSMutator]MSP[N] }
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI1Mutator]MSP[N] a ^= t << n ; b ^= t ;
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI2Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.OBBN3Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR4Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN2Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR1Mutator]MSP[N]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI2Mutator]MSP[N] b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[MathMutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.ABSMutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR6Mutator]MSP[N] d &= 0xfffffff ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.CRCR5Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR2Mutator]MSP[N] if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[InlineConstantMutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.ABSMutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR4Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
left = results [ 1 ] ; MST[rv.CRCR5Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.UOI2Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI2Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
results [ 0 ] = a ; MST[rv.UOI3Mutator]MSP[N] results [ 1 ] = b ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
y ++ ; u = 128 ; MST[rv.CRCR6Mutator]MSP[N] } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.UOI3Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.CRCR1Mutator]MSP[N] right = results [ 0 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[InlineConstantMutator]MSP[N] return out ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR6Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOD2Mutator]MSP[N] return a ; }
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final char charOne = salt . charAt ( 1 ) ; MST[rv.CRCR6Mutator]MSP[N] buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR1Mutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI4Mutator]MSP[N] }
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR2Mutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.UOI1Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.UOI2Mutator]MSP[N] return out ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] key [ i ] = 0 ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR2Mutator]MSP[N] d = results [ 0 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; MST[rv.UOI3Mutator]MSP[N] left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[NonVoidMethodCallMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI3Mutator]MSP[N] }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN3Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI4Mutator]MSP[N] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR5Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = results [ 1 ] ; MST[rv.CRCR6Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[experimental.RemoveIncrementsMutator]MSP[N] return value ; }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI2Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI1Mutator]MSP[N] return value < 0 ? value + 256 : value ; }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ROR5Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR1Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.UOI2Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
s = s << 4 | s >>> 28 ; MST[rv.UOI1Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.UOI4Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.UOI2Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; MST[rv.CRCR3Mutator]MSP[N] int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[PrimitiveReturnsMutator]MSP[N] }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.ABSMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[InlineConstantMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOR3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.ABSMutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[MathMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR4Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; v &= e1 ; MST[rv.OBBN2Mutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.ABSMutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[N]
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR5Mutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.CRCR6Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR2Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.CRCR1Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ; MST[rv.CRCR3Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[rv.UOI2Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.OBBN1Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
int c = 0 ; for (; j < 6 ; j ++ ) { MST[experimental.RemoveIncrementsMutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.ABSMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR5Mutator]MSP[N] }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.UOI3Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI4Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR6Mutator]MSP[N] int j = 0 ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[NonVoidMethodCallMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI4Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; MST[rv.CRCR1Mutator]MSP[N] buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( int j = 0 ; j < 25 ; j ++ ) {
intToFourBytes ( out [ 1 ] , b , 4 ) ; MST[rv.CRCR5Mutator]MSP[N] b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR2Mutator]MSP[N]
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[MathMutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[N] return a ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] key [ i ] = 0 ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[N] a ^= t << n ; b ^= t ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI3Mutator]MSP[N]
left = t >>> 1 | t << 31 ; MST[rv.CRCR6Mutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[InlineConstantMutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR2Mutator]MSP[N]
return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; }
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.ABSMutator]MSP[N] b ^= t ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[VoidMethodCallMutator]MSP[N] d = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR3Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int schedule [] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] int d = fourBytesToInt ( key , 4 ) ; final int results [] = new int [ 2 ] ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI1Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.OBBN3Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.CRCR4Mutator]MSP[N] final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.ABSMutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.UOI3Mutator]MSP[N] }
y ++ ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; MST[rv.UOI1Mutator]MSP[N] } } return buffer . toString () ; } public static String crypt ( final String original ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI4Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; MST[rv.ABSMutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[MathMutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI1Mutator]MSP[N] }
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; MST[ReturnValsMutator]MSP[N] } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[NonVoidMethodCallMutator]MSP[N] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.ABSMutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; MST[rv.UOI4Mutator]MSP[N] } t = right ; right = left >>> 1 | left << 31 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR6Mutator]MSP[N]
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.UOI4Mutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.CRCR5Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; MST[InlineConstantMutator]MSP[N] permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI4Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI3Mutator]MSP[N] return value ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR6Mutator]MSP[N] t = t >>> 4 | t << 28 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.ROR4Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ; MST[rv.CRCR5Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR5Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ; MST[rv.CRCR3Mutator]MSP[N]
c = results [ 1 ] ; MST[rv.ABSMutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI3Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.AOD1Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI2Mutator]MSP[N] b ^= t ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; MST[ReturnValsMutator]MSP[N] }
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR6Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
public static String crypt ( final byte [] original ) { return crypt ( original , null ) ; } public static String crypt ( final byte [] original , String salt ) { if ( salt == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current () ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR6Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; MST[rv.CRCR1Mutator]MSP[N] int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.UOI2Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI4Mutator]MSP[N]
results [ 0 ] = a ; MST[rv.CRCR5Mutator]MSP[N] results [ 1 ] = b ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.UOI2Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.UOI1Mutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
y ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . toString () ; } public static String crypt ( final String original ) {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.UOI2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.CRCR6Mutator]MSP[N]
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.AOD2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI3Mutator]MSP[N] right = results [ 0 ] ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; MST[rv.UOI4Mutator]MSP[N] out [ 1 ] = right ; return out ; }
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ABSMutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.ABSMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[InlineConstantMutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.CRCR1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.CRCR3Mutator]MSP[N] d = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[MathMutator]MSP[N] } else {
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR5Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR2Mutator]MSP[N] } else {
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI1Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.CRCR3Mutator]MSP[N] } else {
c = c >>> 1 | c << 27 ; MST[rv.CRCR6Mutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[NonVoidMethodCallMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.CRCR2Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] int j = 0 ;
right = results [ 0 ] ; left = results [ 1 ] ; final int out [] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; MST[rv.CRCR4Mutator]MSP[N] return out ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.UOI1Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; MST[rv.UOI2Mutator]MSP[N] final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.ABSMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.UOI3Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; MST[rv.UOI2Mutator]MSP[N] right = results [ 0 ] ;
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; MST[rv.UOI4Mutator]MSP[N] right = results [ 0 ] ; left = results [ 1 ] ;
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; MST[rv.CRCR1Mutator]MSP[N] int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; MST[InlineConstantMutator]MSP[N] if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[InlineConstantMutator]MSP[N] left = results [ 1 ] ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.CRCR5Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.UOI3Mutator]MSP[N] d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[InlineConstantMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.AOR3Mutator]MSP[N] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI3Mutator]MSP[N] t = t >>> 4 | t << 28 ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; MST[rv.CRCR6Mutator]MSP[N] int u = v & e0 ; v &= e1 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] c = results [ 1 ] ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[MathMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI4Mutator]MSP[N]
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.ABSMutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[experimental.NakedReceiverMutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
c = c >>> 1 | c << 27 ; MST[MathMutator]MSP[N] d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.UOI4Mutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.CRCR5Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { MST[rv.ABSMutator]MSP[N] c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[InlineConstantMutator]MSP[N] d = results [ 0 ] ; c = results [ 1 ] ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; MST[rv.ABSMutator]MSP[N] key [ i ] = (byte) ( iChar << 1 ) ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[MathMutator]MSP[N]
s = s << 4 | s >>> 28 ; schedule [ j ++ ] = s ; MST[rv.UOI3Mutator]MSP[N] } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[InlineConstantMutator]MSP[N] }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; MST[rv.ABSMutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[VoidMethodCallMutator]MSP[N]
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR6Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[PrimitiveReturnsMutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; MST[rv.UOI1Mutator]MSP[N] b ^= t ;
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; MST[rv.CRCR6Mutator]MSP[N] int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) {
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
s = s << 4 | s >>> 28 ; MST[rv.OBBN1Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[rv.ROR5Mutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.CRCR3Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; MST[rv.CRCR4Mutator]MSP[N] int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[rv.CRCR3Mutator]MSP[N] int j = 0 ;
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { throw new IllegalArgumentException ( lr_4 + salt ) ; MST[experimental.NakedReceiverMutator]MSP[S] } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
final int numSaltChars = SALT_CHARS . length ; salt = lr_1 + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + MST[rv.UOI2Mutator]MSP[N] SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.ABSMutator]MSP[N] return a ; }
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN2Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[IncrementsMutator]MSP[N] int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.CRCR2Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] int j = 0 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.UOI4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.OBBN1Mutator]MSP[N] return value ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; MST[rv.CRCR6Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
left = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.AOD1Mutator]MSP[N] t = t >>> 4 | t << 28 ;
SPTRANS [ 4 ] [ u >>> 16 & 0x3f ] | SPTRANS [ 6 ] [ u >>> 24 & 0x3f ] ; return el ; MST[rv.UOI4Mutator]MSP[N] } private static int [] desSetKey ( final byte key [] ) {
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.UOI1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; a = a ^ t ^ t >>> 16 - n ; MST[rv.UOI1Mutator]MSP[N] return a ; }
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; MST[rv.CRCR4Mutator]MSP[N] t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.OBBN1Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR1Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[MathMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.CRCR4Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
d = hPermOp ( d , - 2 , 0xcccc0000 ) ; MST[rv.UOI4Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR5Mutator]MSP[N]
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ; MST[rv.CRCR4Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; MST[rv.UOI3Mutator]MSP[N] a ^= t << n ; b ^= t ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.ABSMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[MathMutator]MSP[N] d &= 0xfffffff ;
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.UOI4Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
} else if ( ! salt . matches ( lr_2 + B64 . B64T_STRING + lr_3 ) ) { MST[NegateConditionalsMutator]MSP[N] throw new IllegalArgumentException ( lr_4 + salt ) ; } final StringBuilder buffer = new StringBuilder ( lr_5 ) ; final char charZero = salt . charAt ( 0 ) ;
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { MST[rv.UOI3Mutator]MSP[N] c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[MathMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
final byte key [] = new byte [ 8 ] ; MST[InlineConstantMutator]MSP[N] for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; }
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR6Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR2Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
u = u ^ u << 16 ^ r ^ sArr [ s ] ; int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ; MST[rv.UOI2Mutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; MST[rv.CRCR3Mutator]MSP[N] d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; MST[rv.OBBN3Mutator]MSP[N] } u >>>= 1 ; if ( u == 0 ) {
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.ABSMutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI4Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.ABSMutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.OBBN1Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; MST[InlineConstantMutator]MSP[N]
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.CRCR5Mutator]MSP[N] if ( u == 0 ) {
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR5Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; MST[rv.CRCR3Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; MST[rv.CRCR1Mutator]MSP[N] d = d >>> 2 | d << 26 ; } else {
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.OBBN3Mutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.ABSMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR6Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.OBBN1Mutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[rv.ABSMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[IncrementsMutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.UOI2Mutator]MSP[N]
final int schedule [] = desSetKey ( key ) ; final int out [] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [] = new byte [ 9 ] ; MST[rv.CRCR5Mutator]MSP[N] intToFourBytes ( out [ 0 ] , b , 0 ) ;
private static void permOp ( int a , int b , final int n , final int m , final int results [] ) { final int t = ( a >>> n ^ b ) & m ; a ^= t << n ; b ^= t ; MST[rv.UOI3Mutator]MSP[N]
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; MST[MathMutator]MSP[N] int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; MST[rv.CRCR2Mutator]MSP[N] permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR5Mutator]MSP[N]
c = results [ 1 ] ; MST[rv.CRCR3Mutator]MSP[N] d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; c &= 0xfffffff ; int j = 0 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[MathMutator]MSP[N] }
private static int byteToUnsigned ( final byte b ) { final int value = b ; MST[rv.UOI4Mutator]MSP[N] return value < 0 ? value + 256 : value ; }
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[rv.OBBN3Mutator]MSP[N]
private static int [] body ( final int schedule [] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int t = 0 ; for ( int j = 0 ; j < 25 ; j ++ ) { MST[rv.CRCR3Mutator]MSP[N]
u = u ^ u << 16 ^ r ^ sArr [ s ] ; MST[rv.UOI1Mutator]MSP[N] int t = v ^ v << 16 ^ r ^ sArr [ s + 1 ] ; t = t >>> 4 | t << 28 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.CRCR3Mutator]MSP[N] }
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; MST[rv.UOI3Mutator]MSP[N] return value ; }
private static int hPermOp ( int a , final int n , final int m ) { final int t = ( a << 16 - n ^ a ) & m ; MST[rv.UOI3Mutator]MSP[N] a = a ^ t ^ t >>> 16 - n ; return a ; }
left = t >>> 1 | t << 31 ; final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; MST[rv.UOI3Mutator]MSP[N] left = results [ 1 ] ;
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ;
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; MST[rv.OBBN3Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for (; i < 13 ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] int j = 0 ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[InlineConstantMutator]MSP[N]
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; } c &= 0xfffffff ; d &= 0xfffffff ; MST[rv.OBBN1Mutator]MSP[N]
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.CRCR4Mutator]MSP[N]
private static void intToFourBytes ( final int iValue , final byte b [] , int offset ) { b [ offset ++ ] = (byte) ( iValue & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 8 & 0xff ) ; MST[rv.ABSMutator]MSP[N]
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.UOI1Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.ABSMutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.CRCR4Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.OBBN3Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
c = c >>> 1 | c << 27 ; d = d >>> 1 | d << 27 ; MST[rv.CRCR5Mutator]MSP[N] } c &= 0xfffffff ; d &= 0xfffffff ;
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR6Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[InlineConstantMutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
value |= byteToUnsigned ( b [ offset ++ ] ) << 8 ; value |= byteToUnsigned ( b [ offset ++ ] ) << 16 ; MST[rv.UOI4Mutator]MSP[N] value |= byteToUnsigned ( b [ offset ++ ] ) << 24 ; return value ; }
left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; MST[rv.CRCR1Mutator]MSP[N]
intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; MST[rv.CRCR1Mutator]MSP[N] for (; i < 13 ; i ++ ) { int j = 0 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; MST[rv.UOI3Mutator]MSP[N] d = results [ 0 ] ;
left = t >>> 1 | t << 31 ; MST[MathMutator]MSP[N] final int results [] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ;
el ^= SPTRANS [ 1 ] [ t & 0x3f ] | SPTRANS [ 3 ] [ t >>> 8 & 0x3f ] | SPTRANS [ 5 ] [ t >>> 16 & 0x3f ] | MST[rv.CRCR2Mutator]MSP[N]
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.CRCR4Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; s = s >>> 16 | t & 0xffff0000 ; MST[MathMutator]MSP[N]
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; MST[rv.UOI3Mutator]MSP[N] final int eSwap1 = CON_SALT [ charOne ] << 4 ;
permOp ( c , d , 8 , 0xff00ff , results ) ; MST[rv.UOI2Mutator]MSP[N] c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ;
SKB [ 7 ] [ d >>> 21 & 0xf | d >>> 22 & 0x30 ] ; schedule [ j ++ ] = ( t << 16 | s & 0xffff ) ; MST[rv.UOI2Mutator]MSP[N] s = s >>> 16 | t & 0xffff0000 ;
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.CRCR2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; MST[rv.UOI1Mutator]MSP[N] final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] << 4 ;
results [ 0 ] = a ; results [ 1 ] = b ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
final byte key [] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i ++ ) { key [ i ] = 0 ; MST[InlineConstantMutator]MSP[N] }
final int t = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d >>> 7 & 0x3 | d >>> 8 & 0x3c ] | SKB [ 6 ] [ d >>> 15 & 0x3f ] | MST[rv.OBBN1Mutator]MSP[N]
for ( int i = 0 ; i < 16 ; i ++ ) { MST[rv.CRCR2Mutator]MSP[N] if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; } else {
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.CRCR1Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; MST[rv.UOI1Mutator]MSP[N] }
for ( int i = 0 ; i < 32 ; i += 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; MST[rv.ABSMutator]MSP[N]
int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c >>> 6 & 0x3 | c >>> 7 & 0x3c ] | MST[rv.UOI4Mutator]MSP[N] SKB [ 2 ] [ c >>> 13 & 0xf | c >>> 14 & 0x30 ] |
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[MathMutator]MSP[N] }
int c = 0 ; for (; j < 6 ; j ++ ) { c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; MST[rv.ABSMutator]MSP[N] if ( u == 0 ) {
for ( int i = 0 ; i < 32 ; i += 4 ) { MST[rv.CRCR2Mutator]MSP[N] left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR6Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
c = results [ 1 ] ; d = ( d & 0xff ) << 16 | d & 0xff00 | ( d & 0xff0000 ) >>> 16 | ( c & 0xf0000000 ) >>> 4 ; MST[InlineConstantMutator]MSP[N] c &= 0xfffffff ; int j = 0 ;
s = s << 4 | s >>> 28 ; MST[rv.CRCR5Mutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; }
int c = 0 ; for (; j < 6 ; j ++ ) { MST[rv.CRCR2Mutator]MSP[N] c <<= 1 ; if ( ( b [ y ] & u ) != 0 ) { c |= 0x1 ; } u >>>= 1 ; if ( u == 0 ) {
permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; MST[rv.UOI4Mutator]MSP[N] right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; MST[rv.ROR2Mutator]MSP[N] }
right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; MST[rv.UOI2Mutator]MSP[N] } t = left ; left = right ; right = t ; } t = right ; right = left >>> 1 | left << 31 ;
b [ offset ++ ] = (byte) ( iValue >>> 16 & 0xff ) ; MST[rv.UOI2Mutator]MSP[N] b [ offset ++ ] = (byte) ( iValue >>> 24 & 0xff ) ; }
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI2Mutator]MSP[N] } else {
for ( int i = 0 ; i < 16 ; i ++ ) { if ( SHIFT2 [ i ] ) { c = c >>> 2 | c << 26 ; d = d >>> 2 | d << 26 ; MST[rv.UOI3Mutator]MSP[N] } else {
s = s << 4 | s >>> 28 ; MST[rv.ABSMutator]MSP[N] schedule [ j ++ ] = s ; } return schedule ; } private static int fourBytesToInt ( final byte b [] , int offset ) { int value = byteToUnsigned ( b [ offset ++ ] ) ;
for ( int i = 0 ; i < key . length && i < original . length ; i ++ ) { final int iChar = original [ i ] ; key [ i ] = (byte) ( iChar << 1 ) ; MST[rv.CRCR3Mutator]MSP[N] }
permOp ( left , right , 8 , 0xff00ff , results ) ; MST[rv.UOI1Mutator]MSP[N] left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ;
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [] ) { int v = r ^ r >>> 16 ; int u = v & e0 ; MST[rv.UOI3Mutator]MSP[N] v &= e1 ;
Converter select ( Class < ? > type ) throws IllegalStateException { Entry [] entries = iSelectEntries ; int length = entries . length ; int index = type == null ? 0 : type . hashCode () & ( length - 1 ) ; Entry e ;
while ( ( e = entries [ index ] ) != null ) { if ( e . iType == type ) { return e . iConverter ; } if ( ++ index >= length ) { index = 0 ; } }
Converter converter = selectSlow ( this , type ) ; e = new Entry ( type , converter ) ; entries = ( Entry [] ) entries . clone () ; entries [ index ] = e ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ;
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) {
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
ConverterSet remove ( final int index , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; if ( index >= length ) { throw new IndexOutOfBoundsException () ; } if ( removed != null ) {
removed [ 0 ] = converters [ index ] ; } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
copy [ j ++ ] = converters [ i ] ; } } return new ConverterSet ( copy ) ; } private static Converter selectSlow ( ConverterSet set , Class < ? > type ) { Converter [] converters = set . iConverters ;
int length = converters . length ; Converter converter ; for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; if ( supportedType == type ) {
return converter ; } if ( supportedType == null || ( type != null && ! supportedType . isAssignableFrom ( type ) ) ) { set = set . remove ( i , null ) ; converters = set . iConverters ; length = converters . length ; } }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ;
msg . append ( supportedType == null ? null : supportedType . getName () ) ; msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( converters [ i ] ) ) { MST[rv.ROR2Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI4Mutator]MSP[N]
copy [ j ] = converter ; MST[rv.UOI3Mutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] Converter existing = converters [ i ] ;
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; MST[ReturnValsMutator]MSP[N] } if ( converter . getSupportedType () == existing . getSupportedType () ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; MST[rv.UOI1Mutator]MSP[N] } else {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[IncrementsMutator]MSP[N] converter = converters [ i ] ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { MST[rv.UOI1Mutator]MSP[N] if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[InlineConstantMutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] Converter existing = converters [ i ] ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI1Mutator]MSP[N] converter = converters [ i ] ;
if ( converter . equals ( existing ) ) { MST[rv.ROR2Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ; MST[rv.ABSMutator]MSP[S]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR6Mutator]MSP[N] } return new ConverterSet ( copy ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.AOD2Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N] Converter existing = converters [ i ] ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ; MST[rv.UOI3Mutator]MSP[N]
removed [ 0 ] = converters [ index ] ; MST[rv.UOI2Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
Entry [] newEntries = new Entry [ newLength ] ; MST[rv.UOI2Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR2Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI1Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
removed [ 0 ] = converters [ index ] ; MST[rv.ABSMutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.CRCR3Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI3Mutator]MSP[N]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI3Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR5Mutator]MSP[N] }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[ConditionalsBoundaryMutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[experimental.NakedReceiverMutator]MSP[N]
msg . append ( supportedType == null ? null : supportedType . getName () ) ; msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR4Mutator]MSP[N]
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR3Mutator]MSP[N] } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ; MST[rv.UOI2Mutator]MSP[N]
set = set . remove ( j , null ) ; MST[rv.ABSMutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] Converter existing = converters [ i ] ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ABSMutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; MST[rv.UOI1Mutator]MSP[N] } else {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; MST[rv.UOI3Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.ROR5Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.UOI3Mutator]MSP[S] index = 0 ; } } newEntries [ index ] = e ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ABSMutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
if ( converter . equals ( converters [ i ] ) ) { MST[rv.UOI4Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; MST[rv.UOI3Mutator]MSP[N] for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ROR2Mutator]MSP[N] converter = converters [ i ] ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR5Mutator]MSP[S]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[rv.ABSMutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] Converter existing = converters [ i ] ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; MST[rv.CRCR3Mutator]MSP[N] } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ROR3Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[IncrementsMutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.ABSMutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.ROR2Mutator]MSP[N] return converters [ 0 ] ; }
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[rv.CRCR6Mutator]MSP[N]
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.CRCR4Mutator]MSP[N]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
if ( converter . equals ( converters [ i ] ) ) { MST[rv.UOI1Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.UOI2Mutator]MSP[N] return converters [ 0 ] ; }
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR5Mutator]MSP[N] }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI3Mutator]MSP[N] converter = converters [ i ] ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.CRCR5Mutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.UOI3Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[experimental.RemoveIncrementsMutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[NegateConditionalsMutator]MSP[N] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; MST[rv.ABSMutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[IncrementsMutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { MST[rv.ROR5Mutator]MSP[S] removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[rv.ROR5Mutator]MSP[S] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.UOI4Mutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S]
while ( ( e = entries [ index ] ) != null ) { if ( e . iType == type ) { return e . iConverter ; } if ( ++ index >= length ) { index = 0 ; MST[InlineConstantMutator]MSP[S] } }
if ( converter . equals ( converters [ i ] ) ) { MST[rv.ROR5Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[experimental.NakedReceiverMutator]MSP[N] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.UOI3Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { MST[rv.ROR5Mutator]MSP[S] removed [ 0 ] = null ; } return this ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] converter = converters [ i ] ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR1Mutator]MSP[N] } return new ConverterSet ( copy ) ; }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.AOR2Mutator]MSP[N]
if ( converter . equals ( existing ) ) { MST[rv.ROR5Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[MathMutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ABSMutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.OBBN2Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; MST[rv.CRCR6Mutator]MSP[N] } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[InlineConstantMutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[InlineConstantMutator]MSP[N] return converters [ 0 ] ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] e = entries [ i ] ; type = e . iType ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ROR4Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI4Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR5Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.ROR4Mutator]MSP[N] return converters [ 0 ] ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[IncrementsMutator]MSP[S] index = 0 ; } } newEntries [ index ] = e ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[S] e = entries [ i ] ; type = e . iType ;
Entry [] newEntries = new Entry [ newLength ] ; MST[rv.ABSMutator]MSP[S] for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
set = set . remove ( j , null ) ; MST[NonVoidMethodCallMutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR6Mutator]MSP[N] } return this ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.CRCR2Mutator]MSP[N] return converters [ 0 ] ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR1Mutator]MSP[N]
StringBuilder msg = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR1Mutator]MSP[S] } return this ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[NegateConditionalsMutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; MST[rv.UOI2Mutator]MSP[N]
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.UOI1Mutator]MSP[N]
removed [ 0 ] = converters [ index ] ; MST[rv.CRCR1Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.AOR4Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return converters [ 0 ] ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.UOI2Mutator]MSP[N]
set = set . remove ( j , null ) ; MST[rv.UOI2Mutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; MST[rv.ABSMutator]MSP[S] type = e . iType ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[InlineConstantMutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI2Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR5Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[NegateConditionalsMutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.AOR2Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
removed [ 0 ] = converters [ index ] ; MST[rv.CRCR6Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] e = entries [ i ] ; type = e . iType ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] e = entries [ i ] ; type = e . iType ;
copy [ j ] = converter ; } } if ( removed != null ) { MST[rv.ROR5Mutator]MSP[N] removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[IncrementsMutator]MSP[S] e = entries [ i ] ; type = e . iType ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI2Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] Converter existing = converters [ i ] ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI1Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.ABSMutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.UOI3Mutator]MSP[N] return converters [ 0 ] ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] Converter existing = converters [ i ] ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.UOI4Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.OBBN3Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( existing ) ) { if ( removed != null ) { MST[rv.ROR5Mutator]MSP[S] removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.UOI3Mutator]MSP[S]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ROR1Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; MST[rv.CRCR1Mutator]MSP[N] } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; MST[ConstructorCallMutator]MSP[N] } } Converter [] copy = new Converter [ length + 1 ] ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] e = entries [ i ] ; type = e . iType ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] Converter existing = converters [ i ] ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; MST[rv.UOI2Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( '[' ) ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.CRCR2Mutator]MSP[N]
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[rv.CRCR4Mutator]MSP[N]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[NegateConditionalsMutator]MSP[N] return converters [ 0 ] ; }
Converter [] copy = new Converter [ length ] ; MST[rv.UOI2Mutator]MSP[N] for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ABSMutator]MSP[N] converter = converters [ i ] ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[NegateConditionalsMutator]MSP[N]
if ( converter . equals ( existing ) ) { MST[NegateConditionalsMutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
if ( converter . equals ( converters [ i ] ) ) { MST[rv.ABSMutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR6Mutator]MSP[N] } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.CRCR3Mutator]MSP[N] return converters [ 0 ] ; }
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR1Mutator]MSP[N] } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] converter = converters [ i ] ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[InlineConstantMutator]MSP[S] Converter existing = converters [ i ] ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI2Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.UOI1Mutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[NegateConditionalsMutator]MSP[N] converter = converters [ i ] ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[S] e = entries [ i ] ; type = e . iType ;
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { MST[NegateConditionalsMutator]MSP[S] removed [ 0 ] = null ; } return this ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.ROR5Mutator]MSP[N] return converters [ 0 ] ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.UOI1Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[ReturnValsMutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[InlineConstantMutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
removed [ 0 ] = converters [ index ] ; MST[rv.UOI4Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[VoidMethodCallMutator]MSP[N] }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { MST[rv.UOI4Mutator]MSP[S] if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { MST[NegateConditionalsMutator]MSP[S] removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI2Mutator]MSP[N]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ROR2Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
if ( converter . equals ( converters [ i ] ) ) { MST[NegateConditionalsMutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.UOI1Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; MST[NullReturnValsMutator]MSP[N] } } Converter [] copy = new Converter [ length + 1 ] ;
converter = converters [ i ] ; MST[rv.ABSMutator]MSP[N] Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ;
msg . append ( supportedType == null ? null : supportedType . getName () ) ; msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; MST[ConstructorCallMutator]MSP[N] }
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.ABSMutator]MSP[S]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.ROR5Mutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] Converter existing = converters [ i ] ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] Converter existing = converters [ i ] ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.CRCR5Mutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.UOI2Mutator]MSP[S] index = 0 ; } } newEntries [ index ] = e ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI4Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI2Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
if ( converter . equals ( converters [ i ] ) ) { MST[rv.ROR3Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[NullReturnValsMutator]MSP[N] }
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[rv.UOI3Mutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[rv.UOI1Mutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
removed [ 0 ] = converters [ index ] ; MST[InlineConstantMutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) { MST[NegateConditionalsMutator]MSP[N]
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.AOD2Mutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; MST[ConstructorCallMutator]MSP[N] }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ; MST[rv.UOI4Mutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[S] e = entries [ i ] ; type = e . iType ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR5Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.AOD1Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.UOI3Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR3Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI1Mutator]MSP[N] converter = converters [ i ] ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] Converter existing = converters [ i ] ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.UOI1Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ROR5Mutator]MSP[N] converter = converters [ i ] ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI4Mutator]MSP[N] converter = converters [ i ] ;
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; MST[ReturnValsMutator]MSP[N] } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[ConditionalsBoundaryMutator]MSP[N] converter = converters [ i ] ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[InlineConstantMutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[MathMutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( existing ) ) { if ( removed != null ) { MST[NegateConditionalsMutator]MSP[N] removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[InlineConstantMutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.CRCR5Mutator]MSP[N] return converters [ 0 ] ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI4Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ABSMutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
removed [ 0 ] = converters [ index ] ; MST[rv.CRCR3Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.ABSMutator]MSP[N] return converters [ 0 ] ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[InlineConstantMutator]MSP[S]
msg . append ( supportedType == null ? null : supportedType . getName () ) ; msg . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } throw new IllegalStateException ( msg . toString () ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.AOR2Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
if ( converter . equals ( existing ) ) { MST[rv.ROR3Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] copy [ j ] = converters [ j ] ; } else {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; MST[NullReturnValsMutator]MSP[N] }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] }
converter = converters [ i ] ; MST[rv.UOI3Mutator]MSP[N] Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ;
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR3Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
copy [ j ] = converter ; } } if ( removed != null ) { MST[NegateConditionalsMutator]MSP[N] removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; MST[rv.UOI4Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] Converter existing = converters [ i ] ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI1Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.CRCR6Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] Converter existing = converters [ i ] ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[InlineConstantMutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) { MST[rv.ROR5Mutator]MSP[N]
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.AOR4Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR3Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
Converter [] copy = new Converter [ length ] ; MST[rv.UOI4Mutator]MSP[N] for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; MST[ReturnValsMutator]MSP[N] }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] Converter existing = converters [ i ] ;
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; MST[InlineConstantMutator]MSP[N] } return this ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N] Converter existing = converters [ i ] ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI3Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR6Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI3Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.UOI1Mutator]MSP[N] return converters [ 0 ] ; }
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI4Mutator]MSP[N] converter = converters [ i ] ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[InlineConstantMutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
converter = converters [ i ] ; MST[rv.UOI1Mutator]MSP[N] Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return converters [ 0 ] ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[MathMutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] Converter existing = converters [ i ] ;
copy [ j ] = converter ; } } if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ABSMutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[NegateConditionalsMutator]MSP[N]
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR1Mutator]MSP[N] }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[NegateConditionalsMutator]MSP[S] copy [ j ] = converters [ j ] ; } else {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.UOI3Mutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.ABSMutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[InlineConstantMutator]MSP[N] }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR5Mutator]MSP[N]
if ( converter . equals ( existing ) ) { if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.CRCR2Mutator]MSP[S] } } } if ( length == 1 ) { return converters [ 0 ] ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ROR5Mutator]MSP[S] copy [ j ] = converters [ j ] ; } else {
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; MST[ReturnValsMutator]MSP[N] } } Converter [] copy = new Converter [ length + 1 ] ;
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[NonVoidMethodCallMutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { MST[rv.ABSMutator]MSP[N] if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.UOI3Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.AOR3Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
removed [ 0 ] = converters [ index ] ; MST[rv.CRCR5Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
converter = converters [ i ] ; MST[rv.UOI4Mutator]MSP[N] Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; MST[InlineConstantMutator]MSP[N] } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.UOI1Mutator]MSP[S]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
Entry [] newEntries = new Entry [ newLength ] ; MST[rv.UOI3Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ;
} iSelectEntries = newEntries ; return converter ; MST[ReturnValsMutator]MSP[S] } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.CRCR6Mutator]MSP[N] return converters [ 0 ] ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
ConverterSet remove ( final int index , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; if ( index >= length ) { throw new IndexOutOfBoundsException () ; MST[ConstructorCallMutator]MSP[S] } if ( removed != null ) {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR1Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[S] e = entries [ i ] ; type = e . iType ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.AOR3Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI2Mutator]MSP[N] converter = converters [ i ] ;
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; MST[InlineConstantMutator]MSP[N] } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
if ( converter . equals ( converters [ i ] ) ) { MST[rv.ROR1Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; MST[rv.UOI3Mutator]MSP[S] type = e . iType ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.ROR1Mutator]MSP[S] index = 0 ; } } newEntries [ index ] = e ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI3Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; MST[rv.ABSMutator]MSP[N] } else {
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.CRCR3Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI1Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.ABSMutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.CRCR4Mutator]MSP[S]
if ( converter . equals ( existing ) ) { MST[rv.ROR1Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
if ( converter . equals ( existing ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR5Mutator]MSP[N] } return new ConverterSet ( copy ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.AOD1Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; MST[PrimitiveReturnsMutator]MSP[N] } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; }
set = set . remove ( j , null ) ; MST[rv.UOI3Mutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[InlineConstantMutator]MSP[S]
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; MST[rv.ABSMutator]MSP[N] } else {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.CRCR4Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] Converter existing = converters [ i ] ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { MST[rv.UOI2Mutator]MSP[S] if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.ABSMutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
removed [ 0 ] = converters [ index ] ; MST[rv.UOI1Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
if ( converter . equals ( converters [ i ] ) ) { MST[rv.UOI3Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; MST[rv.UOI3Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR1Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
} iSelectEntries = newEntries ; MST[experimental.MemberVariableMutator]MSP[S] return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; }
if ( converter . equals ( converters [ i ] ) ) { MST[NonVoidMethodCallMutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ABSMutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ; MST[rv.UOI3Mutator]MSP[S]
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[rv.CRCR2Mutator]MSP[N]
msg . append ( supportedType == null ? null : supportedType . getName () ) ; msg . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } throw new IllegalStateException ( msg . toString () ) ; }
if ( converter . equals ( existing ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ROR3Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; MST[rv.UOI3Mutator]MSP[N] } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI4Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; MST[rv.UOI1Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
Converter [] copy = new Converter [ length ] ; MST[rv.UOI1Mutator]MSP[N] for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR6Mutator]MSP[N] }
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.CRCR6Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.ROR3Mutator]MSP[N] return converters [ 0 ] ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.UOI4Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[MathMutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.UOI2Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.AOR1Mutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.OBBN1Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( converters [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ROR4Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR3Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ; MST[rv.UOI1Mutator]MSP[N]
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] removed [ 0 ] = null ; } return this ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI1Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[experimental.RemoveIncrementsMutator]MSP[N] converter = converters [ i ] ;
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR1Mutator]MSP[N] }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] copy [ j ] = converters [ j ] ; } else {
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ROR3Mutator]MSP[N] converter = converters [ i ] ;
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; MST[experimental.NakedReceiverMutator]MSP[S] msg . append ( '[' ) ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; MST[rv.UOI4Mutator]MSP[S] type = e . iType ;
copy [ j ] = converter ; } } if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR2Mutator]MSP[N]
copy [ j ] = converter ; MST[rv.UOI1Mutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; MST[rv.UOI3Mutator]MSP[N] } else {
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( '[' ) ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { MST[rv.UOI3Mutator]MSP[N] if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; MST[rv.ABSMutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.AOR3Mutator]MSP[N]
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI2Mutator]MSP[N] converter = converters [ i ] ;
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.UOI3Mutator]MSP[N] converter = converters [ i ] ;
Converter [] copy = new Converter [ length ] ; MST[rv.ABSMutator]MSP[N] for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; MST[rv.CRCR5Mutator]MSP[N] } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
set = set . remove ( j , null ) ; MST[rv.UOI4Mutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
if ( converter . equals ( existing ) ) { if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ABSMutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] Converter existing = converters [ i ] ;
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.CRCR6Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] Converter existing = converters [ i ] ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI4Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[rv.UOI4Mutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ROR5Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.CRCR4Mutator]MSP[N] return converters [ 0 ] ; }
Class < ? > supportedType = converter . getSupportedType () ; MST[NonVoidMethodCallMutator]MSP[N] for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.CRCR3Mutator]MSP[N]
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.UOI2Mutator]MSP[N]
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR3Mutator]MSP[N] }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.AOR1Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[NullReturnValsMutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.UOI4Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ; MST[rv.UOI4Mutator]MSP[N]
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[IncrementsMutator]MSP[N] Converter existing = converters [ i ] ;
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( '[' ) ;
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR5Mutator]MSP[S] } return this ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; MST[rv.UOI4Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.AOR1Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ROR4Mutator]MSP[N] converter = converters [ i ] ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; MST[experimental.NakedReceiverMutator]MSP[N] msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) {
if ( converter . equals ( existing ) ) { MST[rv.ROR4Mutator]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR2Mutator]MSP[S]
set = set . remove ( j , null ) ; MST[rv.UOI1Mutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR4Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI2Mutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.CRCR5Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] Converter existing = converters [ i ] ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI2Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { MST[rv.UOI1Mutator]MSP[N] index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( converters [ i ] ) ) { MST[rv.ROR4Mutator]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; MST[ReturnValsMutator]MSP[N] }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { converter = converters [ i ] ; MST[rv.UOI1Mutator]MSP[N]
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[InlineConstantMutator]MSP[N] e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[IncrementsMutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; MST[rv.UOI1Mutator]MSP[N] type = e . iType ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[IncrementsMutator]MSP[N]
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[InlineConstantMutator]MSP[N] }
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[NonVoidMethodCallMutator]MSP[N] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR3Mutator]MSP[S] e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.UOI3Mutator]MSP[N]
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N] e = entries [ i ] ; type = e . iType ;
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI2Mutator]MSP[N]
if ( converter . equals ( converters [ i ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
} iSelectEntries = newEntries ; return converter ; MST[NullReturnValsMutator]MSP[N] } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[N]
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR5Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[NonVoidMethodCallMutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ROR4Mutator]MSP[N]
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ROR2Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
for ( int i = 0 ; i < length ; i ++ ) { if ( entries [ i ] == null ) { iSelectEntries = entries ; return converter ; } } int newLength = length << 1 ; MST[rv.UOI4Mutator]MSP[N]
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; MST[NullReturnValsMutator]MSP[N] } if ( converter . getSupportedType () == existing . getSupportedType () ) {
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.ABSMutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] Converter existing = converters [ i ] ;
Entry [] newEntries = new Entry [ newLength ] ; MST[rv.UOI1Mutator]MSP[N] for ( int i = 0 ; i < length ; i ++ ) { e = entries [ i ] ; type = e . iType ;
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR1Mutator]MSP[N]
copy [ j ] = converter ; MST[rv.ABSMutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ;
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.UOI4Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.ABSMutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.AOR4Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
msg . append ( supportedType == null ? null : supportedType . getName () ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] msg . append ( lr_3 ) ; } throw new IllegalStateException ( msg . toString () ) ; }
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] e = entries [ i ] ; type = e . iType ;
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.UOI4Mutator]MSP[N] return converters [ 0 ] ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ROR1Mutator]MSP[N] converter = converters [ i ] ;
Entry [] newEntries = new Entry [ newLength ] ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI4Mutator]MSP[S] e = entries [ i ] ; type = e . iType ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N]
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[InlineConstantMutator]MSP[N] }
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR5Mutator]MSP[S] } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[rv.ROR3Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; MST[ReturnValsMutator]MSP[N] }
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ; MST[rv.UOI1Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { Converter existing = converters [ i ] ; MST[rv.ABSMutator]MSP[N]
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; MST[rv.AOD2Mutator]MSP[N] } } } if ( length == 1 ) { return converters [ 0 ] ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
set = set . remove ( j , null ) ; converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { MST[rv.ROR1Mutator]MSP[N] return converters [ 0 ] ; }
ConverterSet remove ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.UOI3Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] Converter existing = converters [ i ] ;
if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) { MST[NonVoidMethodCallMutator]MSP[S]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[rv.UOI2Mutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR3Mutator]MSP[N] } return this ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ROR1Mutator]MSP[N] copy [ j ] = converters [ j ] ; } else {
if ( converter . equals ( existing ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( removed != null ) { removed [ 0 ] = null ; } return this ; } if ( converter . getSupportedType () == existing . getSupportedType () ) {
converter = converters [ i ] ; Class < ? > supportedType = converter . getSupportedType () ; msg . append ( converter . getClass () . getName () ) ; msg . append ( '[' ) ; MST[rv.CRCR5Mutator]MSP[N]
ConverterSet add ( Converter converter , Converter [] removed ) { Converter [] converters = iConverters ; int length = converters . length ; for ( int i = 0 ; i < length ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] Converter existing = converters [ i ] ;
StringBuilder msg = new StringBuilder () ; msg . append ( lr_1 ) ; msg . append ( type . getName () ) ; msg . append ( lr_2 ) ; for ( int i = 0 ; i < length ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N]
while ( ( e = entries [ index ] ) != null ) { if ( e . iType == type ) { return e . iConverter ; } if ( ++ index >= length ) { index = 0 ; MST[rv.CRCR1Mutator]MSP[S] } }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
set = set . remove ( j , null ) ; MST[experimental.NakedReceiverMutator]MSP[N] converters = set . iConverters ; length = converters . length ; i = length - 1 ; } } } if ( length == 1 ) { return converters [ 0 ] ; }
if ( type == null || length == 0 ) { return null ; } if ( length == 1 ) { return converters [ 0 ] ; } for ( int i = length ; -- i >= 0 ; ) { MST[rv.ABSMutator]MSP[N] converter = converters [ i ] ;
index = type == null ? 0 : type . hashCode () & ( newLength - 1 ) ; MST[rv.UOI2Mutator]MSP[N] while ( newEntries [ index ] != null ) { if ( ++ index >= newLength ) { index = 0 ; } } newEntries [ index ] = e ;
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; MST[NullReturnValsMutator]MSP[N] }
System . arraycopy ( converters , 0 , copy , 0 , length ) ; MST[VoidMethodCallMutator]MSP[N] copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; } return new ConverterSet ( copy ) ; }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.UOI4Mutator]MSP[N]
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; MST[rv.CRCR3Mutator]MSP[N] } return new ConverterSet ( copy ) ; }
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) { MST[NonVoidMethodCallMutator]MSP[N]
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; } } if ( removed != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] removed [ 0 ] = null ; } return this ; }
removed [ 0 ] = converters [ index ] ; MST[rv.UOI3Mutator]MSP[N] } Converter [] copy = new Converter [ length - 1 ] ; int j = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != index ) {
System . arraycopy ( converters , 0 , copy , 0 , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ 0 ] = null ; MST[InlineConstantMutator]MSP[N] } return new ConverterSet ( copy ) ; }
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { if ( j != i ) { MST[rv.ABSMutator]MSP[S] copy [ j ] = converters [ j ] ; } else {
Converter [] copy = new Converter [ length ] ; for ( int j = 0 ; j < length ; j ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( j != i ) { copy [ j ] = converters [ j ] ; } else {
Class < ? > supportedType = converter . getSupportedType () ; for ( int j = length ; -- j >= 0 ; ) { MST[rv.UOI3Mutator]MSP[N] if ( j != i && converters [ j ] . getSupportedType () . isAssignableFrom ( supportedType ) ) {
} iSelectEntries = newEntries ; return converter ; } int size () { return iConverters . length ; } void copyInto ( Converter [] converters ) { System . arraycopy ( iConverters , 0 , converters , 0 , iConverters . length ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( converter . equals ( converters [ i ] ) ) { return remove ( i , removed ) ; MST[rv.UOI2Mutator]MSP[N] } } if ( removed != null ) { removed [ 0 ] = null ; } return this ; }
copy [ j ] = converter ; } } if ( removed != null ) { removed [ 0 ] = existing ; } return new ConverterSet ( copy ) ; } } Converter [] copy = new Converter [ length + 1 ] ; MST[rv.AOD1Mutator]MSP[N]
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; }
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { return null ; }
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ;
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
public String getShortName ( Locale locale , String id , String nameKey , boolean standardTime ) { String [] nameSet = getNameSet ( locale , id , nameKey , standardTime ) ; return nameSet == null ? null : nameSet [ 0 ] ; }
public String getName ( Locale locale , String id , String nameKey , boolean standardTime ) { String [] nameSet = getNameSet ( locale , id , nameKey , standardTime ) ; return nameSet == null ? null : nameSet [ 1 ] ; }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey , boolean standardTime ) { if ( locale == null || id == null || nameKey == null ) { return null ; } if ( id . startsWith ( lr_2 ) ) {
id = id . substring ( 4 ) ; } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
Map < Boolean , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ;
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( Boolean . TRUE , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
byNameKeyCache . put ( Boolean . FALSE , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } return ( String [] ) byNameKeyCache . get ( Boolean . valueOf ( standardTime ) ) ; } private HashMap createCache () {
return new HashMap ( 7 ) ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[ConditionalsBoundaryMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR1Mutator]MSP[S]
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[rv.CRCR6Mutator]MSP[S] }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI4Mutator]MSP[S]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[NonVoidMethodCallMutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR2Mutator]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR1Mutator]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR6Mutator]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR4Mutator]MSP[N] setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { MST[NegateConditionalsMutator]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR5Mutator]MSP[N] setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR5Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR1Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; MST[ReturnValsMutator]MSP[N] }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR1Mutator]MSP[N] setLoc = strings ; break; } }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[InlineConstantMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR6Mutator]MSP[S]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR4Mutator]MSP[S]
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[InlineConstantMutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.ROR3Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR5Mutator]MSP[N] setLoc = strings ; break; } }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI3Mutator]MSP[N]
if ( setEn != null && setLoc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR1Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
id = id . substring ( 4 ) ; MST[rv.CRCR5Mutator]MSP[S] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR2Mutator]MSP[N]
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR5Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[NegateConditionalsMutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setLoc = strings ; break; } }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR2Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.ABSMutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR4Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR2Mutator]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR3Mutator]MSP[N] setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { MST[NegateConditionalsMutator]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR1Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR2Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR4Mutator]MSP[S]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[InlineConstantMutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; MST[NonVoidMethodCallMutator]MSP[S] String [] setEn = null ; for ( String [] strings : zoneStringsEn ) {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR3Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[S] } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI1Mutator]MSP[N] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.ABSMutator]MSP[S]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
if ( setEn != null && setLoc != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR1Mutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { MST[rv.ROR5Mutator]MSP[S] byIdCache . put ( id , byNameKeyCache = createCache () ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR6Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; MST[NonVoidMethodCallMutator]MSP[N] return nameSet == null ? null : nameSet [ 0 ] ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR5Mutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR6Mutator]MSP[S]
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; MST[NonVoidMethodCallMutator]MSP[S] String [] setEn = null ; for ( String [] strings : zoneStringsEn ) {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NegateConditionalsMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI3Mutator]MSP[S]
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI4Mutator]MSP[S]
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; MST[NegateConditionalsMutator]MSP[N] }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; MST[NullReturnValsMutator]MSP[N] }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR4Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[InlineConstantMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache . put ( locale , byIdCache = createCache () ) ; MST[NonVoidMethodCallMutator]MSP[S] }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR3Mutator]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI4Mutator]MSP[N] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI3Mutator]MSP[S]
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey , boolean standardTime ) { if ( locale == null || id == null || nameKey == null ) { return null ; MST[ReturnValsMutator]MSP[S] } if ( id . startsWith ( lr_2 ) ) {
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
id = id . substring ( 4 ) ; MST[rv.CRCR4Mutator]MSP[S] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] byIdCache . put ( id , byNameKeyCache = createCache () ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; MST[rv.ROR5Mutator]MSP[N] }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR4Mutator]MSP[S] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI4Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[ConditionalsBoundaryMutator]MSP[N] setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[S] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[NonVoidMethodCallMutator]MSP[N]
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; MST[NonVoidMethodCallMutator]MSP[N] return nameSet == null ? null : nameSet [ 1 ] ; }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI2Mutator]MSP[S]
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR6Mutator]MSP[S] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR3Mutator]MSP[S]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR4Mutator]MSP[N] setLoc = strings ; break; } }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR3Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR1Mutator]MSP[N] setLoc = strings ; break; } }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR2Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NonVoidMethodCallMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[InlineConstantMutator]MSP[N] setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR5Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI3Mutator]MSP[N] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR6Mutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[rv.ROR5Mutator]MSP[N] return null ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR1Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR3Mutator]MSP[S] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR5Mutator]MSP[N]
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI2Mutator]MSP[N]
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.ABSMutator]MSP[S]
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; MST[EmptyObjectReturnValsMutator]MSP[S] }
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[rv.ROR5Mutator]MSP[N] }
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( byIdCache == null ) { iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
id = id . substring ( 4 ) ; MST[rv.CRCR3Mutator]MSP[S] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR2Mutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; MST[ReturnValsMutator]MSP[S] }
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache . put ( locale , byIdCache = createCache () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR3Mutator]MSP[S]
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { MST[NegateConditionalsMutator]MSP[S] iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.ROR2Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NegateConditionalsMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NegateConditionalsMutator]MSP[N] setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[InlineConstantMutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } else {
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR3Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR3Mutator]MSP[S] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR2Mutator]MSP[N] setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[ArgumentPropagationMutator]MSP[N] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ; MST[NonVoidMethodCallMutator]MSP[S]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.ABSMutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI1Mutator]MSP[S]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.ROR5Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR2Mutator]MSP[S]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.ROR1Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR3Mutator]MSP[N] setLoc = strings ; break; } }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NegateConditionalsMutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
id = id . substring ( 4 ) ; MST[rv.CRCR1Mutator]MSP[N] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[NonVoidMethodCallMutator]MSP[S] } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { MST[rv.ROR5Mutator]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } else {
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI3Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } else {
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ; MST[NonVoidMethodCallMutator]MSP[S]
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI4Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR6Mutator]MSP[N]
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI1Mutator]MSP[S]
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NegateConditionalsMutator]MSP[N] setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[S] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[InlineConstantMutator]MSP[N]
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { MST[rv.ROR5Mutator]MSP[S] iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR5Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR5Mutator]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR5Mutator]MSP[N] setLoc = strings ; break; } }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR1Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[NegateConditionalsMutator]MSP[N] }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR5Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR6Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[InlineConstantMutator]MSP[N] setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[ConstructorCallMutator]MSP[S] } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR4Mutator]MSP[S] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[InlineConstantMutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ; MST[NonVoidMethodCallMutator]MSP[S]
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[ReturnValsMutator]MSP[N] }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI3Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR1Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[InlineConstantMutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR6Mutator]MSP[S] setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR2Mutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR3Mutator]MSP[S] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
id = id . substring ( 4 ) ; MST[rv.CRCR2Mutator]MSP[N] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[NonVoidMethodCallMutator]MSP[S] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR2Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return null ; }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { return null ; MST[ReturnValsMutator]MSP[N] }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; MST[ArgumentPropagationMutator]MSP[S] if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI2Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR2Mutator]MSP[N] } else {
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[NegateConditionalsMutator]MSP[N] return null ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR4Mutator]MSP[S]
if ( setEn != null && setLoc != null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NonVoidMethodCallMutator]MSP[N] setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache . put ( locale , byIdCache = createCache () ) ; MST[ArgumentPropagationMutator]MSP[N] }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR1Mutator]MSP[N] setLoc = strings ; break; } }
Map < String , Map < String , Object > > byIdCache = iByLocaleCache . get ( locale ) ; MST[ArgumentPropagationMutator]MSP[S] if ( byIdCache == null ) { iByLocaleCache . put ( locale , byIdCache = createCache () ) ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI2Mutator]MSP[N] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[rv.CRCR3Mutator]MSP[S] }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.ABSMutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[S] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[InlineConstantMutator]MSP[N]
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR5Mutator]MSP[N] setLoc = strings ; break; } }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI1Mutator]MSP[N]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR4Mutator]MSP[S]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR5Mutator]MSP[N]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR6Mutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.ROR4Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[NegateConditionalsMutator]MSP[N] setLoc = strings ; break; } }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR1Mutator]MSP[N]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
id = id . substring ( 4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR5Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR3Mutator]MSP[S] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.ROR4Mutator]MSP[N] setLoc = strings ; break; } }
id = id . substring ( 4 ) ; MST[NonVoidMethodCallMutator]MSP[S] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { MST[NegateConditionalsMutator]MSP[S] byIdCache . put ( id , byNameKeyCache = createCache () ) ;
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( byNameKeyCache == null ) { byIdCache . put ( id , byNameKeyCache = createCache () ) ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR6Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } else {
id = id . substring ( 4 ) ; MST[InlineConstantMutator]MSP[S] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI1Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR3Mutator]MSP[S]
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; MST[ArgumentPropagationMutator]MSP[S] }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR5Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
String [] [] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings () ; String [] setEn = null ; for ( String [] strings : zoneStringsEn ) { MST[rv.UOI4Mutator]MSP[N]
public String getShortName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 0 ] ; MST[InlineConstantMutator]MSP[N] }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[rv.CRCR2Mutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
Map < String , Object > byNameKeyCache = byIdCache . get ( id ) ; if ( byNameKeyCache == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] byIdCache . put ( id , byNameKeyCache = createCache () ) ;
id = id . substring ( 4 ) ; MST[rv.CRCR6Mutator]MSP[N] } Map < String , Map < Boolean , Object > > byIdCache = iByLocaleCache2 . get ( locale ) ; if ( byIdCache == null ) { iByLocaleCache2 . put ( locale , byIdCache = createCache () ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[S] } else {
if ( setEn != null && setLoc != null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; MST[rv.CRCR4Mutator]MSP[S]
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR1Mutator]MSP[N] } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn != null && setLoc != null ) { MST[rv.ROR5Mutator]MSP[N] byNameKeyCache . put ( setEn [ 2 ] , new String [] { setLoc [ 2 ] , setLoc [ 1 ] } ) ;
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR4Mutator]MSP[S] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[InlineConstantMutator]MSP[N] } else {
public String getName ( Locale locale , String id , String nameKey ) { String [] nameSet = getNameSet ( locale , id , nameKey ) ; return nameSet == null ? null : nameSet [ 1 ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
private synchronized String [] getNameSet ( Locale locale , String id , String nameKey ) { if ( locale == null || id == null || nameKey == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return null ; }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { MST[InlineConstantMutator]MSP[N] byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else {
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] setLoc = strings ; break; } }
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else {
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.UOI1Mutator]MSP[S] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
String [] setLoc = null ; for ( String [] strings : zoneStringsLoc ) { MST[rv.ABSMutator]MSP[N] if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break; } }
byNameKeyCache . put ( setEn [ 4 ] , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return ( String [] ) byNameKeyCache . get ( nameKey ) ; }
if ( strings != null && strings . length >= 5 && id . equals ( strings [ 0 ] ) ) { MST[rv.CRCR4Mutator]MSP[N] setEn = strings ; break; } } String [] [] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + lr_1 , new String [] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; MST[rv.CRCR3Mutator]MSP[S] } else {
private static long convertByYear ( long instant , Chronology from , Chronology to ) { return to . getDateTimeMillis ( from . year () . get ( instant ) , from . monthOfYear () . get ( instant ) , from . dayOfMonth () . get ( instant ) ,
from . millisOfDay () . get ( instant ) ) ; } private static long convertByWeekyear ( final long instant , Chronology from , Chronology to ) { long newInstant ;
newInstant = to . weekyear () . set ( 0 , from . weekyear () . get ( instant ) ) ; newInstant = to . weekOfWeekyear () . set ( newInstant , from . weekOfWeekyear () . get ( instant ) ) ;
newInstant = to . dayOfWeek () . set ( newInstant , from . dayOfWeek () . get ( instant ) ) ; newInstant = to . millisOfDay () . set ( newInstant , from . millisOfDay () . get ( instant ) ) ; return newInstant ; }
public static GJChronology getInstanceUTC () { return getInstance ( DateTimeZone . UTC , DEFAULT_CUTOVER , 4 ) ; } public static GJChronology getInstance () { return getInstance ( DateTimeZone . getDefault () , DEFAULT_CUTOVER , 4 ) ; } public static GJChronology getInstance ( DateTimeZone zone ) {
return getInstance ( zone , DEFAULT_CUTOVER , 4 ) ; } public static GJChronology getInstance ( DateTimeZone zone , ReadableInstant gregorianCutover ) { return getInstance ( zone , gregorianCutover , 4 ) ; } public static GJChronology getInstance ( DateTimeZone zone , ReadableInstant gregorianCutover , int minDaysInFirstWeek ) {
zone = DateTimeUtils . getZone ( zone ) ; Instant cutoverInstant ; if ( gregorianCutover == null ) { cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant () ;
LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis () , GregorianChronology . getInstance ( zone ) ) ; if ( cutoverDate . getYear () <= 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } }
GJCacheKey cacheKey = new GJCacheKey ( zone , cutoverInstant , minDaysInFirstWeek ) ; GJChronology chrono = cCache . get ( cacheKey ) ; if ( chrono == null ) { if ( zone == DateTimeZone . UTC ) { chrono = new GJChronology
( JulianChronology . getInstance ( zone , minDaysInFirstWeek ) , GregorianChronology . getInstance ( zone , minDaysInFirstWeek ) , cutoverInstant ) ; } else { chrono = getInstance ( DateTimeZone . UTC , cutoverInstant , minDaysInFirstWeek ) ; chrono = new GJChronology
( ZonedChronology . getInstance ( chrono , zone ) , chrono . iJulianChronology , chrono . iGregorianChronology , chrono . iCutoverInstant ) ; } GJChronology oldChrono = cCache . putIfAbsent ( cacheKey , chrono ) ; if ( oldChrono != null ) { chrono = oldChrono ; } }
return chrono ; } public static GJChronology getInstance ( DateTimeZone zone , long gregorianCutover , int minDaysInFirstWeek ) { Instant cutoverInstant ; if ( gregorianCutover == DEFAULT_CUTOVER . getMillis () ) { cutoverInstant = null ; } else { cutoverInstant = new Instant ( gregorianCutover ) ; }
return getInstance ( zone , cutoverInstant , minDaysInFirstWeek ) ; } private Object readResolve () { return getInstance ( getZone () , iCutoverInstant , getMinimumDaysInFirstWeek () ) ; } public DateTimeZone getZone () { Chronology base ; if ( ( base = getBase () ) != null ) {
return base . getZone () ; } return DateTimeZone . UTC ; } public Chronology withUTC () { return withZone ( DateTimeZone . UTC ) ; } public Chronology withZone ( DateTimeZone zone ) { if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
if ( zone == getZone () ) { return this ; } return getInstance ( zone , iCutoverInstant , getMinimumDaysInFirstWeek () ) ; } public long getDateTimeMillis ( int year , int monthOfYear , int dayOfMonth , int millisOfDay ) throws IllegalArgumentException { Chronology base ;
if ( ( base = getBase () ) != null ) { return base . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ; } long instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ; if ( instant < iCutoverMillis ) {
instant = iJulianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ; if ( instant >= iCutoverMillis ) { throw new IllegalArgumentException ( lr_2 ) ; } } return instant ; } public long getDateTimeMillis ( int year , int monthOfYear , int dayOfMonth ,
int hourOfDay , int minuteOfHour , int secondOfMinute , int millisOfSecond ) throws IllegalArgumentException { Chronology base ; if ( ( base = getBase () ) != null ) { return base . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
} long instant ; try { instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } catch ( IllegalFieldValueException ex ) { if ( monthOfYear != 2 || dayOfMonth != 29 ) { throw ex ; }
instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , 28 , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant >= iCutoverMillis ) { throw ex ; } } if ( instant < iCutoverMillis ) { instant = iJulianChronology . getDateTimeMillis
( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant >= iCutoverMillis ) { throw new IllegalArgumentException ( lr_2 ) ; } } return instant ; } public Instant getGregorianCutover () { return iCutoverInstant ; } public int getMinimumDaysInFirstWeek () {
return iGregorianChronology . getMinimumDaysInFirstWeek () ; } public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof GJChronology ) { GJChronology chrono = ( GJChronology ) obj ; return iCutoverMillis == chrono . iCutoverMillis &&
getMinimumDaysInFirstWeek () == chrono . getMinimumDaysInFirstWeek () && getZone () . equals ( chrono . getZone () ) ; } return false ; } public int hashCode () { return lr_3 . hashCode () * 11 + getZone () . hashCode () +
getMinimumDaysInFirstWeek () + iCutoverInstant . hashCode () ; } public String toString () { StringBuffer sb = new StringBuffer ( 60 ) ; sb . append ( lr_4 ) ; sb . append ( '[' ) ; sb . append ( getZone () . getID () ) ;
if ( iCutoverMillis != DEFAULT_CUTOVER . getMillis () ) { sb . append ( lr_5 ) ; DateTimeFormatter printer ; if ( withUTC () . dayOfYear () . remainder ( iCutoverMillis ) == 0 ) { printer = ISODateTimeFormat . date () ; } else {
printer = ISODateTimeFormat . dateTime () ; } printer . withChronology ( withUTC () ) . printTo ( sb , iCutoverMillis ) ; } if ( getMinimumDaysInFirstWeek () != 4 ) { sb . append ( lr_6 ) ; sb . append ( getMinimumDaysInFirstWeek () ) ; }
sb . append ( ']' ) ; return sb . toString () ; } protected void assemble ( Fields fields ) { Object [] params = ( Object [] ) getParam () ; JulianChronology julian = ( JulianChronology ) params [ 0 ] ;
GregorianChronology gregorian = ( GregorianChronology ) params [ 1 ] ; Instant cutoverInstant = ( Instant ) params [ 2 ] ; iCutoverMillis = cutoverInstant . getMillis () ; iJulianChronology = julian ; iGregorianChronology = gregorian ; iCutoverInstant = cutoverInstant ; if ( getBase () != null ) { return;
} if ( julian . getMinimumDaysInFirstWeek () != gregorian . getMinimumDaysInFirstWeek () ) { throw new IllegalArgumentException () ; } iGapDuration = iCutoverMillis - julianToGregorianByYear ( iCutoverMillis ) ; fields . copyFieldsFrom ( gregorian ) ;
if ( gregorian . millisOfDay () . get ( iCutoverMillis ) == 0 ) { fields . millisOfSecond = new CutoverField ( julian . millisOfSecond () , fields . millisOfSecond , iCutoverMillis ) ;
fields . millisOfDay = new CutoverField ( julian . millisOfDay () , fields . millisOfDay , iCutoverMillis ) ; fields . secondOfMinute = new CutoverField ( julian . secondOfMinute () , fields . secondOfMinute , iCutoverMillis ) ;
fields . secondOfDay = new CutoverField ( julian . secondOfDay () , fields . secondOfDay , iCutoverMillis ) ; fields . minuteOfHour = new CutoverField ( julian . minuteOfHour () , fields . minuteOfHour , iCutoverMillis ) ;
fields . minuteOfDay = new CutoverField ( julian . minuteOfDay () , fields . minuteOfDay , iCutoverMillis ) ; fields . hourOfDay = new CutoverField ( julian . hourOfDay () , fields . hourOfDay , iCutoverMillis ) ;
fields . hourOfHalfday = new CutoverField ( julian . hourOfHalfday () , fields . hourOfHalfday , iCutoverMillis ) ; fields . clockhourOfDay = new CutoverField ( julian . clockhourOfDay () , fields . clockhourOfDay , iCutoverMillis ) ; fields . clockhourOfHalfday = new CutoverField ( julian . clockhourOfHalfday () ,
fields . clockhourOfHalfday , iCutoverMillis ) ; fields . halfdayOfDay = new CutoverField ( julian . halfdayOfDay () , fields . halfdayOfDay , iCutoverMillis ) ; } { fields . era = new CutoverField ( julian . era () , fields . era , iCutoverMillis ) ; } {
fields . year = new ImpreciseCutoverField ( julian . year () , fields . year , iCutoverMillis ) ; fields . years = fields . year . getDurationField () ; fields . yearOfEra = new ImpreciseCutoverField (
julian . yearOfEra () , fields . yearOfEra , fields . years , iCutoverMillis ) ; fields . centuryOfEra = new ImpreciseCutoverField ( julian . centuryOfEra () , fields . centuryOfEra , iCutoverMillis ) ; fields . centuries = fields . centuryOfEra . getDurationField () ;
fields . yearOfCentury = new ImpreciseCutoverField ( julian . yearOfCentury () , fields . yearOfCentury , fields . years , fields . centuries , iCutoverMillis ) ; fields . monthOfYear = new ImpreciseCutoverField (
julian . monthOfYear () , fields . monthOfYear , null , fields . years , iCutoverMillis ) ; fields . months = fields . monthOfYear . getDurationField () ; fields . weekyear = new ImpreciseCutoverField (
julian . weekyear () , fields . weekyear , null , iCutoverMillis , true ) ; fields . weekyears = fields . weekyear . getDurationField () ; fields . weekyearOfCentury = new ImpreciseCutoverField (
julian . weekyearOfCentury () , fields . weekyearOfCentury , fields . weekyears , fields . centuries , iCutoverMillis ) ; } { long cutover = gregorian . year () . roundCeiling ( iCutoverMillis ) ; fields . dayOfYear = new CutoverField (
julian . dayOfYear () , fields . dayOfYear , fields . years , cutover , false ) ; } { long cutover = gregorian . weekyear () . roundCeiling ( iCutoverMillis ) ; fields . weekOfWeekyear = new CutoverField (
julian . weekOfWeekyear () , fields . weekOfWeekyear , fields . weekyears , cutover , true ) ; } { CutoverField cf = new CutoverField ( julian . dayOfMonth () , fields . dayOfMonth , iCutoverMillis ) ; cf . iRangeDurationField = fields . months ;
fields . dayOfMonth = cf ; } } long julianToGregorianByYear ( long instant ) { return convertByYear ( instant , iJulianChronology , iGregorianChronology ) ; } long gregorianToJulianByYear ( long instant ) { return convertByYear ( instant , iGregorianChronology , iJulianChronology ) ; }
long julianToGregorianByWeekyear ( long instant ) { return convertByWeekyear ( instant , iJulianChronology , iGregorianChronology ) ; } long gregorianToJulianByWeekyear ( long instant ) { return convertByWeekyear ( instant , iGregorianChronology , iJulianChronology ) ; } public boolean isLenient () { return false ; }
public int get ( long instant ) { if ( instant >= iCutover ) { return iGregorianField . get ( instant ) ; } else { return iJulianField . get ( instant ) ; } } public String getAsText ( long instant , Locale locale ) {
if ( instant >= iCutover ) { return iGregorianField . getAsText ( instant , locale ) ; } else { return iJulianField . getAsText ( instant , locale ) ; } } public String getAsText ( int fieldValue , Locale locale ) {
return iGregorianField . getAsText ( fieldValue , locale ) ; } public String getAsShortText ( long instant , Locale locale ) { if ( instant >= iCutover ) { return iGregorianField . getAsShortText ( instant , locale ) ; } else {
return iJulianField . getAsShortText ( instant , locale ) ; } } public String getAsShortText ( int fieldValue , Locale locale ) { return iGregorianField . getAsShortText ( fieldValue , locale ) ; } public long add ( long instant , int value ) {
return iGregorianField . add ( instant , value ) ; } public long add ( long instant , long value ) { return iGregorianField . add ( instant , value ) ; }
public int [] add ( ReadablePartial partial , int fieldIndex , int [] values , int valueToAdd ) { if ( valueToAdd == 0 ) { return values ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ;
for ( int i = 0 , isize = partial . size () ; i < isize ; i ++ ) { instant = partial . getFieldType ( i ) . getField ( GJChronology . this ) . set ( instant , values [ i ] ) ; }
instant = add ( instant , valueToAdd ) ; return GJChronology . this . get ( partial , instant ) ; } else { return super . add ( partial , fieldIndex , values , valueToAdd ) ; } }
public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iGregorianField . getDifference ( minuendInstant , subtrahendInstant ) ; } public long getDifferenceAsLong ( long minuendInstant , long subtrahendInstant ) { return iGregorianField . getDifferenceAsLong ( minuendInstant , subtrahendInstant ) ; }
public long set ( long instant , int value ) { if ( instant >= iCutover ) { instant = iGregorianField . set ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) {
instant = gregorianToJulian ( instant ) ; } if ( get ( instant ) != value ) { throw new IllegalFieldValueException ( iGregorianField . getType () , Integer . valueOf ( value ) , null , null ) ; } } } else {
instant = iJulianField . set ( instant , value ) ; if ( instant >= iCutover ) { if ( instant - iGapDuration >= iCutover ) { instant = julianToGregorian ( instant ) ; } if ( get ( instant ) != value ) { throw new IllegalFieldValueException
( iJulianField . getType () , Integer . valueOf ( value ) , null , null ) ; } } } return instant ; } public long set ( long instant , String text , Locale locale ) { if ( instant >= iCutover ) {
instant = iGregorianField . set ( instant , text , locale ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } } else {
instant = iJulianField . set ( instant , text , locale ) ; if ( instant >= iCutover ) { if ( instant - iGapDuration >= iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; } public DurationField getDurationField () {
return iDurationField ; } public DurationField getRangeDurationField () { return iRangeDurationField ; } public boolean isLeap ( long instant ) { if ( instant >= iCutover ) { return iGregorianField . isLeap ( instant ) ; } else { return iJulianField . isLeap ( instant ) ; } }
public int getLeapAmount ( long instant ) { if ( instant >= iCutover ) { return iGregorianField . getLeapAmount ( instant ) ; } else { return iJulianField . getLeapAmount ( instant ) ; } } public DurationField getLeapDurationField () { return iGregorianField . getLeapDurationField () ; }
public int getMinimumValue () { return iJulianField . getMinimumValue () ; } public int getMinimumValue ( ReadablePartial partial ) { return iJulianField . getMinimumValue ( partial ) ; } public int getMinimumValue ( ReadablePartial partial , int [] values ) {
return iJulianField . getMinimumValue ( partial , values ) ; } public int getMinimumValue ( long instant ) { if ( instant < iCutover ) { return iJulianField . getMinimumValue ( instant ) ; } int min = iGregorianField . getMinimumValue ( instant ) ;
instant = iGregorianField . set ( instant , min ) ; if ( instant < iCutover ) { min = iGregorianField . get ( iCutover ) ; } return min ; } public int getMaximumValue () { return iGregorianField . getMaximumValue () ; }
public int getMaximumValue ( long instant ) { if ( instant >= iCutover ) { return iGregorianField . getMaximumValue ( instant ) ; } int max = iJulianField . getMaximumValue ( instant ) ; instant = iJulianField . set ( instant , max ) ;
if ( instant >= iCutover ) { max = iJulianField . get ( iJulianField . add ( iCutover , - 1 ) ) ; } return max ; } public int getMaximumValue ( ReadablePartial partial ) {
long instant = GJChronology . getInstanceUTC () . set ( partial , 0L ) ; return getMaximumValue ( instant ) ; } public int getMaximumValue ( ReadablePartial partial , int [] values ) { Chronology chrono = GJChronology . getInstanceUTC () ; long instant = 0L ;
for ( int i = 0 , isize = partial . size () ; i < isize ; i ++ ) { DateTimeField field = partial . getFieldType ( i ) . getField ( chrono ) ;
if ( values [ i ] <= field . getMaximumValue ( instant ) ) { instant = field . set ( instant , values [ i ] ) ; } } return getMaximumValue ( instant ) ; } public long roundFloor ( long instant ) {
if ( instant >= iCutover ) { instant = iGregorianField . roundFloor ( instant ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } } else {
instant = iJulianField . roundFloor ( instant ) ; } return instant ; } public long roundCeiling ( long instant ) { if ( instant >= iCutover ) { instant = iGregorianField . roundCeiling ( instant ) ; } else { instant = iJulianField . roundCeiling ( instant ) ;
if ( instant >= iCutover ) { if ( instant - iGapDuration >= iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; } public int getMaximumTextLength ( Locale locale ) { return Math . max ( iJulianField . getMaximumTextLength ( locale ) ,
iGregorianField . getMaximumTextLength ( locale ) ) ; } public int getMaximumShortTextLength ( Locale locale ) { return Math . max ( iJulianField . getMaximumShortTextLength ( locale ) , iGregorianField . getMaximumShortTextLength ( locale ) ) ; } protected long julianToGregorian ( long instant ) {
if ( iConvertByWeekyear ) { return julianToGregorianByWeekyear ( instant ) ; } else { return julianToGregorianByYear ( instant ) ; } } protected long gregorianToJulian ( long instant ) { if ( iConvertByWeekyear ) { return gregorianToJulianByWeekyear ( instant ) ; } else { return gregorianToJulianByYear ( instant ) ;
} } public long add ( long instant , int value ) { if ( instant >= iCutover ) { instant = iGregorianField . add ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) {
if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear () . get ( instant ) ; if ( wyear <= 0 ) { instant = iGregorianChronology . weekyear () . add ( instant , - 1 ) ; } } else {
int year = iGregorianChronology . year () . get ( instant ) ; if ( year <= 0 ) { instant = iGregorianChronology . year () . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } } else {
instant = iJulianField . add ( instant , value ) ; if ( instant >= iCutover ) { if ( instant - iGapDuration >= iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; }
public long add ( long instant , long value ) { if ( instant >= iCutover ) { instant = iGregorianField . add ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) {
int wyear = iGregorianChronology . weekyear () . get ( instant ) ; if ( wyear <= 0 ) { instant = iGregorianChronology . weekyear () . add ( instant , - 1 ) ; } } else {
int year = iGregorianChronology . year () . get ( instant ) ; if ( year <= 0 ) { instant = iGregorianChronology . year () . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } } else {
instant = iJulianField . add ( instant , value ) ; if ( instant >= iCutover ) { if ( instant - iGapDuration >= iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; }
public int getDifference ( long minuendInstant , long subtrahendInstant ) { if ( minuendInstant >= iCutover ) { if ( subtrahendInstant >= iCutover ) { return iGregorianField . getDifference ( minuendInstant , subtrahendInstant ) ; } minuendInstant = gregorianToJulian ( minuendInstant ) ;
return iJulianField . getDifference ( minuendInstant , subtrahendInstant ) ; } else { if ( subtrahendInstant < iCutover ) { return iJulianField . getDifference ( minuendInstant , subtrahendInstant ) ; } minuendInstant = julianToGregorian ( minuendInstant ) ; return iGregorianField . getDifference ( minuendInstant , subtrahendInstant ) ; } }
public long getDifferenceAsLong ( long minuendInstant , long subtrahendInstant ) { if ( minuendInstant >= iCutover ) { if ( subtrahendInstant >= iCutover ) { return iGregorianField . getDifferenceAsLong ( minuendInstant , subtrahendInstant ) ; } minuendInstant = gregorianToJulian ( minuendInstant ) ;
return iJulianField . getDifferenceAsLong ( minuendInstant , subtrahendInstant ) ; } else { if ( subtrahendInstant < iCutover ) { return iJulianField . getDifferenceAsLong ( minuendInstant , subtrahendInstant ) ; } minuendInstant = julianToGregorian ( minuendInstant ) ; return iGregorianField . getDifferenceAsLong ( minuendInstant , subtrahendInstant ) ; } }
public int getMinimumValue ( long instant ) { if ( instant >= iCutover ) { return iGregorianField . getMinimumValue ( instant ) ; } else { return iJulianField . getMinimumValue ( instant ) ; } } public int getMaximumValue ( long instant ) {
if ( instant >= iCutover ) { return iGregorianField . getMaximumValue ( instant ) ; } else { return iJulianField . getMaximumValue ( instant ) ; } } public long add ( long instant , int value ) { return iField . add ( instant , value ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long getDifferenceAsLong ( long minuendInstant , long subtrahendInstant ) { return iField . getDifferenceAsLong ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.ABSMutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[PrimitiveReturnsMutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI1Mutator]MSP[S] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[NonVoidMethodCallMutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.ABSMutator]MSP[N] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI2Mutator]MSP[S] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[PrimitiveReturnsMutator]MSP[N] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI2Mutator]MSP[S] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI4Mutator]MSP[N] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI1Mutator]MSP[S] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI1Mutator]MSP[S] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI3Mutator]MSP[S] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[ReturnValsMutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI4Mutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.ABSMutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI2Mutator]MSP[S] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI1Mutator]MSP[S] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI3Mutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.ABSMutator]MSP[N] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI3Mutator]MSP[N] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI4Mutator]MSP[S] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[rv.UOI2Mutator]MSP[S] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI4Mutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[rv.UOI3Mutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[ReturnValsMutator]MSP[N] }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; MST[ArgumentPropagationMutator]MSP[N] } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; }
public long add ( long instant , long value ) { return iField . add ( instant , value ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { return iField . getDifference ( minuendInstant , subtrahendInstant ) ; MST[NonVoidMethodCallMutator]MSP[N] }
