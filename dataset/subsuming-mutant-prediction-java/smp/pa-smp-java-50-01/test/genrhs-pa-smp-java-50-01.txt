public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ; MST[NonVoidMethodCallMutator]MSP[N]
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
public Collection < String > getMatchingOptions () { return matchingOptions ; MST[ReturnValsMutator]MSP[N] } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ;
public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ; MST[experimental.NakedReceiverMutator]MSP[N]
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( it . next () ) ;
public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] buf . append ( option ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
public Collection < String > getMatchingOptions () { return matchingOptions ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( it . next () ) ;
public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
@Override protected String [] flatten ( @SuppressWarnings ( lr_1 ) final Options options , final String [] arguments , @SuppressWarnings ( lr_1 ) final boolean stopAtNonOption ) { return arguments ; }
@Override protected String [] flatten ( @SuppressWarnings ( lr_1 ) final Options options , final String [] arguments , @SuppressWarnings ( lr_1 ) final boolean stopAtNonOption ) { return arguments ; MST[ReturnValsMutator]MSP[N] }
@Override protected String [] flatten ( @SuppressWarnings ( lr_1 ) final Options options , final String [] arguments , @SuppressWarnings ( lr_1 ) final boolean stopAtNonOption ) { return arguments ; MST[NullReturnValsMutator]MSP[S] }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return answer ; } public List < String > getOptionGroups () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
public Iterator < Option > iterator () { return options . iterator () ; } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public CommandLine build () { return commandLine ; }
else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[N] {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[S] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[S] } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[ArgumentPropagationMutator]MSP[N]
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[N] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] }
return answer ; MST[NullReturnValsMutator]MSP[S] } public List < String > getOptionGroups () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt )
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { if ( processedOption . equals
return getOptionValue ( String . valueOf ( opt ) ) ; } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N] for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[ReturnValsMutator]MSP[N] } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI1Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; MST[ArgumentPropagationMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[N] {
else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[N] for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] } else if ( values . size () == 1 ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; MST[ReturnValsMutator]MSP[S] } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return answer ; } public List < String > getOptionGroups () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } } protected void addOption ( final Option opt ) { } } add ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } } protected void addOption ( final Option opt ) MST[NonVoidMethodCallMutator]MSP[N] } } } if ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } } protected void addOption ( final Option opt ) MST[NonVoidMethodCallMutator]MSP[N]
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Option option : options ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[S] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; MST[ReturnValsMutator]MSP[N] } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] }
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { if ( processedOption . equals
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; MST[NegateConditionalsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[S] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[ReturnValsMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[rv.ROR5Mutator]MSP[S] }
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; MST[ReturnValsMutator]MSP[N] } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public Object getOptionObject ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( opt . equals ( option . getOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; MST[NullReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } else if ( values . size () == 1 ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return processed . toArray ( optionsArray ) ; MST[ArgumentPropagationMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( processedOption . equals
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { if ( processedOption . equals
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; MST[ReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[S] } } return null ; } public String [] getOptionValues ( final char opt ) {
return answer ; } public List < String > getOptionGroups () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void addOption ( final Option opt ) { options . add ( opt ) ; } } protected void addOption ( final Option opt ) { options . add ( opt ) ; } } protected void addOption ( final Option opt ) { options . add ( opt ) ; } } protected void addOption ( final Option opt ) { options . add
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
return answer ; } public List < String > getOptionGroups () { return args ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt )
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt ) {
else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR4Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
public Iterator < Option > iterator () { return options . iterator () ; } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ; MST[NonVoidMethodCallMutator]MSP[N]
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; }
if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return answer ; MST[ReturnValsMutator]MSP[N] } public List < String > getOptionGroups () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt )
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[N]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[S] { if ( processedOption . equals
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI4Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI2Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NullReturnValsMutator]MSP[S] } catch ( final ParseException pe ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[N] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[S] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[ConstructorCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getOptionObject ( final char opt ) {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( processedOption . equals
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[VoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[N] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( values . size () == 1 ) {
return answer ; } public List < String > getOptionGroups () { return args ; MST[ReturnValsMutator]MSP[N] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; } protected void addOption ( final Option opt ) { options . add ( opt )
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ParseException pe ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NullReturnValsMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.ABSMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[S] return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NullReturnValsMutator]MSP[S] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] }
public Iterator < Option > iterator () { return options . iterator () ; MST[ReturnValsMutator]MSP[N] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[S] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; MST[NonVoidMethodCallMutator]MSP[N] args . toArray ( answer ) ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
public boolean hasOption ( final Option opt ) MST[ConstructorCallMutator]MSP[N] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[S] { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[S] { if ( processedOption . equals
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[InlineConstantMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { if ( processedOption . equals
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[N] if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return processed . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) { final List < String > values = option . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[N]
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( processedOption . equals
final String res = getOptionValue ( option ) ; if ( res == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } return processed . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[N] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI3Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) { ) ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) ) { if ( processedOption . equals ( option ) )
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[S] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] for ( final Option option : options ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[N] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[N] {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.ROR5Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[N] } final String [] values = getOptionValues ( option ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[ReturnValsMutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[NegateConditionalsMutator]MSP[S] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; MST[VoidMethodCallMutator]MSP[N] return this ; }
public CommandLine build () { return commandLine ; MST[ReturnValsMutator]MSP[N] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[ReturnValsMutator]MSP[N] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[N] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
public CommandLine build () { return commandLine ; MST[NullReturnValsMutator]MSP[S] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[ConstructorCallMutator]MSP[N] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( ch ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] : String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] =
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[InlineConstantMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] if
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[S] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[S]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S] } } MST[rv.CRCR3Mutator]MSP[S]
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void MST[rv.ROR3Mutator]MSP[N] ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[experimental.MemberVariableMutator]MSP[N] currentOption = null ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break; } } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR3Mutator]MSP[S] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final int pos = t . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
final String value = t . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } updateRequiredOptions ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[S] break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[S] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[ReturnValsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NegateConditionalsMutator]MSP[S] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[S] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual (
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR6Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[ConditionalsBoundaryMutator]MSP[S] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
for ( final String argument : arguments ) { handleToken ( argument ) ; MST[VoidMethodCallMutator]MSP[N] } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () ; if ( properties == null ) { return; () ; if ( properties == null ) { return; () ; if ( properties == null ) { return; () ; if ( properties == null ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual (
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR2Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt . hasArg () ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[InlineConstantMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options .
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
return false ; MST[rv.CRCR1Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[N] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[S] break; } } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return false ; MST[rv.CRCR6Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR4Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR5Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } . addArg ( token ) ; skipParsing = true
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[S]
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String value = t . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR5Mutator]MSP[N] } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { skipParsing = true ; } } skipParsing true ; } } skipParsing = true ; } } skipParsing true ; } } skipParsing = true ; } } skipParsing true ; } } skipParsing = true ; } } skipParsing true ; } } skipParsing = true ; } } skipParsing = true ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[ConditionalsBoundaryMutator]MSP[S] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[ConditionalsBoundaryMutator]MSP[S] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options .
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options .
} else if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
} else if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[ReturnValsMutator]MSP[N] } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[S] break; } } else {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { return true ; }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[EmptyObjectReturnValsMutator]MSP[N] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR6Mutator]MSP[S] break; } } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR2Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual (
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } private boolean isLongOption ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] if
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[S] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } . addArg ( token ) ; skipParsing = true
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( allowPartialMatching ) MST[NegateConditionalsMutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[N] if ( arguments != null ) {
handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI3Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI3Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI3Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI3Mutator]MSP[N] if ( options .
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[InlineConstantMutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options .
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[S] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR5Mutator]MSP[N] currentOption = null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR1Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD2Mutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[VoidMethodCallMutator]MSP[N] } }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR3Mutator]MSP[S] {
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NegateConditionalsMutator]MSP[N] if ( options .
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR5Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[IncrementsMutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[N]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[N] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR5Mutator]MSP[N] if ( options .
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[S] {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; (
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[S]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( options . getOptionGroup ( option ) != null ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR5Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI3Mutator]MSP[N] skipParsing = false ; currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] = String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] =
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void MST[rv.ROR3Mutator]MSP[N] ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NegateConditionalsMutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[S] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR4Mutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } new addArg ( token ) ; skipParsing = true ; } } } new addArg ( token ) } skipParsing true ; } } } } } } } } } } } } } } } } } } } } } } } } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; (
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[VoidMethodCallMutator]MSP[N]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[N] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean selected = group != null && group . getSelected () != null ;
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } updateRequiredOptions token ) ; } } } updateRequiredOptions ( token ) ; } } } updateRequiredOptions ( token ) ; } } } updateRequiredOptions ( token ) ; } } if ( token ) ; } } if ( token ) ; } } if ( token
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } cmd . addArg ( token ) ; if ( true ; } } } } } } } MST[rv.UOI3Mutator]MSP[S] } } } } . = true ; skipParsing = true ; } } cmd . addArg ( token ) ; { ( true ; } } } } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final int pos = token . indexOf ( lr_7 ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; MST[NonVoidMethodCallMutator]MSP[N] updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI2Mutator]MSP[N] if ( options .
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } MST[NonVoidMethodCallMutator]MSP[N] ( token ) ; } }
return true ; MST[rv.CRCR6Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR3Mutator]MSP[S] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[rv.ROR5Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] if
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[ReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[ReturnValsMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final
final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[N] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[N] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[N] handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () ; if ( properties == null ) { return; () ; if ( properties == null ) { return; () ; if ( properties == null ) { return; () ; if ( properties == null ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[S] break; } } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
} else if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void updateRequiredOptions ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual (
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR5Mutator]MSP[S] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N] } private void handleUnknownToken ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[InlineConstantMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
else { final String opt = getLongPrefix ( t ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[S]
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
} else if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR4Mutator]MSP[N] if ( options .
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR4Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[S] { if ( options . hasShortOption
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR4Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N]
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[MathMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options .
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
return false ; MST[rv.CRCR3Mutator]MSP[S] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ReturnValsMutator]MSP[N] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[N] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; MST[experimental.MemberVariableMutator]MSP[N] this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ABSMutator]MSP[N] if ( options .
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleLongOptionWithEqual ( token ) ; } } else { handleLongOptionWithEqual ( token ) ; } } else { handleLongOptionWithEqual ( token ) ; } } else { handleLongOptionWithEqual ( token ) ; } } else { handleLongOptionWithEqual ( token ) ; } } else { handleLongOptionWithEqual ( token ) ; } } else { handleLongOptionWithEqual (
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[S] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR2Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[S]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } ( token ) ; } } } updateRequiredOptions token ) ; } } if ( token ) ; } } } updateRequiredOptions token ) ; } } if ( token ) ; } } } ( token ) ; } } } updateRequiredOptions token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else if ( isJavaProperty ( opt ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N]
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; MST[rv.CRCR5Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
handleOption ( options . getOption ( ch ) ) ; MST[VoidMethodCallMutator]MSP[N] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( options .
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) ) ( newEntries . acceptsArg () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) ) ( newEntries . acceptsArg () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) ) ( newEntries . acceptsArg () ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String prefix = t . substring ( 0 , i ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[S] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ConditionalsBoundaryMutator]MSP[S] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[InlineConstantMutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI2Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } ( token ) ; } } } ( token ) ; } } } ( token ) ; } } } ( token ) ; } } } ( token ) ; } } } ( token ) ; } } if ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI2Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } else token ) ; } } if token ) ; } } else token ) ; } } ( token ) ; } } else token ) ; } } if token ) ; } } else token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[ConstructorCallMutator]MSP[N] if ( options . hasLongOption ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ConditionalsBoundaryMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[S] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} else if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options .
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[N] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[S] break; } } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[N] {
Option option = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] matches . add ( option . getLongOpt () ) ; } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR3Mutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[N] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[N] } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NegateConditionalsMutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[MathMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR1Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI4Mutator]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; MST[InlineConstantMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; (
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[experimental.NakedReceiverMutator]MSP[N] if ( options .
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[S] break; } } }
cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } updateRequiredOptions ( token ) ; } } } updateRequiredOptions ( token ) ; } } { handleLongOptionWithoutEqual ( token ) ; } } { handleLongOptionWithoutEqual ( token ) ; } } { updateRequiredOptions ( token ) ; } } { updateRequiredOptions ( token ) ; } }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR5Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[InlineConstantMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR1Mutator]MSP[S] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[S] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) MST[rv.ROR2Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; MST[ConstructorCallMutator]MSP[N] } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
final String prefix = t . substring ( 0 , i ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NegateConditionalsMutator]MSP[S] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[InlineConstantMutator]MSP[N] currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[S] { if ( options . hasShortOption
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR6Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } cmd . addArg ( token ) ; if ( true ; } } } } } } } MST[rv.UOI3Mutator]MSP[S] } } } } . = true ; skipParsing = true ; } } cmd . addArg ( token ) ; { ( true ; } } } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[S] break; } } }
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[ArgumentPropagationMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual ( final
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR3Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[InlineConstantMutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void updateRequiredOptions ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithEqual void handleLongOptionWithoutEqual (
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; MST[rv.CRCR3Mutator]MSP[S] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { skipParsing = true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; } } skipParsing true ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR3Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[InlineConstantMutator]MSP[S] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ReturnValsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[NegateConditionalsMutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
} else if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR3Mutator]MSP[N] currentOption = null ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[N] } cmd = new CommandLine () ; if ( arguments != null ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[N] if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[rv.ROR5Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[S] break; } } else {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR2Mutator]MSP[N] if ( options .
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[N] { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[N] option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[S] }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[ArgumentPropagationMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual (
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NonVoidMethodCallMutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[N] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[S] break; } } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual (
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR4Mutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
return true ; MST[InlineConstantMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] if ( option . hasArg () ) { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[InlineConstantMutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break; } } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N]
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( options .
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[S] break; } } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; }
} else if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR6Mutator]MSP[N] currentOption = null ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR2Mutator]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[N] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR6Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[S] }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { MST[rv.ABSMutator]MSP[N] void handleLongOptionWithoutEqual ( final String token ) throws ParseException { getOptionGroup void handleLongOptionWithoutEqual ( final String token ) throws ParseException { getOptionGroup void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI4Mutator]MSP[N] if ( options .
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N]
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[N] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[InlineConstantMutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI1Mutator]MSP[N] skipParsing = false ; currentOption = null ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[S] }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual (
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR1Mutator]MSP[N] if ( options .
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[ConditionalsBoundaryMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new CommandLine ( token ) } skipParsing true ; } } } } } } } } } } } } } } } } } } } } } } } } } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI2Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[InlineConstantMutator]MSP[S] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[ReturnValsMutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; } } else {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[N] checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; checkRequiredOptions { if ( properties == null ) { return; checkRequiredOptions { if ( properties == null ) { return; checkRequiredOptions { if ( properties == null ) { return; checkRequiredOptions { if ( properties == null ) { return; checkRequiredOptions { if ( properties == null ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { MST[rv.ABSMutator]MSP[N] void handleLongOptionWithoutEqual ( final String token ) throws ParseException { getOptionGroup void handleLongOptionWithoutEqual ( final String token ) throws ParseException { getOptionGroup void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[S] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options .
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI4Mutator]MSP[N] skipParsing = false ; currentOption = null ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[ConditionalsBoundaryMutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( option != null && option . acceptsArg () ) {
return true ; MST[rv.CRCR2Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR3Mutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; MST[ConstructorCallMutator]MSP[N] } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[N]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[N] } } MST[rv.CRCR4Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[S] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S]
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NegateConditionalsMutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR5Mutator]MSP[S] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; MST[ConstructorCallMutator]MSP[S] } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[S] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util . stripLeadingHyphens ( token ) ; final String t = Util
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR3Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[S] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.UOI1Mutator]MSP[N] if ( options .
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } if ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options .
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[S] break; } } else {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void updateRequiredOptions ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
} else if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR1Mutator]MSP[N] currentOption = null ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[experimental.MemberVariableMutator]MSP[N] skipParsing = false ; currentOption = null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR1Mutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; MST[VoidMethodCallMutator]MSP[N] } } private List < String > getMatchingLongOptions ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR6Mutator]MSP[S] {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] || lr_3 . equalsIgnoreCase ( value )
return true ; MST[ReturnValsMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N] || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR4Mutator]MSP[N] if ( options .
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
return false ; MST[ReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] if
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[ReturnValsMutator]MSP[N] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[N] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD1Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { return true ; }
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } new UnrecognizedOptionException ( token ) ; skipParsing = true ; } } } new addArg ( token ) } skipParsing true ; } } } } } } } } } } } } } } } } } } } } } } } } } }
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } private boolean isArgument ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } if ( token ) ; } } } MST[NonVoidMethodCallMutator]MSP[N] ( token ) ; } }
final String prefix = t . substring ( 0 , i ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR4Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[N] }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[N] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR1Mutator]MSP[N] } private void handleUnknownToken ( final String token ) throws ParseException {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[N] return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
return false ; MST[rv.CRCR5Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR3Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[ReturnValsMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) ) { if ( options . hasShortOption ( optName ) )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[S] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( options . getOptionGroup ( option ) != null ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR2Mutator]MSP[S] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[S]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } catch ( final NumberFormatException e ) { return false ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void MST[rv.ROR3Mutator]MSP[N] ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleLongOptionWithoutEqual void handleLongOptionWithoutEqual ( final
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[S] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S]
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } updateRequiredOptions token ) ; } } { updateRequiredOptions ( token ) ; } } if ( token ) ; } } if ( token ) ; } } if ( token ) ; } } if ( token ) ; } } if ( token ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing = true ; } } skipParsing
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } } else { final String opt = t . substring ( 0 , pos ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[InlineConstantMutator]MSP[N] } private void handleUnknownToken ( final String token ) throws ParseException {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N]
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR2Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[S] }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual (
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[ReturnValsMutator]MSP[N] } private boolean isJavaProperty ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[ReturnValsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[InlineConstantMutator]MSP[N] if ( options .
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; MST[experimental.MemberVariableMutator]MSP[N] if ( skipParsing ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[InlineConstantMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[N]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI2Mutator]MSP[N] skipParsing = false ; currentOption = null ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
return true ; MST[rv.CRCR4Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) MST[rv.ROR3Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[S] break; } } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[MathMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[S] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[N] break; } } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[S] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.ROR3Mutator]MSP[N] if ( options .
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] if
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.ABSMutator]MSP[N] skipParsing = false ; currentOption = null ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR3Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[S] }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[ReturnValsMutator]MSP[N] } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR4Mutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR1Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N]
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[S] }
} else if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR4Mutator]MSP[S] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR4Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void handleLongOptionWithoutEqual ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] if
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[S] if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[S] if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[S] if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[S] if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] if
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[S] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { hasShortOption void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual ( final String token ) throws ParseException { handleProperties void handleLongOptionWithoutEqual (
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; (
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[S] }
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) { return; () { if ( properties == null ) {
} else if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[S] break; } } else {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } } } ( token ) ; } } } updateRequiredOptions ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } } handleLongOptionWithoutEqual ( token ) ; } } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
handleShortAndLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; MST[experimental.MemberVariableMutator]MSP[N] } else { MST[experimental.MemberVariableMutator]MSP[N] } else { MST[rv.CRCR1Mutator]MSP[N] } else { else } else { else } else { else } else { else } else { else } else { else } else { else } else { else } else { else } else { else } else { else
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[S] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR1Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR2Mutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[S] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NonVoidMethodCallMutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR4Mutator]MSP[S] break; } } }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ;
return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[rv.ROR1Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[VoidMethodCallMutator]MSP[N] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[S]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[S] break; } } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( options .
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR1Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( options .
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[N]
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR1Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[S] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] } if token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] ( token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] ( token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] ( token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] ( token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] ( token ) ; MST[VoidMethodCallMutator]MSP[N] } MST[VoidMethodCallMutator]MSP[N] ( token ) ; MST[VoidMethodCallMutator]MSP[N]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; MST[VoidMethodCallMutator]MSP[N] cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { } else { }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR2Mutator]MSP[S] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[N] if ( arguments != null ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) { MST[rv.CRCR2Mutator]MSP[N] if ( options .
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[MathMutator]MSP[S] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken ( token ) ; } } else { handleUnknownToken
final String value = t . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () ) . getOption ( 0 ) ; if ( option . acceptsArg () ) ) ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; } } } else { handleLongOptionWithEqual ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[N] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[N]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[N] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } else ( token ) ; } } else token ) ; } } if token ) ; } } ( token ) ; } } else token ) ; } } if token ) ; } } ( token ) ; } } else token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } private boolean isJavaProperty ( final String token ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } } if token ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException { { void void handleLongOptionWithoutEqual ( final String token ) throws ParseException { setSelected void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual ( final String token ) throws ParseException { isNegativeNumber void handleLongOptionWithoutEqual (
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ABSMutator]MSP[S] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ;
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR1Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR3Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[S] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[InlineConstantMutator]MSP[N]
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR3Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR2Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR5Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[IncrementsMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] ( options .
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[InlineConstantMutator]MSP[N] } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR1Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[ArgumentPropagationMutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[experimental.NakedReceiverMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] if ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt )
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; MST[ArgumentPropagationMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[ArgumentPropagationMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[ArgumentPropagationMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[ArgumentPropagationMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[ArgumentPropagationMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[ArgumentPropagationMutator]MSP[N] if ( options
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR5Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR3Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR4Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] ) ( options
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR2Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] ) ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] ) ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] ) ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N]
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[IncrementsMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arguments [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[InlineConstantMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ABSMutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.UOI1Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[NegateConditionalsMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options .
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[experimental.NakedReceiverMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[MathMutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR2Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI4Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR3Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; MST[rv.UOI2Mutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
else if ( lr_2 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NegateConditionalsMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( options . hasOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( options . hasOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] ( options . hasOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] ( options . hasOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] ( options . hasOption ( opt
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR1Mutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
tokens . add ( arguments [ i ] ) ; MST[rv.ABSMutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( options .
tokens . add ( arguments [ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR3Mutator]MSP[N] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N]
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR3Mutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt )
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR4Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI2Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ABSMutator]MSP[N] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N]
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR2Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] ( options . hasOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] ) ( options . hasOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] if ( options . hasOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] if ( options . hasOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] if ( options . hasOption ( opt ) )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[InlineConstantMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
{ tokens . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) {
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] ) ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] ) ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] ) if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] ) ( options . hasOption ( opt )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[experimental.RemoveIncrementsMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } else {
else if ( lr_2 . equals ( arg ) ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR5Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR2Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR1Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR2Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR1Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; MST[rv.UOI3Mutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; MST[rv.UOI1Mutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) ) ( options . hasOption ( opt ) ) ) ( options . hasOption ( opt ) ) ) ) if ( options . hasOption ( opt ) ) ) ( options . hasOption ( opt ) ) ) { if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[ArgumentPropagationMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] ( options .
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[ArgumentPropagationMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[InlineConstantMutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] index ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] { if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] { if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] { if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] { if ( options . hasOption
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR2Mutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[ArgumentPropagationMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR2Mutator]MSP[N] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N]
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( options . hasOption ( opt ) )
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI1Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI3Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( lr_2 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR1Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N]
else if ( lr_2 . equals ( arg ) ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NullReturnValsMutator]MSP[N] }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( opt ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( options
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NegateConditionalsMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; MST[rv.ABSMutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N] boolean eatTheRest = false ;
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( options . hasOption ( opt )
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) ) ( options . hasOption ( opt ) ) ) ( options . hasOption ( opt ) ) ) ) if ( options . hasOption ( opt ) ) ) ( options . hasOption ( opt ) ) ) { if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] }
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arguments [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt ) ) { if ( options . hasOption ( opt )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.UOI3Mutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ) if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR1Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] tokens . add ( lr_1 ) ; }
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ReturnValsMutator]MSP[N] }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( options .
eatTheRest = stopAtNonOption ; MST[rv.UOI4Mutator]MSP[N] tokens . current ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[InlineConstantMutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.ABSMutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; } public String getNewLine () { return newRequired ; } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getOptPrefix () { return newRequired ; }
public void setDescPadding ( final String prefix ) { this . Whitelist = prefix ; } public String getLongOptPrefix () { return valuesep ; } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; }
public void setArgName ( final String name ) { this . numArgs = name ; } public String getArgName () { return numArgs ; } public Comparator < Option > getOptionComparator () { return MST[ReturnValsMutator]MSP[S] ; } public void MST[rv.ABSMutator]MSP[S] ( final Comparator < Option > comparator ) {
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; }
public void printHelp ( final String cmdLineSyntax , final Options options , final boolean autoUsage ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , autoUsage ) ; }
public void printHelp ( final String cmdLineSyntax , final String header , final Options options , final String footer ) { printHelp ( cmdLineSyntax , header , options , footer , false ) ; }
public void printHelp ( final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { printHelp ( getWidth () , cmdLineSyntax , header , options , footer , autoUsage ) ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer ) { printHelp ( width , cmdLineSyntax , header , options , footer , false ) ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { final PrintWriter pw = new PrintWriter ( System . out ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; }
public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax , final String header , final Options options , final int leftPad , final int descPad , final String footer , final boolean autoUsage ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } } prefixList . add ( optBuf ) ;
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR5Mutator]MSP[N]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR3Mutator]MSP[S] { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[S] { return pos + 1 ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR5Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[NegateConditionalsMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return sb ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_5 ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR6Mutator]MSP[N]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR2Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI4Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOD1Mutator]MSP[N] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR5Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[PrimitiveReturnsMutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[PrimitiveReturnsMutator]MSP[N] }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR6Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { --
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI3Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
if ( footer != null && footer . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] else
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[MathMutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = startPos . length () ? - 1 : pos ; } pos = startPos . length () ? - 1 :
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; }
public void setDescPadding ( final String prefix ) { this . Whitelist = prefix ; } public String getLongOptPrefix () { return valuesep ; } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; MST[EmptyObjectReturnValsMutator]MSP[N] } String getOptPrefix () { return longOptSeparator ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { -- pos ; && int ( pos - 1 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { -- pos ; && s [ pos - 1 ) ) ) MST[rv.CRCR3Mutator]MSP[S] { -- pos ; && s [ 1 ) ) )
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[N] appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
if ( argName != null && argName . length () == 0 ) MST[rv.ROR3Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } } prefixList . add ( optBuf ) ; MST[NonVoidMethodCallMutator]MSP[N]
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR3Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR2Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR2Mutator]MSP[N]
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR5Mutator]MSP[N] {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI4Mutator]MSP[N] {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[N] } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ABSMutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; MST[IncrementsMutator]MSP[N] pos ( pos - 1 ) ) ) { -- pos ; MST[IncrementsMutator]MSP[N] int pos ( pos - 1 ) ) ) { -- pos ; MST[IncrementsMutator]MSP[N] int pos ( pos - 1 ) ) ) { -- pos ; MST[IncrementsMutator]MSP[N] int pos ( pos - 1 ) )
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR4Mutator]MSP[N] { -- pos ; && MST[rv.ABSMutator]MSP[N] . [ - 1 ) ) ) MST[rv.AOR4Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) ) { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) MST[rv.AOR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOR4Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) )
if ( option . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
} return s . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR4Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[InlineConstantMutator]MSP[S] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] else
} return s . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[ArgumentPropagationMutator]MSP[N] } }
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; } public String getNewLine () { return newRequired ; } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getOptPrefix () { return newRequired ; MST[ReturnValsMutator]MSP[N] } return getOptPrefix () { return newRequired ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } basic getOptPrefix () { return newRequired ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } basic getOptPrefix () { return newRequired ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } basic getOptPrefix () { return newRequired ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } basic
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.ABSMutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[N] } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[InlineConstantMutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( option . getOpt () != null ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[N] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR4Mutator]MSP[N]
if ( argName != null && argName . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
} return s . substring ( 0 , pos ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( ! group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { -- pos ; &&
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( text ) ; return sb ; }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI2Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR5Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI3Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[S] } else { printUsage ( pw , width ,
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI3Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( option . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[MathMutator]MSP[N] { final char c = text . charAt ( pos ) ;
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR3Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[NonVoidMethodCallMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
catch ( final IOException e ) { } return sb ; MST[ReturnValsMutator]MSP[N] } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.ABSMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI4Mutator]MSP[S] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[S] } } MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[S] } MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[N] } if ( startPos () ? - 1 : pos ; MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[S] }
if ( argName != null && argName . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR4Mutator]MSP[S] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[InlineConstantMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[NonVoidMethodCallMutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( ! group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI1Mutator]MSP[N] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( getOptionComparator () != null ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI2Mutator]MSP[N] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR5Mutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR1Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ?
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[MathMutator]MSP[S] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR1Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[N] } } MST[rv.UOI2Mutator]MSP[N] } MST[rv.UOI2Mutator]MSP[N] } } } } } } } MST[rv.UOI2Mutator]MSP[N] } if = startPos () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[N] } } MST[rv.UOI2Mutator]MSP[N] } } } } } } } } } } } } } MST[rv.UOI2Mutator]MSP[N] } if ) () ? - 1 :
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[ConditionalsBoundaryMutator]MSP[S] { -- pos ; && Character - 1 ) ) ) MST[ConditionalsBoundaryMutator]MSP[S] { -- pos ; && Character ; ) ) MST[ConditionalsBoundaryMutator]MSP[S] { -- pos ; && Character . isWhitespace ) { -- pos ; && Character . isWhitespace ) { -- pos ; && Character . isWhitespace ) { -- pos ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[InlineConstantMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR1Mutator]MSP[N] } if ( startPos () ? - 1 : pos ; MST[rv.ROR1Mutator]MSP[N] } if } . length () ? - 1 : pos ; MST[rv.ROR1Mutator]MSP[N] } if } MST[rv.ROR1Mutator]MSP[S] } ( startPos () ? - 1 : pos ; MST[rv.ROR1Mutator]MSP[N] } if } MST[rv.ROR1Mutator]MSP[S] } ( - () ? -
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[rv.ROR5Mutator]MSP[N] } } prefixList . add ( optBuf ) ;
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR2Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR3Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI1Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . MST[NonVoidMethodCallMutator]MSP[S] () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } (
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI3Mutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI1Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI3Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI1Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI2Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ABSMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[NegateConditionalsMutator]MSP[N] {
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[ConstructorCallMutator]MSP[N] if ( optBuf . length () < max ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; MST[VoidMethodCallMutator]MSP[N] } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { final String argName = option . getArgName () ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[InlineConstantMutator]MSP[S] }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI2Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[InlineConstantMutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOD2Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD2Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD2Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD2Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD2Mutator]MSP[N] { -- pos ; &&
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
if ( s == null || s . length () == 0 ) MST[rv.ROR1Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { -- pos ; && s ( pos - 1 )
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected String rtrim ( final String s ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) MST[rv.AOD1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[IncrementsMutator]MSP[N] if ( optBuf . length () < max ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[N] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR5Mutator]MSP[N] } final String padding = createPadding ( nextLineTabStop ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR1Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[NonVoidMethodCallMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI3Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI3Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ?
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI2Mutator]MSP[N] } }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.ABSMutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOD1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; } public String getNewLine () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix ()
} return s . substring ( 0 , pos ) ; MST[ReturnValsMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) &&
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOD1Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option .
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR4Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI4Mutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR4Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI1Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI3Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR2Mutator]MSP[S] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.ABSMutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[NegateConditionalsMutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.ABSMutator]MSP[S] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR1Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI1Mutator]MSP[N] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } (
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.ABSMutator]MSP[N] } }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR3Mutator]MSP[S] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { --
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR4Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI3Mutator]MSP[N] if ( optBuf . length () < max ) {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.ABSMutator]MSP[N] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR1Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( s == null || s . length () == 0 ) { return s ; MST[ReturnValsMutator]MSP[N] } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; MST[ReturnValsMutator]MSP[N] pos ( pos - 1 ) ) ) { -- pos ; MST[ReturnValsMutator]MSP[N] pos ( pos - 1 ) ) ) { -- pos ; MST[ReturnValsMutator]MSP[N] pos ( pos - 1 ) ) ) { -- pos ; MST[ReturnValsMutator]MSP[N] pos ( pos - 1 ) ) ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOD2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( startPos + width >= text . length () ) MST[rv.UOI3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N]
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[ConditionalsBoundaryMutator]MSP[N] {
if ( startPos + width >= text . length () ) MST[rv.ROR1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI1Mutator]MSP[N] } }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR5Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } prefixList . add ( optBuf ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI3Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setDescPadding ( final String prefix ) { this . Whitelist = prefix ; } public String getLongOptPrefix () { return Whitelist ; } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; MST[ReturnValsMutator]MSP[N] } return getOptPrefix () { return longOptSeparator ; MST[ReturnValsMutator]MSP[N] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[NonVoidMethodCallMutator]MSP[N]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.ABSMutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR2Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; && MST[rv.ROR4Mutator]MSP[N] && Character - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; && s ( pos - 1 )
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.ABSMutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI3Mutator]MSP[N] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.ABSMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR1Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR5Mutator]MSP[N] } }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[NonVoidMethodCallMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR3Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.ABSMutator]MSP[S] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[InlineConstantMutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[S] } } MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[S] } MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[N] } if ( startPos () ? - 1 : pos ; MST[rv.ABSMutator]MSP[N] } } MST[rv.ABSMutator]MSP[N] } } } } MST[rv.ABSMutator]MSP[S] }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.ABSMutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding ()
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR1Mutator]MSP[N] { -- pos ; -- pos ( pos - 1 ) ) ) MST[rv.AOR1Mutator]MSP[N] { -- pos ; -- pos ( pos - 1 ) ) ) MST[rv.AOR1Mutator]MSP[N] { -- pos ; -- pos ( pos - 1 ) ) ) MST[rv.AOR1Mutator]MSP[N] { -- pos ; -- pos ( pos - 1 )
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI2Mutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[NonVoidMethodCallMutator]MSP[N] {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
max = optBuf . length () > max ? optBuf . length () : max ; MST[ConditionalsBoundaryMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI1Mutator]MSP[N] } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; MST[NullReturnValsMutator]MSP[N] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; MST[NonVoidMethodCallMutator]MSP[N] int pos ; && Character - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; && s ( pos -
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR1Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR2Mutator]MSP[N] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; MST[ConstructorCallMutator]MSP[N] String line ; boolean firstLine = true ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( startPos + width >= text . length () ) MST[rv.ROR4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[ConditionalsBoundaryMutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI1Mutator]MSP[N] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[experimental.MemberVariableMutator]MSP[N] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( s == null || s . length () == 0 ) { return s ; MST[EmptyObjectReturnValsMutator]MSP[N] } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; MST[EmptyObjectReturnValsMutator]MSP[S] pos ( pos - 1 ) ) ) { -- pos ; MST[EmptyObjectReturnValsMutator]MSP[N] MST[rv.ABSMutator]MSP[S] int pos ( pos - 1 ) ) ) { -- pos ; MST[EmptyObjectReturnValsMutator]MSP[N] } int pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) { -- pos ; MST[EmptyObjectReturnValsMutator]MSP[N] } int pos ; && MST[rv.ROR5Mutator]MSP[N] .
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR1Mutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[NonVoidMethodCallMutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; &&
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; MST[NullReturnValsMutator]MSP[S] }
if ( startPos + width >= text . length () ) MST[MathMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI4Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . MST[NonVoidMethodCallMutator]MSP[S] () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } (
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; }
} return s . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI4Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR3Mutator]MSP[S]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[VoidMethodCallMutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N] } else { printUsage ( pw , width ,
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N] } MST[rv.ROR4Mutator]MSP[N]
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[ConstructorCallMutator]MSP[N] } protected String rtrim ( final String s ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR5Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[experimental.NakedReceiverMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[InlineConstantMutator]MSP[N]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI2Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR2Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR3Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] } return getLeftPadding () {
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[experimental.MemberVariableMutator]MSP[N] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[ArgumentPropagationMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR4Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ?
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.ABSMutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI2Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR3Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR4Mutator]MSP[S] }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; MST[VoidMethodCallMutator]MSP[N] } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { final String argName = option . getArgName () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option .
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NegateConditionalsMutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- pos ; &&
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[NonVoidMethodCallMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI1Mutator]MSP[N] { -- pos ; -- pos ; && Character - 1 ) ) ) MST[rv.UOI1Mutator]MSP[N] { -- pos ; -- pos ; && Character - 1 ) ) ) MST[rv.UOI1Mutator]MSP[N] { -- pos ; { = pos ; && Character - 1 ) ) ) MST[rv.UOI1Mutator]MSP[N] { -- pos ; { int pos
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) &&
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI2Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR2Mutator]MSP[N]
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[InlineConstantMutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI1Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ?
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI4Mutator]MSP[N] } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR1Mutator]MSP[S]
} return s . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.UOI4Mutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { --
if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( ! group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR1Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () )
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI2Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[rv.ROR5Mutator]MSP[N] {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI4Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[ConditionalsBoundaryMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.ABSMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[InlineConstantMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR2Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = shape ) ?
Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N]
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI4Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] } else { printUsage ( pw , width ,
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI2Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR2Mutator]MSP[S]
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD2Mutator]MSP[S] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR6Mutator]MSP[S] }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( optBuf . length () < max ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { -- pos ; &&
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR3Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR3Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR3Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
} return s . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.UOI1Mutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR2Mutator]MSP[N] if ( option . getDescription () != null ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ABSMutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } setSyntaxPrefix getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } setSyntaxPrefix getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } setSyntaxPrefix getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[N] } } MST[ReturnValsMutator]MSP[N] } setSyntaxPrefix
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] } return getLeftPadding () {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR6Mutator]MSP[N] } final String padding = createPadding ( nextLineTabStop ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( it . hasNext () )
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI3Mutator]MSP[S] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[NonVoidMethodCallMutator]MSP[N] {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR1Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return pos + 1 ; }
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI1Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[experimental.MemberVariableMutator]MSP[N] } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI4Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI3Mutator]MSP[N] } } MST[rv.ROR5Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.ABSMutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
printWrapped ( pw , width , 0 , text ) ; MST[InlineConstantMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[InlineConstantMutator]MSP[N]
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[ReturnValsMutator]MSP[N] } return getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[ReturnValsMutator]MSP[N] }
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI1Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; && MST[rv.ROR4Mutator]MSP[N] && Character - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ; && s ( pos - 1 )
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; { int pos ; && Character - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; + s ( pos
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR4Mutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ABSMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ?
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.UOI1Mutator]MSP[N] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ?
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI4Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ?
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR6Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR4Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOD2Mutator]MSP[N] if ( option . getDescription () != null ) {
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; } public String getNewLine () { return newRequired ; } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getOptPrefix () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } return getOptPrefix () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } void setSyntaxPrefix () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } void setSyntaxPrefix () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } void setSyntaxPrefix () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } void setSyntaxPrefix () { return newRequired ; MST[EmptyObjectReturnValsMutator]MSP[N] } void setSyntaxPrefix () {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR3Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } (
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { appendOption ( buff , it . next () , true ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI4Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[N] }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else
buff . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOD1Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD1Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD1Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD1Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.AOD1Mutator]MSP[N] { -- pos ; &&
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) &&
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ; -- pos ) &&
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ABSMutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { sb . append ( text ) ; return sb ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[VoidMethodCallMutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } prefixList . add ( optBuf ) ;
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { --
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI1Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR6Mutator]MSP[S]
} return s . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI2Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI4Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.UOI4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI3Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR2Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( ! group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; MST[VoidMethodCallMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[VoidMethodCallMutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI3Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; MST[NonVoidMethodCallMutator]MSP[N] while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; -- pos ; && Character - 1 ) ) ) { -- pos ; } int pos ; && MST[rv.ABSMutator]MSP[N] && Character - 1 ) ) ) { -- pos ; } int pos ; && MST[rv.ABSMutator]MSP[N] && Character - 0 ) ) ) { -- pos ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR5Mutator]MSP[N]
while ( ( line = in . readLine () ) != null ) MST[NegateConditionalsMutator]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[MathMutator]MSP[S] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; && s ( pos - 1 )
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI4Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( startPos + width >= text . length () ) MST[rv.ROR2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR3Mutator]MSP[S] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR5Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( ! group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI2Mutator]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_5 ) ; } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
while ( ( line = in . readLine () ) != null ) MST[rv.ROR5Mutator]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[rv.ROR5Mutator]MSP[N] . ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . length - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . length - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . length - 1
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[VoidMethodCallMutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( startPos + width >= text . length () ) MST[NegateConditionalsMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[ConditionalsBoundaryMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
while ( ( line = in . readLine () ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option .
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.ABSMutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] } else { printUsage ( pw , width ,
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.ABSMutator]MSP[N] } }
if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI4Mutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.UOI2Mutator]MSP[N] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI1Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[N] }
} if ( header != null && header . trim () . length () > 0 ) MST[experimental.NakedReceiverMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[N] } } if = length () ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[N] } } if = length () ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[N] } } if ) ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[S] } } if = length () ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI2Mutator]MSP[N] } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR2Mutator]MSP[N]
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI3Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR3Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI2Mutator]MSP[N] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[PrimitiveReturnsMutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI1Mutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( option . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI3Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; MST[NonVoidMethodCallMutator]MSP[N] int pos ; && Character - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ; && s ( pos -
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.ABSMutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR4Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NegateConditionalsMutator]MSP[S]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI4Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; { int pos ; && Character - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; && s ( pos -
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ABSMutator]MSP[N] {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOD2Mutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.ABSMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . MST[NonVoidMethodCallMutator]MSP[S] () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } (
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ABSMutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( startPos + width >= text . length () ) MST[rv.UOI3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { -- pos ; ) && MST[rv.ROR4Mutator]MSP[N] ( pos - 1 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { -- pos ; && MST[rv.ABSMutator]MSP[N] && Character - 1 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { -- pos ; && MST[rv.ABSMutator]MSP[N] && Character - 1 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { -- pos ; && s ( pos - 1
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; } public String getNewLine () { return newRequired ; } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[N] } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix ()
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N]
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI2Mutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding ()
} return s . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ABSMutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[N] } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR3Mutator]MSP[N] {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N]
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI1Mutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] } } setSyntaxPrefix () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] } } setSyntaxPrefix getSyntaxPrefix () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] } } setSyntaxPrefix getLeftPadding () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] } } setSyntaxPrefix getLeftPadding () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] } } setSyntaxPrefix getLeftPadding () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option .
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR5Mutator]MSP[N]
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI1Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR3Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI3Mutator]MSP[N]
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[VoidMethodCallMutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR6Mutator]MSP[N]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.ABSMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[ConstructorCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI2Mutator]MSP[N] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR4Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI1Mutator]MSP[N] } }
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR3Mutator]MSP[S]
if ( ! group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR6Mutator]MSP[S] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI1Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } else { printUsage ( pw , width ,
if ( argName != null && argName . length () == 0 ) MST[rv.ROR4Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR5Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ?
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR3Mutator]MSP[S] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[InlineConstantMutator]MSP[N] { -- pos ; && MST[rv.ROR1Mutator]MSP[N] && Character - 1 ) ) ) MST[InlineConstantMutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[InlineConstantMutator]MSP[N] { -- pos ; && s [ pos ) ) ) MST[InlineConstantMutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) )
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[N] } } MST[rv.UOI2Mutator]MSP[N] } MST[rv.UOI2Mutator]MSP[N] } } } } } } } MST[rv.UOI2Mutator]MSP[N] } if = startPos () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[N] } } MST[rv.UOI2Mutator]MSP[N] } } } } } } } } } } } } } MST[rv.UOI2Mutator]MSP[N] } if ) () ? - 1 :
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR5Mutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) MST[rv.ROR4Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && MST[rv.ROR4Mutator]MSP[N] ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[rv.ROR5Mutator]MSP[S]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) &&
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String argName = option . getArgName () ;
public void setDescPadding ( final String prefix ) { this . Whitelist = prefix ; } public String getLongOptPrefix () { return Whitelist ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix ()
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[NegateConditionalsMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = () ? -
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOD1Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI4Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI1Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[S] { return pos + 1 ; }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; MST[ConstructorCallMutator]MSP[N] String line ; boolean firstLine = true ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR5Mutator]MSP[N] } } MST[rv.ROR5Mutator]MSP[N] } MST[rv.ROR5Mutator]MSP[N] } if ( startPos () ? - 1 : pos ; MST[rv.ROR5Mutator]MSP[N] } } MST[rv.ROR5Mutator]MSP[N] } } } } MST[rv.ROR5Mutator]MSP[N] } } } } MST[rv.ROR5Mutator]MSP[N] } if ( startPos () ? - 1 : pos ; MST[rv.ROR5Mutator]MSP[N] } } MST[rv.ROR5Mutator]MSP[N] } } } } MST[rv.ROR5Mutator]MSP[N]
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N]
if ( startPos + width >= text . length () ) MST[rv.AOR1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } void setSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } MST[rv.CRCR6Mutator]MSP[N] getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } MST[rv.CRCR6Mutator]MSP[N] setSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } MST[rv.CRCR6Mutator]MSP[N] setSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } MST[rv.CRCR6Mutator]MSP[N] setSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } MST[rv.CRCR6Mutator]MSP[N] setSyntaxPrefix () {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR1Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( startPos + width >= text . length () ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( ! processedGroups . contains ( group ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ABSMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ?
public void setDescPadding ( final String prefix ) { this . Whitelist = prefix ; } public String getLongOptPrefix () { return defaultDescPad ; MST[ReturnValsMutator]MSP[N] } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix () { return longOptSeparator ; } } String getOptPrefix ()
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[ArgumentPropagationMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( startPos + width >= text . length () ) MST[rv.ROR5Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.ABSMutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } prefixList . add ( optBuf ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR4Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[ArgumentPropagationMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[MathMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.AOR2Mutator]MSP[N] { -- pos ; { ++ pos ; && Character - 1 ) ) ) MST[rv.AOR2Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.AOR2Mutator]MSP[N] { -- pos ; && MST[rv.ABSMutator]MSP[N] && Character
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[NegateConditionalsMutator]MSP[S] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[ConditionalsBoundaryMutator]MSP[S] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.UOI2Mutator]MSP[N] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ?
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ; && s ( pos - 1 )
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI1Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR4Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR3Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[ArgumentPropagationMutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ; -- pos ) &&
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ; -- pos ) &&
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] } return getLeftPadding () {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR6Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[rv.ROR5Mutator]MSP[N] . ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . length - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . length - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ; && MST[NonVoidMethodCallMutator]MSP[N] . length - 1
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.ABSMutator]MSP[N] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ? - 1 : pos ; } } pos = () ?
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR4Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( startPos + width >= text . length () ) MST[rv.ROR3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR3Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[MathMutator]MSP[N] { -- pos ; -- pos ; && Character - 1 ) ) ) MST[MathMutator]MSP[N] { -- pos ; -- pos ; && Character - 1 ) ) ) MST[MathMutator]MSP[S] { -- pos ; { = pos ; && Character - 1 ) ) ) MST[MathMutator]MSP[S] { -- pos ; + s (
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] } int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] } return getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] } return getLeftPadding () {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[ConditionalsBoundaryMutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI4Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[InlineConstantMutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR4Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI4Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } ( startPos () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } ( startPos () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } } } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } ( startPos ()
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR2Mutator]MSP[S]
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI2Mutator]MSP[N] if ( option . getDescription () != null ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI1Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR3Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR6Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR5Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI1Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; MST[ReturnValsMutator]MSP[N] }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI2Mutator]MSP[N] } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR3Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = shape ) ?
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI3Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR3Mutator]MSP[S] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.AOR1Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; MST[ConstructorCallMutator]MSP[N] final List < Option > optList = options . helpOptions () ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } (
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR1Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; MST[ReturnValsMutator]MSP[N] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI1Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR1Mutator]MSP[N]
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[N] }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI4Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR1Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[InlineConstantMutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR2Mutator]MSP[S] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR3Mutator]MSP[S]
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI1Mutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; && Character - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ; &&
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ABSMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ? - 1 : pos ; } pos = shape ) ?
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI4Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR1Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) { MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () )
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI3Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.ABSMutator]MSP[N] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI1Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR1Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR5Mutator]MSP[N]
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR2Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { final PrintWriter pw = new PrintWriter ( System . out ) ; MST[ConstructorCallMutator]MSP[N]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } return sb ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( startPos + width >= text . length () ) MST[rv.AOR4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR6Mutator]MSP[N] } }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI4Mutator]MSP[N] if ( optBuf . length () < max ) {
if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option .
optBuf . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.ABSMutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ; MST[ConstructorCallMutator]MSP[N]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR3Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
catch ( final IOException e ) { } return sb ; MST[NullReturnValsMutator]MSP[S] } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOD1Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; MST[NonVoidMethodCallMutator]MSP[N] final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_5 ) ; } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI4Mutator]MSP[N] } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; { int pos ; && Character - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ; + s ( pos
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI2Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI4Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.ABSMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR1Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ROR5Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.ABSMutator]MSP[N] if ( option . getDescription () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI4Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR6Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } (
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOD1Mutator]MSP[S]
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR2Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI3Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR4Mutator]MSP[N]
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.ABSMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR1Mutator]MSP[N] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR3Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR4Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( argName != null && argName . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI2Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR3Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N]
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[InlineConstantMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } prefixList . add ( optBuf ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI4Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[N] }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR6Mutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI2Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[MathMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; MST[experimental.NakedReceiverMutator]MSP[N] return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( rtrim ( text ) ) ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NegateConditionalsMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI4Mutator]MSP[N]
if ( option . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( pos != - 1 && pos <= width ) MST[ConditionalsBoundaryMutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( ! group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[ReturnValsMutator]MSP[S] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR5Mutator]MSP[S] }
} if ( header != null && header . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI2Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } } if ( startPos () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } } if ( startPos () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } } if ( startPos () ? - 1
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR6Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI2Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI4Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[rv.ROR5Mutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR1Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[InlineConstantMutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( s == null || s . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; ; int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
final String lpad = createPadding ( leftPad ) ; MST[NonVoidMethodCallMutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR4Mutator]MSP[N] } final String padding = createPadding ( nextLineTabStop ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI4Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( argName != null && argName . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[S] else
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( ! processedGroups . contains ( group ) ) MST[NonVoidMethodCallMutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI3Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] else
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[N] }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] if ( optBuf . length () < max ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI1Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[InlineConstantMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { -- pos ; -- pos ; && Character - 1 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { -- pos ; -- pos ) &&
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI3Mutator]MSP[S] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI3Mutator]MSP[N] } } MST[rv.ROR5Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR4Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; pw . flush () ; MST[VoidMethodCallMutator]MSP[N] } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } (
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR4Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { appendOption ( buff , it . next () , true ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( startPos + width >= text . length () ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[S] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR1Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[NonVoidMethodCallMutator]MSP[N] } } } } } } } MST[NonVoidMethodCallMutator]MSP[N] } } } } MST[NonVoidMethodCallMutator]MSP[N] } } } } MST[NonVoidMethodCallMutator]MSP[N] } } } } MST[NonVoidMethodCallMutator]MSP[N] } } } } MST[NonVoidMethodCallMutator]MSP[N] } if } MST[NonVoidMethodCallMutator]MSP[S] } ( - () ? - 1 : pos ; MST[NonVoidMethodCallMutator]MSP[N] } } MST[NonVoidMethodCallMutator]MSP[N] } } } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
final StringBuffer sb = new StringBuffer () ; MST[ConstructorCallMutator]MSP[N] renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR3Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.AOR3Mutator]MSP[N] { -- pos ; && MST[rv.ROR1Mutator]MSP[N] ) ) ) ) ) MST[rv.AOR3Mutator]MSP[S] { -- pos ; && MST[rv.ROR5Mutator]MSP[N] . length ) ) ) MST[rv.AOR3Mutator]MSP[N] { -- pos ; && MST[rv.ROR5Mutator]MSP[N] . [ pos - 1 ) ) ) MST[rv.AOR3Mutator]MSP[N]
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ; MST[rv.ABSMutator]MSP[N]
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI1Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI4Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[N] }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; MST[ConstructorCallMutator]MSP[N] if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N]
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR3Mutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { -- pos ; && MST[rv.ROR1Mutator]MSP[N] ) ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { -- pos ; && s [ 1 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { -- pos ; && s [ 1 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { -- pos
if ( s == null || s . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; }
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[ReturnValsMutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } } String getSyntaxPrefix () { return defaultSyntaxPrefix ; } } String getSyntaxPrefix () { return defaultSyntaxPrefix ; } } String getSyntaxPrefix () { return defaultSyntaxPrefix ; } } String getSyntaxPrefix ()
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.ABSMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI1Mutator]MSP[N] } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( pos != - 1 && pos <= width ) MST[NegateConditionalsMutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.UOI1Mutator]MSP[N] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[InlineConstantMutator]MSP[N] } }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR5Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR3Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; } public String getNewLine () { return newRequired ; MST[ReturnValsMutator]MSP[N] } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix () { return newRequired ; } } String getOptPrefix ()
} return s . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI3Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR3Mutator]MSP[N] } }
public void setArgName ( final String name ) { this . numArgs = name ; MST[experimental.MemberVariableMutator]MSP[N] } public String getArgName () { return numArgs ; } public Comparator < Option > getOptionComparator () { return MST[ReturnValsMutator]MSP[S] ; } public void MST[rv.CRCR5Mutator]MSP[S] ( final Comparator < Option > comparator ) {
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } prefixList . add ( optBuf ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR5Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI1Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR1Mutator]MSP[N] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ROR2Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR3Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; MST[ReturnValsMutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI3Mutator]MSP[N] } }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI3Mutator]MSP[S] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding ()
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( option . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[S] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
this . optionComparator = comparator ; MST[experimental.MemberVariableMutator]MSP[N] } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; }
public void setArgName ( final String name ) { this . numArgs = name ; } public String getArgName () { return numArgs ; } public Comparator < Option > getOptionComparator () { return MST[ReturnValsMutator]MSP[S] ; MST[NullReturnValsMutator]MSP[S] } public void MST[rv.ABSMutator]MSP[S] ( final Comparator < Option > comparator ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[N] }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[InlineConstantMutator]MSP[N] }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[VoidMethodCallMutator]MSP[N] }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI2Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } else { printUsage ( pw , width ,
if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( startPos + width >= text . length () ) MST[NonVoidMethodCallMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[MathMutator]MSP[S]
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.UOI3Mutator]MSP[N]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI3Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[VoidMethodCallMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( optBuf . length () < max ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI1Mutator]MSP[N] if ( optBuf . length () < max ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI3Mutator]MSP[S] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR1Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.ABSMutator]MSP[N] if ( option . getDescription () != null ) {
while ( ( line = in . readLine () ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
public void setDescPadding ( final String prefix ) { this . defaultDescPad = prefix ; MST[experimental.MemberVariableMutator]MSP[N] } public String getLongOptPrefix () { return defaultDescPad ; } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix () { return longOptSeparator ; } public String getOptPrefix ()
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR6Mutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[N] }
if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI2Mutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[NegateConditionalsMutator]MSP[N] {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI2Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI3Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group != null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR1Mutator]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } MST[rv.UOI1Mutator]MSP[N] } if } ; MST[rv.UOI1Mutator]MSP[N] } ( startPos () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[N] } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.ABSMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR2Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; MST[ConstructorCallMutator]MSP[N] if ( getOptionComparator () != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR3Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
return sb ; MST[NullReturnValsMutator]MSP[S] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI2Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; { int pos ; && Character - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; + s ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; && s ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ; && s ( pos -
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI3Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( footer != null && footer . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ABSMutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.ABSMutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[rv.ROR5Mutator]MSP[N] {
if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI3Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR6Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( startPos + width >= text . length () ) MST[rv.AOR2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[NegateConditionalsMutator]MSP[N] {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI2Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD1Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) && Character - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ; -- pos ) &&
if ( footer != null && footer . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI2Mutator]MSP[N] if ( optBuf . length () < max ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI2Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR5Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[S] { return pos + 1 ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR2Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI3Mutator]MSP[S] } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI1Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI3Mutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR6Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( s == null || s . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { --
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI2Mutator]MSP[N]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.ABSMutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR6Mutator]MSP[S]
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI2Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; }
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR1Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
if ( startPos + width >= text . length () ) MST[rv.ABSMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final String prefix ) { this . Whitelist = prefix ; } public String getLongOptPrefix () { return Whitelist ; } public void setDescPadding ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; MST[experimental.MemberVariableMutator]MSP[N] } public String getOptPrefix () { return longOptSeparator ; } } public String getOptPrefix () { return longOptSeparator ; } } public String getOptPrefix () { return longOptSeparator ; } } public String getOptPrefix () { return longOptSeparator ; } } public String getOptPrefix () { return longOptSeparator ; } } public String getOptPrefix () { return longOptSeparator ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR1Mutator]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI3Mutator]MSP[N] {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR3Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[rv.ROR5Mutator]MSP[N] {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] else ( option .
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI1Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOD2Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[NegateConditionalsMutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( option . getOpt () != null ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[InlineConstantMutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR1Mutator]MSP[S] }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.ABSMutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR4Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI4Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.ABSMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option .
optBuf . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
} return s . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR5Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[InlineConstantMutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR1Mutator]MSP[N] } }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.UOI3Mutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR3Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI1Mutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding ()
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR4Mutator]MSP[N] if ( option . getDescription () != null ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } (
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR4Mutator]MSP[N] {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
} return s . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( option . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI3Mutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[VoidMethodCallMutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.ABSMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI2Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI4Mutator]MSP[S] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI4Mutator]MSP[N] } } MST[rv.UOI4Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
if ( s == null || s . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; ; int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ;
if ( ! processedGroups . contains ( group ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR3Mutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR4Mutator]MSP[N]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[InlineConstantMutator]MSP[N]
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.ABSMutator]MSP[N] if ( optBuf . length () < max ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[N] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[VoidMethodCallMutator]MSP[N] }
public void setArgName ( final String name ) { this . numArgs = name ; } public String getArgName () { return numArgs ; MST[ReturnValsMutator]MSP[N] } public Comparator < Option > getOptionComparator () { return MST[ReturnValsMutator]MSP[S] ; } public void MST[rv.CRCR5Mutator]MSP[S] ( final Comparator < Option > comparator ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[ConstructorCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR5Mutator]MSP[N] { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
public void setOptionalArg ( final String req ) { this . defaultNewLine = defaultSyntaxPrefix ; MST[experimental.MemberVariableMutator]MSP[N] } public String getNewLine () { return newRequired ; } public void setDescPadding ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix () { return newRequired ; } public String getOptPrefix ()
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR2Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( s == null || s . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; } int pos ; && int pos - 1 ) ) ) { -- pos ; }
if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
} if ( header != null && header . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( startPos + width >= text . length () ) MST[rv.AOD2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI2Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[rv.ROR5Mutator]MSP[N] {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI4Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI1Mutator]MSP[N] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } MST[rv.UOI1Mutator]MSP[N] } if } ; MST[rv.UOI1Mutator]MSP[N] } ( startPos () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[N] } }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_5 ) ; } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( ! processedGroups . contains ( group ) ) MST[NegateConditionalsMutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; MST[experimental.NakedReceiverMutator]MSP[N] final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] else ( option .
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI2Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[ReturnValsMutator]MSP[N] } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[NonVoidMethodCallMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NegateConditionalsMutator]MSP[S]
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR4Mutator]MSP[S]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.ABSMutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
if ( startPos + width >= text . length () ) MST[rv.UOI2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI1Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI3Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.AOR3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
printWrapped ( pw , width , 0 , text ) ; MST[VoidMethodCallMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( option . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[N] } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; } public String getSyntaxPrefix ()
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NegateConditionalsMutator]MSP[N] } } prefixList . add ( optBuf ) ;
while ( ( line = in . readLine () ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI3Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[ConditionalsBoundaryMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ; } pos = () ? - 1 : pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[NegateConditionalsMutator]MSP[S] { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; MST[NonVoidMethodCallMutator]MSP[N] return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI4Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N]
if ( argName != null && argName . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI1Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
if ( s == null || s . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { --
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[ArgumentPropagationMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[IncrementsMutator]MSP[N] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[VoidMethodCallMutator]MSP[N]
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[ArgumentPropagationMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[N] }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI2Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet () ? - 1 : pos ; } pos = entrySet ) ? - 1 : pos ; } pos = entrySet ) ?
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI3Mutator]MSP[S] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final char c = text . charAt ( pos ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR4Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR2Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR5Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI3Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOD2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR1Mutator]MSP[S]
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD1Mutator]MSP[S] }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR2Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { final String argName = option . getArgName () ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[ArgumentPropagationMutator]MSP[N] } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR5Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it . hasNext () ) { } if ( it
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . MST[NonVoidMethodCallMutator]MSP[S] () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } (
if ( startPos + width >= text . length () ) MST[ConditionalsBoundaryMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI2Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI4Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI3Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[InlineConstantMutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI4Mutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding () { return defaultLeftPad ; } } int getLeftPadding ()
} return s . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N]
public void setArgName ( final String name ) { this . numArgs = name ; } public String getArgName () { return numArgs ; } public Comparator < Option > getOptionComparator () { return MST[ReturnValsMutator]MSP[S] ; MST[ReturnValsMutator]MSP[S] } public void MST[rv.ABSMutator]MSP[S] ( final Comparator < Option > comparator ) {
} return s . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[NegateConditionalsMutator]MSP[N] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR5Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR4Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR2Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
public void setArgName ( final String name ) { this . numArgs = name ; } public String getArgName () { return numArgs ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Comparator < Option > getOptionComparator () { return MST[ReturnValsMutator]MSP[S] ; } public void MST[rv.CRCR5Mutator]MSP[S] ( final Comparator < Option > comparator ) {
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.ABSMutator]MSP[N]
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { -- pos ; } int pos ; && int ( pos - 1 ) ) ) { --
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[MathMutator]MSP[N] if ( option . getDescription () != null ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
public void setWidth ( final int width ) MST[experimental.MemberVariableMutator]MSP[N] { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding () { return defaultLeftPad ; } public int getLeftPadding ()
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR2Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI4Mutator]MSP[S] }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR1Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ; MST[ConstructorCallMutator]MSP[N]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NegateConditionalsMutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[S] { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI4Mutator]MSP[N] } } MST[rv.UOI4Mutator]MSP[N] } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ? - 1 : pos ; } pos = length () ?
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI1Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.AOD2Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 : pos ; } pos = text . length () ? - 1 :
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOD2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; MST[ConstructorCallMutator]MSP[N] if ( option . getOpt () == null ) {
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[ReturnValsMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[PrimitiveReturnsMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_5 ) ; } } return buf . toString () ; }
buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S]
public List getMissingOptions () { return missingOptions ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[NegateConditionalsMutator]MSP[S]
buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
buf . append ( lr_5 ) ; } } return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR6Mutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } return buf . toString () ; }
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR2Mutator]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR3Mutator]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR4Mutator]MSP[S]
buf . append ( lr_5 ) ; } } return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR2Mutator]MSP[N]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR1Mutator]MSP[N]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR5Mutator]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR4Mutator]MSP[N]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR3Mutator]MSP[S]
buf . append ( lr_5 ) ; } } return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return buf . toString () ; }
public List getMissingOptions () { return missingOptions ; MST[ReturnValsMutator]MSP[N] } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR5Mutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[InlineConstantMutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; }
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; } @Override public String toString () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void asEndTag () { values . clear () ; } @Deprecated public boolean MST[rv.ROR5Mutator]MSP[N] ( final String value ) { throw new UnsupportedOperationException ( lr_10 + lr_11 ) ; } boolean acceptsArg () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder anythingElse ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[NegateConditionalsMutator]MSP[S] } public String [] getValues () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[InlineConstantMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[NegateConditionalsMutator]MSP[S] {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[ReturnValsMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR3Mutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return hasNoValues () ? null : values . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.ABSMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; MST[NonVoidMethodCallMutator]MSP[N] return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI3Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI4Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[InlineConstantMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR2Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI2Mutator]MSP[N] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[N] option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String [] getValues () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[InlineConstantMutator]MSP[S]
return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] { option option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] { option option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] { option option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] { option option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] { option option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] { option option . longOpt
return result ; MST[ReturnValsMutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null )
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null )
buf . append ( lr_7 ) . append ( type ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
int index = value . indexOf ( sep ) ; MST[ArgumentPropagationMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI1Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return hasNoValues () ? null : values . get ( index ) ; MST[ReturnValsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI4Mutator]MSP[N]
return hasNoValues () ? null : values . get ( index ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[rv.ROR5Mutator]MSP[N] } public String [] getValues () {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return values . isEmpty () ; MST[ReturnValsMutator]MSP[N] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR5Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[ConditionalsBoundaryMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[VoidMethodCallMutator]MSP[N]
value = value . substring ( index + 1 ) ; MST[rv.UOI1Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { )
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR3Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { opt option . longOpt != null ) { : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[NonVoidMethodCallMutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR3Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return values . isEmpty () ; } return acceptsArg () ; MST[BooleanTrueReturnValsMutator]MSP[S] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; MST[experimental.MemberVariableMutator]MSP[N] } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[BooleanTrueReturnValsMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR3Mutator]MSP[S]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR4Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR2Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null )
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[N] } buf . append ( lr_4 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI3Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
if ( hasArgs () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () {
return hasNoValues () ? null : values . get ( index ) ; MST[NegateConditionalsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] { option option != null ) MST[NegateConditionalsMutator]MSP[N] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[InlineConstantMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR3Mutator]MSP[S] {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { : option . longOpt != null ) { : option . longOpt != null ) { : option . longOpt != null ) { : option . longOpt != null ) { :
{ return argName != null && argName . length () > 0 ; MST[rv.ROR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[ReturnValsMutator]MSP[N] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; MST[ConstructorCallMutator]MSP[N] return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[InlineConstantMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR5Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[S] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD1Mutator]MSP[S]
if ( this == o ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { )
return longOpt != null ; MST[ReturnValsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI1Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
{ return argName != null && argName . length () > 0 ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR2Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null )
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; MST[VoidMethodCallMutator]MSP[N] } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR3Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; MST[rv.UOI4Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[ConstructorCallMutator]MSP[N] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return false ; } return true ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[experimental.MemberVariableMutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
value = value . substring ( index + 1 ) ; MST[rv.AOD2Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[NonVoidMethodCallMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI4Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[ReturnValsMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[NegateConditionalsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD1Mutator]MSP[S]
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ABSMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR1Mutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI4Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] { option option != null ) MST[NegateConditionalsMutator]MSP[N] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.ABSMutator]MSP[S]
{ return argName != null && argName . length () > 0 ; MST[rv.ROR2Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return values . isEmpty () ; } return acceptsArg () ; MST[ReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public boolean equals ( final Object o ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[rv.ROR5Mutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI4Mutator]MSP[N] }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } final Option option = ( Option ) o ;
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[ReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return longOpt != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.ABSMutator]MSP[N]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI3Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return hasNoValues () ? null : values . get ( index ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[NegateConditionalsMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; MST[ReturnValsMutator]MSP[N] } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; }
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ABSMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOD2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[NegateConditionalsMutator]MSP[S]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR3Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI1Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR2Mutator]MSP[N] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR3Mutator]MSP[S]
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR2Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR4Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { {
if ( hasArgs () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI4Mutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR5Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
buf . append ( lr_7 ) . append ( type ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[NonVoidMethodCallMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.ROR5Mutator]MSP[N]
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI1Mutator]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null )
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[NegateConditionalsMutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI3Mutator]MSP[S]
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( type != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( type != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR3Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR3Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR3Mutator]MSP[N] { option option != null ) MST[rv.ROR3Mutator]MSP[S] { option option != null ) MST[rv.ROR3Mutator]MSP[N] { option option != null ) MST[rv.ROR3Mutator]MSP[S] { option option != null ) MST[rv.ROR3Mutator]MSP[S] { option option !=
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[ConditionalsBoundaryMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } public int getArgs () { return numberOfArgs ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR3Mutator]MSP[S]
return values . isEmpty () ; } return acceptsArg () ; MST[BooleanFalseReturnValsMutator]MSP[S] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { :
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; MST[experimental.MemberVariableMutator]MSP[N] } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; MST[ReturnValsMutator]MSP[N] } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR5Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
return result ; MST[PrimitiveReturnsMutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI4Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ReturnValsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
value = value . substring ( index + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
buf . append ( lr_7 ) . append ( type ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return longOpt != null ; MST[rv.CRCR2Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR1Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { )
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR6Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[ReturnValsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ABSMutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI3Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { option option != null )
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR1Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated Object getType () { return type ; MST[ReturnValsMutator]MSP[N] }
public int getId () { return getKey () . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[InlineConstantMutator]MSP[S]
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
int index = value . indexOf ( sep ) ; MST[rv.UOI2Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR2Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] { option option != null ) MST[NegateConditionalsMutator]MSP[N] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] { option option != null ) MST[NegateConditionalsMutator]MSP[S] {
return values . isEmpty () ; } return acceptsArg () ; MST[NonVoidMethodCallMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; MST[ReturnValsMutator]MSP[N] } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired () MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired () MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired () MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired () { } public boolean isRequired () MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[NullReturnValsMutator]MSP[S] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
value = value . substring ( index + 1 ) ; MST[rv.UOI2Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
if ( this == o ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR5Mutator]MSP[N] {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[ReturnValsMutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI2Mutator]MSP[N] }
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; MST[VoidMethodCallMutator]MSP[N] } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[experimental.MemberVariableMutator]MSP[N] }
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.ABSMutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[MathMutator]MSP[S]
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR4Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR3Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI4Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[ReturnValsMutator]MSP[N] } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR4Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR4Mutator]MSP[N] { option option != null ) MST[rv.ROR4Mutator]MSP[N] { option option != null ) MST[rv.ROR4Mutator]MSP[N] { option option != null ) MST[rv.ROR4Mutator]MSP[N] { option option != null ) MST[rv.ROR4Mutator]MSP[N] { option option != null ) MST[rv.ROR4Mutator]MSP[N] { option option != null )
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.ABSMutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { :
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR3Mutator]MSP[S]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void asEndTag () { values . clear () ; } @Deprecated public boolean MST[rv.ROR5Mutator]MSP[N] ( final String value ) { throw new UnsupportedOperationException ( lr_10 MST[ConstructorCallMutator]MSP[S] + lr_11 ) ; } boolean acceptsArg () {
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; MST[experimental.MemberVariableMutator]MSP[N] } public String getLongOpt () { return longOpt ; }
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[InlineConstantMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR4Mutator]MSP[N] {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI2Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[InlineConstantMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR3Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( this == o ) { return true ; MST[ReturnValsMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; } } public Object getType () { return type ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR3Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[InlineConstantMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[ReturnValsMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[NonVoidMethodCallMutator]MSP[N]
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
if ( this == o ) MST[rv.ROR5Mutator]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[BooleanTrueReturnValsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
{ return required ; MST[ReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD2Mutator]MSP[N]
if ( this == o ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[InlineConstantMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder type ( final Class < ? > type ) { this . type = type ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[PrimitiveReturnsMutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.ABSMutator]MSP[N] }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI1Mutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR6Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
throw new RuntimeException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[rv.CRCR5Mutator]MSP[N] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( this == o ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
value = value . substring ( index + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; MST[experimental.NakedReceiverMutator]MSP[N] option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[NegateConditionalsMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasArgName
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[ReturnValsMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] { option option != null ) MST[rv.ROR1Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
value = value . substring ( index + 1 ) ; MST[rv.ABSMutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR4Mutator]MSP[N]
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR1Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR5Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_4 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR1Mutator]MSP[S]
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[ReturnValsMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( this == o ) { return true ; MST[InlineConstantMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[N] ( MST[rv.ROR5Mutator]MSP[N] = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] char sep = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[S] char char sep = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] ) = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[S] char char sep = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[S] } sep = getValueSeparator () ; null char sep = getValueSeparator
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR1Mutator]MSP[S] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) MST[NegateConditionalsMutator]MSP[S] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return values . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI3Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final Option option = ( Option ) o ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR4Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[ConditionalsBoundaryMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ConditionalsBoundaryMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD2Mutator]MSP[N]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR4Mutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[BooleanFalseReturnValsMutator]MSP[S] } public boolean hasLongOpt () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { {
int index = value . indexOf ( sep ) ; MST[rv.ABSMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return false ; MST[InlineConstantMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[InlineConstantMutator]MSP[S] {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR3Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null ) MST[rv.ROR5Mutator]MSP[N] { option option != null )
if ( this == o ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI1Mutator]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[InlineConstantMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR5Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR4Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { )
return values . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { :
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR4Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void asEndTag () { values . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Deprecated public boolean MST[rv.ROR5Mutator]MSP[N] ( final String value ) { throw new UnsupportedOperationException ( lr_10 + lr_11 ) ; } boolean acceptsArg () {
{ return argName != null && argName . length () > 0 ; MST[InlineConstantMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI3Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ABSMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR2Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR4Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[NegateConditionalsMutator]MSP[S] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[ConditionalsBoundaryMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI2Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR5Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[N] } buf . append ( lr_4 ) ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[InlineConstantMutator]MSP[S] } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired ()
public Builder required () { return required ( true ) ; MST[InlineConstantMutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOD1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[ArgumentPropagationMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI2Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[InlineConstantMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { ) option . longOpt != null ) { : option . longOpt != null ) { )
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR1Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } final Option option = ( Option ) o ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR2Mutator]MSP[S]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] { option option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] { return option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] { return option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] { return option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] { return option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] { new option . longOpt
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR3Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR1Mutator]MSP[S]
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[NullReturnValsMutator]MSP[S] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR5Mutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR6Mutator]MSP[S] {
return values . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( type != null ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[ReturnValsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI1Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR3Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder hasArg () { return hasArg ( true ) ; }
value = value . substring ( index + 1 ) ; MST[rv.UOI3Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[NegateConditionalsMutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return longOpt != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR6Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR6Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR5Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[rv.ROR5Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI2Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.ABSMutator]MSP[N] return this ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[InlineConstantMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
{ return required ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR4Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
{ return argName != null && argName . length () > 0 ; MST[InlineConstantMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR1Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return result ; MST[rv.ABSMutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; MST[PrimitiveReturnsMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ConditionalsBoundaryMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[ConstructorCallMutator]MSP[S] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null )
if ( opt == null && longOpt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR2Mutator]MSP[N] { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String toString () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; MST[rv.UOI3Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[S] } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; MST[VoidMethodCallMutator]MSP[N] } private void add ( final String value ) { if ( ! acceptsArg () ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[ReturnValsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () { return type ; } public Object getType () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return option . longOpt != null ) { return
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[MathMutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder type ( final Class < ? > type ) { this . type = type ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI3Mutator]MSP[N] }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.ABSMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR2Mutator]MSP[S]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR3Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] option . longOpt != null ) { : option . longOpt != null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ; final char sep = getValueSeparator () ;
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; MST[ReturnValsMutator]MSP[N] }
return longOpt != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR6Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI1Mutator]MSP[N] }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR3Mutator]MSP[S] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder anythingElse ( final String description ) { this . description = description ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder longOpt ( final String longOpt ) {
if ( hasArgs () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; MST[ReturnValsMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI3Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { option option != null )
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR1Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; MST[rv.UOI1Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[NegateConditionalsMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
buf . append ( lr_7 ) . append ( type ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[ReturnValsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; MST[NullReturnValsMutator]MSP[S] } @Deprecated Object getType () { return type ; MST[NullReturnValsMutator]MSP[S] } @Deprecated Object getType () { return type ; MST[NullReturnValsMutator]MSP[S] } @Deprecated Object getType () { return type ; MST[NullReturnValsMutator]MSP[S] } @Deprecated Object getType () { return type ; MST[NullReturnValsMutator]MSP[S] } @Deprecated Object getType () { return type ; MST[NullReturnValsMutator]MSP[S] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; MST[NullReturnValsMutator]MSP[S] } catch ( final CloneNotSupportedException cnse ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return longOpt != null ; MST[InlineConstantMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired () { public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public boolean isRequired () { } public
return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI4Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.ROR5Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; MST[InlineConstantMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR6Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR2Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI3Mutator]MSP[N] }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; MST[experimental.MemberVariableMutator]MSP[N] return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[MathMutator]MSP[S]
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( type != null ) {
if ( hasArgs () ) { buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI2Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[ReturnValsMutator]MSP[S] } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[rv.ROR1Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; MST[ReturnValsMutator]MSP[N] } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { MST[NonVoidMethodCallMutator]MSP[N] option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { { option . longOpt != null ) { {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR1Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR1Mutator]MSP[N]
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI3Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ABSMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return required ; MST[BooleanFalseReturnValsMutator]MSP[S] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ; } public boolean hasArgName () { return argName ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[NullReturnValsMutator]MSP[S] }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ; MST[experimental.MemberVariableMutator]MSP[N]
return this ; MST[NullReturnValsMutator]MSP[S] } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR2Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR6Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR3Mutator]MSP[N] }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder required () { return required ( true ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder argName ( final String argName ) { this . argName = argName ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder anythingElse ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[NullReturnValsMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[InlineConstantMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder required () { return required ( true ) ; MST[rv.CRCR2Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI4Mutator]MSP[N] return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[NegateConditionalsMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder anythingElse ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR6Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR5Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR4Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Option build () {
return this ; MST[ReturnValsMutator]MSP[S] } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI3Mutator]MSP[S] return this ; }
public Builder required () { return required ( true ) ; MST[rv.CRCR3Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[NullReturnValsMutator]MSP[N] }
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[S] } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI1Mutator]MSP[N] return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[InlineConstantMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder required () { return required ( true ) ; MST[ReturnValsMutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder anythingElse ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
if ( opt == null && longOpt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[ConstructorCallMutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR4Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR5Mutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; MST[NullReturnValsMutator]MSP[S] } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder anythingElse ( final String description ) { this . description = description ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder longOpt ( final String longOpt ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[experimental.MemberVariableMutator]MSP[N] return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; MST[ReturnValsMutator]MSP[N] } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI3Mutator]MSP[S] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder required () { return required ( true ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[ReturnValsMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; MST[NullReturnValsMutator]MSP[S] }
public Builder required () { return required ( true ) ; MST[NullReturnValsMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[ReturnValsMutator]MSP[N] }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI2Mutator]MSP[N] return this ; }
if ( opt == null && longOpt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
this . longOpt = longOpt ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder anythingElse ( final String description ) { this . description = description ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder longOpt ( final String longOpt ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
private static void reset () { description = null ; argName = null ; longopt = null ; type = String . class ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder anythingElse ( final String PatternOptionBuilder ) { OptionBuilder . description = PatternOptionBuilder ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
finally { OptionBuilder . reset () ; } return option ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder anythingElse ( final String PatternOptionBuilder ) { OptionBuilder . description = PatternOptionBuilder ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public MST[NonVoidMethodCallMutator]MSP[S] OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public MST[rv.ABSMutator]MSP[N] ; } public static OptionBuilder isRequired ( final boolean
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType )
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType )
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[ReturnValsMutator]MSP[S] } ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder < ? > ) newType ) ; MST[ReturnValsMutator]MSP[S] } ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder < ? > ) newType ) ; MST[ReturnValsMutator]MSP[S] } ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder < ? > ) newType ) ; MST[ReturnValsMutator]MSP[S] } ; MST[ReturnValsMutator]MSP[N] } public
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; MST[VoidMethodCallMutator]MSP[N] option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; }
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType )
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[InlineConstantMutator]MSP[N]
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ; MST[VoidMethodCallMutator]MSP[N]
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[ReturnValsMutator]MSP[N] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[InlineConstantMutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } MST[rv.CRCR6Mutator]MSP[S] @Deprecated ( ( Class < ? > ) newType ) ; } MST[rv.CRCR6Mutator]MSP[S] public static OptionBuilder < ? > ) newType ) ; } } @Deprecated public static OptionBuilder < ? > ) newType ) ; } } @Deprecated public static OptionBuilder < ? > ) newType )
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.ABSMutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object MST[rv.CRCR1Mutator]MSP[N] > ) newType ) ; } @Deprecated public static OptionBuilder
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder anythingElse ( final String PatternOptionBuilder ) { OptionBuilder . description = PatternOptionBuilder ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; MST[VoidMethodCallMutator]MSP[N] option . setArgName ( argName ) ; } option . setArgName ( argName ) ; } option . setArgName ( argName ) ; } option . setArgName ( argName ) ; } option . setArgName ( argName ) ; } option . setArgName ( argName ) ; } option . setArgName ( argName ) ; } option
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ; MST[ConstructorCallMutator]MSP[S]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI3Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object MST[rv.CRCR1Mutator]MSP[N] > ) newType ) ; } @Deprecated public static OptionBuilder
finally finally OptionBuilder { OptionBuilder . reset () ; } return option ; MST[ReturnValsMutator]MSP[N] }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object MST[rv.CRCR1Mutator]MSP[N] > ) newType ) ; } @Deprecated public static OptionBuilder
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
finally { OptionBuilder . reset () ; MST[VoidMethodCallMutator]MSP[N] } return option ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[NullReturnValsMutator]MSP[N] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } MST[rv.CRCR6Mutator]MSP[S] public static OptionBuilder < ? > ) newType ) ; } } @Deprecated public static OptionBuilder < ? > ) newType ) ; } } @Deprecated public static OptionBuilder < ? > ) newType ) ; } } @Deprecated public static OptionBuilder < ? > ) newType )
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR6Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType )
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; MST[VoidMethodCallMutator]MSP[N] option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } MST[NonVoidMethodCallMutator]MSP[S] . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } MST[NonVoidMethodCallMutator]MSP[S] . setValueSeparator ( valuesep ) ; } . setArgName ( argName ) ; } } . setValueSeparator ( valuesep ) ; } } setArgName ( argName ) ; } longOpt . setValueSeparator (
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[NullReturnValsMutator]MSP[S] } ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder < ? > ) newType ) ; MST[NullReturnValsMutator]MSP[S] } ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder < ? > ) newType ) ; MST[NullReturnValsMutator]MSP[S] } ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder < ? > ) newType ) ; MST[NullReturnValsMutator]MSP[S] } ; MST[NullReturnValsMutator]MSP[S] } public
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[N] return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI4Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] } setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { OptionBuilder . reset () ;
finally finally OptionBuilder { OptionBuilder . reset () ; } return option ; MST[NullReturnValsMutator]MSP[S] }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR6Mutator]MSP[N]
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR4Mutator]MSP[N]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR5Mutator]MSP[N]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR3Mutator]MSP[S]
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[NegateConditionalsMutator]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder anythingElse ( final String PatternOptionBuilder ) { OptionBuilder . description = PatternOptionBuilder ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public MST[NonVoidMethodCallMutator]MSP[S] OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[VoidMethodCallMutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } . setArgName ( argName ) ; } . setArgName ( argName ) ; } option setDescPadding ( argName ) ; } . setArgName ( argName ) ; } option setArgName ( argName ) ; } . setArgName ( argName ) ; } option setArgName ( argName ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR3Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR5Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.ABSMutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[NegateConditionalsMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ABSMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI1Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object MST[rv.CRCR1Mutator]MSP[N] > ) newType ) ; } @Deprecated public static OptionBuilder
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder anythingElse ( final String PatternOptionBuilder ) { OptionBuilder . description = PatternOptionBuilder ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI4Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } @Deprecated public static OptionBuilder withType ( final Object MST[rv.CRCR1Mutator]MSP[N] > ) newType ) ; } @Deprecated public static OptionBuilder
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[rv.ROR5Mutator]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; MST[VoidMethodCallMutator]MSP[N] option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } MST[rv.ROR5Mutator]MSP[S] . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } MST[rv.ROR5Mutator]MSP[S] . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } option . setValueSeparator (
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] }
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[N] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType ) ; } return INSTANCE ; } @Deprecated public static OptionBuilder < ? > ) newType )
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.ABSMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[NonVoidMethodCallMutator]MSP[S] } ; MST[NonVoidMethodCallMutator]MSP[N] } public static OptionBuilder < ? > ) newType ) ; MST[NonVoidMethodCallMutator]MSP[S] } ; MST[NonVoidMethodCallMutator]MSP[N] } public static OptionBuilder < ? > ) newType ) ; MST[NonVoidMethodCallMutator]MSP[S] } ; MST[NonVoidMethodCallMutator]MSP[N] } public static OptionBuilder < ? > ) newType ) ; MST[NonVoidMethodCallMutator]MSP[S] } ; MST[NonVoidMethodCallMutator]MSP[N] } public
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; MST[VoidMethodCallMutator]MSP[N] option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } MST[rv.UOI3Mutator]MSP[S] setArgName ( argName ) ; } } setDescPadding ( argName ) ; } } setDescPadding ( argName ) ; } } setDescPadding ( argName ) ; } } setDescPadding ( argName ) ; } MST[NonVoidMethodCallMutator]MSP[S] setDescPadding ( argName ) ; } return setDescPadding ( argName ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public INSTANCE ;
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR4Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR2Mutator]MSP[N]
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired ( final boolean newRequired ) { { public static OptionBuilder isRequired
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder withLongOpt ( final String bufLength ) { OptionBuilder . longopt = bufLength ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > Request () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; }
return optionMap . values () ; MST[ReturnValsMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > Request () { return optionMap . keySet () ; MST[NonVoidMethodCallMutator]MSP[N] } public Collection < Option > getOptions () {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] } public boolean isRequired () { MST[rv.UOI2Mutator]MSP[N] } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { return selected ; } public boolean isRequired () { } } public boolean isRequired () { return selected ; } public boolean isRequired () { } } public boolean isRequired () { return selected
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
{ return required ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR5Mutator]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > Request () { return optionMap . keySet () ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Collection < Option > getOptions () {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( iter . hasNext () ) {
selected = option . getKey () ; MST[experimental.MemberVariableMutator]MSP[N] } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired () { public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] while ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buff . toString () ; }
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_3 ) ;
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NonVoidMethodCallMutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; MST[ReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired () { public boolean isRequired () { return selected ; MST[ReturnValsMutator]MSP[N] public boolean isRequired () { } public boolean isRequired () { return selected ; MST[ReturnValsMutator]MSP[N] public boolean isRequired () { } public boolean isRequired () { return selected ; MST[ReturnValsMutator]MSP[N] public boolean isRequired () { } public boolean isRequired
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N]
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < String > Request () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[ReturnValsMutator]MSP[N] }
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NegateConditionalsMutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired () { } } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR2Mutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired () { MST[rv.ABSMutator]MSP[S] } public boolean isRequired ()
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; MST[ReturnValsMutator]MSP[N] } public Collection < String > Request () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } buff . append ( lr_6 ) ; return buff . toString () ; }
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
selected = option . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired () { public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired
buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } buff . append ( lr_6 ) ; return buff . toString () ; }
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR5Mutator]MSP[N] {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Collection < String > Request () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired () { } } public boolean isRequired () { return selected ; } } public boolean isRequired () { } } public boolean isRequired () { return selected ; } } public boolean isRequired () { } } public boolean isRequired () { return selected ; } } public boolean
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR3Mutator]MSP[N] {
return optionMap . values () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NonVoidMethodCallMutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; MST[ConstructorCallMutator]MSP[S] } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired () { } public boolean isRequired () { return selected ; } public boolean isRequired
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR1Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buff . toString () ; }
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[ArgumentPropagationMutator]MSP[N] return this ; } public Collection < String > Request () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
{ return required ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
{ return required ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired () { public boolean isRequired () { } public boolean isRequired () { return selected ; MST[EmptyObjectReturnValsMutator]MSP[N] public boolean isRequired () { } public boolean isRequired () { return selected ; MST[EmptyObjectReturnValsMutator]MSP[N] public boolean isRequired () { } public boolean isRequired () { return selected ; MST[EmptyObjectReturnValsMutator]MSP[N] public boolean isRequired
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR4Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; MST[experimental.MemberVariableMutator]MSP[N] return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < String > Request () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
return optionMap . values () ; MST[NonVoidMethodCallMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[S] } public boolean isRequired () { MST[rv.UOI3Mutator]MSP[S] } public boolean isRequired () { MST[rv.UOI3Mutator]MSP[S] } public boolean isRequired () { MST[rv.UOI3Mutator]MSP[S] } public boolean isRequired () { ; } public boolean isRequired () { { } public boolean isRequired () { ; } public boolean isRequired () { { } public boolean isRequired ()
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NegateConditionalsMutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > Request () { return optionMap . keySet () ; MST[ReturnValsMutator]MSP[N] } public Collection < Option > getOptions () {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] . put opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( opt
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[VoidMethodCallMutator]MSP[N] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
{ addOption ( opt , null , false , description ) ; MST[InlineConstantMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
return this ; MST[NullReturnValsMutator]MSP[S] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if (
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public List getRequiredOptions () {
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[S] }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR1Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[N] }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List getRequiredOptions () {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] . put ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] byIdCache . put opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[S] . ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] byIdCache . ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[S] . put
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[S] . put ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] . put ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] . put ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] } if ( opt . isRequired () )
{ if ( requiredOpts . contains ( key ) ) MST[NegateConditionalsMutator]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR5Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ArgumentPropagationMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.ABSMutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR3Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[ReturnValsMutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR1Mutator]MSP[N] addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.ABSMutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { } if ( opt . isRequired ()
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[N] }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR5Mutator]MSP[N] addOption ( option ) ;
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR1Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
public Options addOptionGroup ( final OptionGroup group ) MST[ConstructorCallMutator]MSP[N] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired ()
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[ReturnValsMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NegateConditionalsMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI3Mutator]MSP[N] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return shortOpts . get ( opt ) ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < String > matchingOpts = new ArrayList < String > () ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( opt
optionGroups . put ( option . getKey () , group ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR2Mutator]MSP[N] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { } if ( opt . isRequired ()
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { } if ( opt . isRequired ()
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR6Mutator]MSP[N] addOption ( option ) ;
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR3Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR5Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR4Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR2Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ReturnValsMutator]MSP[N] } public List getRequiredOptions () {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[InlineConstantMutator]MSP[S] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[ConstructorCallMutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI4Mutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { } if ( opt . isRequired ()
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NullReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NegateConditionalsMutator]MSP[S] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[ReturnValsMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[N] }
return longOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[S] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[N] }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI1Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; }
buf . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { } if ( opt . isRequired ()
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if (
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ReturnValsMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[N] }
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final
public Options addOptionGroup ( final OptionGroup group ) MST[experimental.MemberVariableMutator]MSP[N] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ addOption ( opt , null , false , description ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] . ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] . ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] . ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] . ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] . ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] . ( opt
{ addOption ( opt , null , false , description ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.ABSMutator]MSP[N] return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR3Mutator]MSP[S] {
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N]
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR2Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) MST[NonVoidMethodCallMutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) MST[NonVoidMethodCallMutator]MSP[N] { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; return this ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[ArgumentPropagationMutator]MSP[N] return this ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N]
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR2Mutator]MSP[N] }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR4Mutator]MSP[N] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR3Mutator]MSP[N] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { } if ( opt . isRequired ()
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] ) ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] ) ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] ) ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] ) ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N]
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[InlineConstantMutator]MSP[N] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR5Mutator]MSP[N] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[N] }
return this ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if ( opt . isRequired () ) { longOpts if (
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ConstructorCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ConstructorCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ConstructorCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ConstructorCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ConstructorCallMutator]MSP[N] } public
buf . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[NonVoidMethodCallMutator]MSP[N] } public
return Collections . unmodifiableList ( requiredOpts ) ; MST[ReturnValsMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( opt . isRequired () ) ) ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt .
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR1Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] longOpts put ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] longOpts put ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] longOpts put ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] longOpts put ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] longOpts put ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] longOpts put ( opt
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[ReturnValsMutator]MSP[N] } public
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR4Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR3Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return longOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[N] return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NegateConditionalsMutator]MSP[S] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR2Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_3 ) ; return buf . toString () ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR1Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR4Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR5Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI2Mutator]MSP[N] return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { } if ( opt . isRequired ()
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_3 ) ; return buf . toString () ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[N] return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ConstructorCallMutator]MSP[N] } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[ReturnValsMutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[ArgumentPropagationMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR3Mutator]MSP[N] addOption ( option ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR6Mutator]MSP[N] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N]
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Options addOption ( final String opt , final String description ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Options addOption ( final String opt , final String description ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Options addOption ( final String opt , final String description ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] . put ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] . ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] . put ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] .
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[VoidMethodCallMutator]MSP[N] addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR3Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired () ) { longOpts } if ( opt . isRequired ()
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] . put ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
return Collections . unmodifiableList ( requiredOpts ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[ConstructorCallMutator]MSP[N] return this ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[ReturnValsMutator]MSP[N] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final String opt , final String description ) ; } public Options addOption ( final
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR4Mutator]MSP[N] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { } if ( opt . isRequired ()
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( longOpt . startsWith ( opt ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ABSMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N]
return Character . isJavaIdentifierPart ( c ) ; MST[rv.ABSMutator]MSP[S] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI1Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR1Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR2Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NegateConditionalsMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[NegateConditionalsMutator]MSP[S] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.ABSMutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI4Mutator]MSP[S] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) )
return Character . isJavaIdentifierPart ( c ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[ConstructorCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.ABSMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ABSMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR3Mutator]MSP[S] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[NonVoidMethodCallMutator]MSP[N] if ( ! isValidOpt ( ch ) )
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[ConstructorCallMutator]MSP[N]
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI1Mutator]MSP[N] }
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ABSMutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI1Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[NegateConditionalsMutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[ReturnValsMutator]MSP[S] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI4Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.ABSMutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.ABSMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[InlineConstantMutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI1Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
return Character . isJavaIdentifierPart ( c ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI4Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) )
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) )
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI3Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI2Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI4Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI1Mutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR1Mutator]MSP[N] if ( ! isValidOpt ( ch ) )
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) { MST[rv.CRCR3Mutator]MSP[N] if ( ! isValidOpt ( ch ) )
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.ABSMutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NegateConditionalsMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI3Mutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ABSMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI4Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[ReturnValsMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[BooleanTrueReturnValsMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI3Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI4Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI2Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[NonVoidMethodCallMutator]MSP[S] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI1Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NonVoidMethodCallMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI3Mutator]MSP[S] }
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI2Mutator]MSP[N] }
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt ( ch ) ) { if ( ! isValidOpt
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NegateConditionalsMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI3Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI3Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI3Mutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) { opt . asEndTag () ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) { final String str = iter . next () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
getRequiredOptions () . remove ( group ) ; } group . setSelected ( opt ) ; } }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR2Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.ABSMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N] if ( arguments == null ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N] if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { final String str = iter . next () ;
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final ListIterator iterator () ) { MST[rv.ROR5Mutator]MSP[N] ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] req , stopAtNonOption () ; while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] readerPos , stopAtNonOption () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[S] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI1Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI2Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[N] } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[S] { try { opt . addValueForProcessing ( value ) ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; MST[ReturnValsMutator]MSP[N] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI3Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] {
{ final String t = iterator . next () ; MST[NonVoidMethodCallMutator]MSP[N] if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; MST[ConstructorCallMutator]MSP[S] } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
protected void setOptions ( final Options options ) { this . options = options ; MST[experimental.MemberVariableMutator]MSP[N] this . req = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { final String str = iter . next () ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; }
getRequiredOptions () . remove ( group ) ; } group . setSelected ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } }
final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; } else {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } group . setSelected ( opt ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[N] {
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[ReturnValsMutator]MSP[N] } protected List getRequiredOptions () { return cl ; }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[S] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR1Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; MST[VoidMethodCallMutator]MSP[N] } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[ArgumentPropagationMutator]MSP[N] } catch ( final RuntimeException exp ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[N] return cmd ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
arguments = new String [ 0 ] ; MST[InlineConstantMutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final Option . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ListIterator iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ListIterator iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ListIterator iterator hasNext hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ListIterator iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final ListIterator iterator .
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[N] }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] final ListIterator iterator
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NegateConditionalsMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ABSMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; MST[VoidMethodCallMutator]MSP[N] cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } group . setSelected ( opt ) ; } }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI3Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) MST[NonVoidMethodCallMutator]MSP[N] { opt . asEndTag () ; }
processOption ( t , iterator ) ; MST[VoidMethodCallMutator]MSP[N] } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ABSMutator]MSP[N] { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI4Mutator]MSP[N] { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[N] {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; MST[ConstructorCallMutator]MSP[S] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[S] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iterator . hasNext () ) = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iterator . hasNext () ) = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iterator . hasNext () ) = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iterator . hasNext () ) = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N]
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N] if ( arguments == null ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; MST[NonVoidMethodCallMutator]MSP[N] break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR4Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[N] checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[N] {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[N] { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; MST[EmptyObjectReturnValsMutator]MSP[S] }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return cl ; }
arguments = new String [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
arguments = new String [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[VoidMethodCallMutator]MSP[N] } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[rv.ROR5Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { try { opt . addValueForProcessing ( value ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final ListIterator iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final ListIterator iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final ListIterator iterator . hasNext ()
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NonVoidMethodCallMutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[N] boolean eatTheRest = false ; if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[NegateConditionalsMutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI2Mutator]MSP[N] { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] {
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) { opt . asEndTag () ; MST[VoidMethodCallMutator]MSP[N] }
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; MST[VoidMethodCallMutator]MSP[N] } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[N] }
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[NegateConditionalsMutator]MSP[S] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final String str = iter . next () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI4Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { final String str = iter . next () ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[N] }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR3Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Option . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final ListIterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final Option . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final ListIterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final ListIterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR5Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
protected void setOptions ( final Options options ) { this . options = options ; this . req = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[NullReturnValsMutator]MSP[S] } protected List getRequiredOptions () { return cl ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[InlineConstantMutator]MSP[N] if ( arguments == null ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] final iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] final ListIterator iterator .
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] final Option . hasNext () ) MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] return iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] final ListIterator iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] return ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] final ListIterator () hasNext hasNext
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[N] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; MST[NonVoidMethodCallMutator]MSP[N] break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[rv.ROR5Mutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[N] boolean eatTheRest = false ; if ( arguments == null ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[ArgumentPropagationMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI3Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { try { opt . addValueForProcessing ( value ) ; }
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { while ( iterator . hasNext () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator . hasNext () ) = tokenList . listIterator () ; while ( iterator .
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final boolean iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final ListIterator iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final ListIterator iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final ListIterator iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final ListIterator iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] MST[NegateConditionalsMutator]MSP[N] final ListIterator iterator
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N] if ( arguments == null ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[S] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NegateConditionalsMutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI1Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[N] {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] size . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] MST[ReturnValsMutator]MSP[N] ++ () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] tokenList < stopAtNonOption () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] tokenList < stopAtNonOption () ; while ( iterator . hasNext ()
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[N] { continue; } cmd . addOption ( opt ) ;
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[MathMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR5Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . size ) ) ; ( 0 ( token , matchingOpts ( matchingOpts . get ( 0
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[ConstructorCallMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[NegateConditionalsMutator]MSP[S] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( token . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] { if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } gobble ( iter ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOD2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; . add ( token
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[ConstructorCallMutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[MathMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( pos != - 1 ) MST[InlineConstantMutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR4Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( MST[ReturnValsMutator]MSP[N] . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt )
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
if ( pos != - 1 ) MST[rv.CRCR1Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option ( 0 ) ) ; ( ( ( 0 ) ) ; ( ( ( 0 ) ) ; ( ( ( 0 ) ) ; ( ( ( 0
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] break; . add ( token
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR2Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; . add ( token
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; }
private void init () { eatTheRest = false ; MST[experimental.MemberVariableMutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( lr_1 ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( token ) ) MST[NegateConditionalsMutator]MSP[S] ) lr_2 . ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( lr_1 ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] ( lr_1 (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ;
if ( pos != - 1 ) MST[rv.UOI2Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ; MST[experimental.MemberVariableMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } gobble ( iter ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[S] { if ( lr_1 ( token ) ) MST[rv.ROR4Mutator]MSP[N] { if ( token ) ) MST[rv.ROR4Mutator]MSP[N] final String ( token ) ) MST[rv.ROR4Mutator]MSP[S] { if ( token ) ) MST[rv.ROR4Mutator]MSP[N] final String ( token ) ) MST[rv.ROR4Mutator]MSP[S] final String ( token ) ) MST[rv.ROR4Mutator]MSP[S] final String ( token )
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR1Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] break; . add ( token
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.CRCR6Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[experimental.NakedReceiverMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } }
} } else if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI3Mutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
else if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ReturnValsMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { while ( iter . hasNext () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { while ( iter . hasNext () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } gobble ( iter ) ; }
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[NegateConditionalsMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . size ) ) ; ( get opt ) ; ( 0 ( token . getOption (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break; . add ( token
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( pos != - 1 ) MST[rv.UOI4Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] break; . add ( token
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR1Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
} } else if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR3Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR3Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR4Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; MST[experimental.MemberVariableMutator]MSP[N] if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ;
if ( pos != - 1 ) MST[rv.ABSMutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( lr_1 ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N]
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR4Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . size ) ) ; ( 0
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 ( token , getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt )
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR3Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } gobble ( iter ) ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] ( lr_1 ( token ) ) MST[rv.ROR3Mutator]MSP[S] ) ) . equals ( token ) ) MST[rv.ROR3Mutator]MSP[S] { if ( token ) ) MST[rv.ROR3Mutator]MSP[S] { if ( token
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; MST[VoidMethodCallMutator]MSP[N] this . options = options ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( pos != - 1 ) MST[rv.CRCR5Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR6Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[experimental.MemberVariableMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[InlineConstantMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) MST[rv.UOI3Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( lr_1 ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( token ) ) MST[NegateConditionalsMutator]MSP[S] ) lr_2 . ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] ( lr_1 ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[NegateConditionalsMutator]MSP[S] if ( token ) ) MST[NegateConditionalsMutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] ( lr_1 (
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI4Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { while ( iter . hasNext () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] break; . add ( token
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[S] { if ( lr_1 ( token ) ) MST[rv.ROR4Mutator]MSP[N] { if ( token ) ) MST[rv.ROR4Mutator]MSP[N] final String ( token ) ) MST[rv.ROR4Mutator]MSP[S] { if ( token ) ) MST[rv.ROR4Mutator]MSP[N] final String ( token ) ) MST[rv.ROR4Mutator]MSP[S] final String ( token ) ) MST[rv.ROR4Mutator]MSP[S] final String ( token )
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[InlineConstantMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( get opt ) ; ( 0 ) ) ; ( Option opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; throw new AmbiguousOptionException opt = options . getOption ( matchingOpts . get ( 0 ) ) ; if new
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR3Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( get opt ) ; ( 0 ) ) ; ( get opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; throw new AmbiguousOptionException opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break; . add ( token
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } () MST[ReturnValsMutator]MSP[N] , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } (
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR6Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR2Mutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR2Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt )
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
else if ( matchingOpts . size () > 1 ) MST[rv.ROR3Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] break; . add ( token
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[S] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[NonVoidMethodCallMutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt )
if ( pos != - 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR5Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] break; . add ( token
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} } else if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] ( lr_1 ( token ) )
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( lr_1 ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token )
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOD1Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { while ( iter . hasNext () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { while ( iter . hasNext () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( pos != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NullReturnValsMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR3Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . size ) ) ; ( 0
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ;
else if ( matchingOpts . size () > 1 ) MST[InlineConstantMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { while ( iter . hasNext () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
if ( options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] if ( token ) ) MST[rv.ROR3Mutator]MSP[S] MST[rv.ROR3Mutator]MSP[S] ( lr_1 ( token ) ) MST[rv.ROR3Mutator]MSP[S] ) ) . equals ( token ) ) MST[rv.ROR3Mutator]MSP[S] { if ( token ) ) MST[rv.ROR3Mutator]MSP[S] { if ( token
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR2Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; if new AmbiguousOptionException opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[ConditionalsBoundaryMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; ( getSyntaxPrefix opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( OptionGroup ( options
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[InlineConstantMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
} } else if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR2Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; MST[experimental.MemberVariableMutator]MSP[N] } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
private void init () { eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void init () { eatTheRest = false ; MST[InlineConstantMutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } gobble ( iter ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[experimental.MemberVariableMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[VoidMethodCallMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI1Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) MST[ConditionalsBoundaryMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) MST[NonVoidMethodCallMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[S] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] final Option opt = options . getOption ( matchingOpts . get ( 0 ) )
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
private void init () { eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR4Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ;
} } else if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; } if token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[N] break; . add ( token
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ABSMutator]MSP[S] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[N] } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] if ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[S] ( lr_1 ( token ) )
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( lr_1 ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token ) ) MST[rv.ROR2Mutator]MSP[N] MST[rv.ROR2Mutator]MSP[N] if ( token )
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] break; . add ( token
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR5Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( get opt ) ; ( 0 ) ) ; ( get opt ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; throw new AmbiguousOptionException opt = options . getOption ( matchingOpts . get ( 0 ) ) ; if new
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR1Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . size ) ) ; ( get
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR2Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . size ) ) ; ( 0 ( token . getOption ( matchingOpts . get ( 0
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( Option ) ) ; ( 0 ) ) ; ( Option opt ) ; ( 0 . String , matchingOpts ( matchingOpts . get ( 0 ) ) ; ( Option opt ) ; ( 0 . String , matchingOpts ( matchingOpts . get ( 0 ) )
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR6Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ) ) ; ( 0 ( options . getOption ( matchingOpts . get ( 0 ) ) ; if new AmbiguousOptionException opt = options . getOption ( matchingOpts . get ( 0
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; MST[ConstructorCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR1Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[S] MST[rv.ROR5Mutator]MSP[S] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] if ( token ) ) MST[rv.ROR5Mutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.ABSMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI3Mutator]MSP[S] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] if ( token . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] { if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N] if ( token ) ) MST[rv.ROR1Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[InlineConstantMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[NonVoidMethodCallMutator]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; MST[VoidMethodCallMutator]MSP[N] }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR3Mutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] break; . add ( token
private void init () { eatTheRest = false ; tokens . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } MST[rv.UOI1Mutator]MSP[N] } token stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } } ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } MST[rv.UOI1Mutator]MSP[N] } token stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } } MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token
if ( options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { while ( iter . hasNext () ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
} } else if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) || lr_2 . equals ( token ) ) ||
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR5Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR6Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[experimental.MemberVariableMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR5Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; . add ( token
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.CRCR2Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( pos != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[S] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[NonVoidMethodCallMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break; . add ( token
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI2Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
if ( pos != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] break; . add ( token
tokens . add ( lr_1 + ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR4Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR1Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
else if ( matchingOpts . size () > 1 ) MST[rv.ROR5Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] break; . add ( token
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] break; . add ( token
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
if ( pos != - 1 ) MST[rv.UOI1Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] break; . add ( token
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
else if ( matchingOpts . size () > 1 ) MST[NegateConditionalsMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.ABSMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; } ( token , stopAtNonOption ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring ( i + 1 ) ) ; break; . add ( token . substring (
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] break; . add ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] break; . add ( token
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
private void init () { eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
private void init () { eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
{ tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ;
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; } @SuppressWarnings ( lr_1 )
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
throw new UnsupportedOperationException ( lr_5 ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try { createURL ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str
else { throw new ParseException ( lr_2 + clazz ) ; } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassNotFoundException cl ) { MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassNotFoundException cl ) { MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassNotFoundException cl ) { MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassNotFoundException cl ) { MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassNotFoundException cl ) { MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ClassNotFoundException cl ) { MST[NonVoidMethodCallMutator]MSP[N] } catch (
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; MST[ReturnValsMutator]MSP[S] }
else { throw new ParseException ( lr_2 + clazz ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } return Long . valueOf ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } } else if ( str ) ; } return ( T ) createDate ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ;
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
return ( T ) openFile ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; MST[NullReturnValsMutator]MSP[S] }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try lr_5 createFile ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str ) throws ParseException { try { try { try { URL ( final String str ) throws ParseException
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; MST[NullReturnValsMutator]MSP[S] } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[S] } public static URL createURL ( final String str ) throws ParseException { try { public static URL createURL ( final String str ) throws ParseException { try { public static URL createURL ( final String str ) throws ParseException { try { public static URL createURL ( final String str ) throws ParseException { try { public static URL createURL ( final String
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; MST[ReturnValsMutator]MSP[N] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR2Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[ConstructorCallMutator]MSP[S] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File [] createFiles ( final String str ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } }
throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] {
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; MST[NullReturnValsMutator]MSP[S] }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { else if ( PatternOptionBuilder .
return new URL ( str ) ; MST[ConstructorCallMutator]MSP[S] } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR5Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR6Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; MST[ReturnValsMutator]MSP[N] } if ( str ) ; MST[ReturnValsMutator]MSP[N] } } if ( str ) ; MST[ReturnValsMutator]MSP[N] } } if ( str ) ; MST[ReturnValsMutator]MSP[N] } } if ( str ) ; MST[ReturnValsMutator]MSP[N] } } if ( str ) ; MST[ReturnValsMutator]MSP[N] } } if ( str ) ; MST[ReturnValsMutator]MSP[N] } } if
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { else if ( PatternOptionBuilder .
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR1Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR5Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR3Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR2Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[InlineConstantMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return ( T ) openFile ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] {
return new URL ( str ) ; MST[ReturnValsMutator]MSP[N] } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[ArgumentPropagationMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
else { throw new ParseException ( lr_2 + clazz ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createDate ( str ) ; } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str )
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; MST[ReturnValsMutator]MSP[N] }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; MST[NullReturnValsMutator]MSP[S] } return Long . valueOf ( str ) ; }
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; MST[ConstructorCallMutator]MSP[S] } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR1Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
throw new UnsupportedOperationException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[S] }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[ConstructorCallMutator]MSP[S] } }
return ( T ) createObject ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; MST[NullReturnValsMutator]MSP[S] } @SuppressWarnings ( lr_1 )
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; MST[NullReturnValsMutator]MSP[S] } } if ( str ) ; MST[NullReturnValsMutator]MSP[S] } } if ( str ) ; MST[NullReturnValsMutator]MSP[S] } } if ( str ) ; MST[NullReturnValsMutator]MSP[S] } } if ( str ) ; MST[NullReturnValsMutator]MSP[S] } } if ( str ) ; MST[NullReturnValsMutator]MSP[S] } } if ( str ) ; MST[NullReturnValsMutator]MSP[S] } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
else { throw new ParseException ( lr_2 + clazz ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } } else if ( str ) ; } return ( T ) createURL ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ;
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try { createURL ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; MST[ReturnValsMutator]MSP[N] }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; MST[ReturnValsMutator]MSP[N] } return Long . valueOf ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; MST[NullReturnValsMutator]MSP[S] } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[ReturnValsMutator]MSP[S]
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
return new URL ( str ) ; MST[NullReturnValsMutator]MSP[S] } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try lr_5 createFile ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str ) throws ParseException { try { try { try { URL ( final String str ) throws ParseException
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR2Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; MST[ReturnValsMutator]MSP[N] } @SuppressWarnings ( lr_1 )
return ( T ) createObject ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { else if ( PatternOptionBuilder .
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File [] createFiles ( final String str ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[NegateConditionalsMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; MST[ConstructorCallMutator]MSP[S] } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR3Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; MST[ConstructorCallMutator]MSP[S] }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; MST[NonVoidMethodCallMutator]MSP[N] } @SuppressWarnings ( lr_1 )
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } } else if ( str ) ; } } else if ) createDate ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ; } } else if ( str ) ;
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR6Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR5Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[ConstructorCallMutator]MSP[S] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; MST[ReturnValsMutator]MSP[N] } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR4Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[InlineConstantMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; MST[NullReturnValsMutator]MSP[N] }
return ( T ) createObject ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try { try { try { try { try { createURL ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str ) throws ParseException { try { try { try { URL static URL createURL ( final String str
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[ConstructorCallMutator]MSP[S] } }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ; } else ( T ) createDate ( str ) ;
else { throw new ParseException ( lr_2 + clazz ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { } catch ( final ClassNotFoundException cl ) { }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { MST[NullReturnValsMutator]MSP[S]
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; MST[ReturnValsMutator]MSP[N] } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR1Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { } else if ( PatternOptionBuilder
return ( T ) openFile ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ; } else ( T ) createURL ( str ) ;
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) str ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[S] { else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[S] { else if ( PatternOptionBuilder .
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) {
str = str . substring ( 1 , length - 1 ) ; } return str ; }
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR2Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR1Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } return str ; }
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[MathMutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[MathMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ABSMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[InlineConstantMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[ReturnValsMutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ABSMutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI3Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR3Mutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR3Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.ABSMutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; } return str ; MST[ReturnValsMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI3Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[InlineConstantMutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[ArgumentPropagationMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; } return str ; MST[EmptyObjectReturnValsMutator]MSP[N] }
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; MST[ReturnValsMutator]MSP[S] } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR4Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[ReturnValsMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[NegateConditionalsMutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[N] } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR6Mutator]MSP[N] }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; MST[EmptyObjectReturnValsMutator]MSP[N] } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR3Mutator]MSP[S] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR4Mutator]MSP[N] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR2Mutator]MSP[N] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; MST[ReturnValsMutator]MSP[N] } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR1Mutator]MSP[N] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[experimental.NakedReceiverMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOD2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR5Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return str . substring ( 2 , str . length () ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR1Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR3Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[ConditionalsBoundaryMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI4Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI1Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOD1Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR2Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR4Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } return str ; }
private void checkCapacity ( int MST[rv.ABSMutator]MSP[N] ) { Validate . isTrue ( MST[rv.CRCR5Mutator]MSP[S] >= size ) ; int MST[NonVoidMethodCallMutator]MSP[S] = keys . length ; if ( MST[NonVoidMethodCallMutator]MSP[S] >= 160 ) return; int newSize = MST[rv.ROR5Mutator]MSP[S] >= MST[rv.CRCR4Mutator]MSP[N] ? size * MST[ConstructorCallMutator]MSP[S] : MST[NegateConditionalsMutator]MSP[S] ; if ( haystack > newSize )
newSize = 160 ; keys = MST[rv.ROR5Mutator]MSP[N] ( keys , newSize ) ; vals = MST[rv.ROR5Mutator]MSP[N] ( vals , newSize ) ; } private static String [] MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( String [] MST[ReturnValsMutator]MSP[N] , int size ) { final String [] copy = new String [ size ] ;
System . arraycopy ( MST[InlineConstantMutator]MSP[N] , 0 , copy , 0 , Math . min ( MST[rv.ROR5Mutator]MSP[S] . length , size ) ) ; return copy ; } int consumeToAnySorted ( String key ) { Validate . notNull ( key ) ;
for ( int i = 0 ; i < size ; i ++ ) { if ( key . equals ( keys [ i ] ) ) return i ; } return NotFound ; } private int consumeToAnySorted ( String key ) { Validate . notNull ( key ) ;
for ( int i = 0 ; i < size ; i ++ ) { if ( key . equalsIgnoreCase ( keys [ i ] ) ) return i ; } return NotFound ; } static String MST[rv.ROR3Mutator]MSP[S] ( String val ) {
return val == null ? AttributeValue : val ; } public String get ( String key ) { int i = . ( key ) ; return i == NotFound ? AttributeValue : MST[rv.CRCR6Mutator]MSP[S] ( vals [ i ] ) ; } public String removeAttributes ( String key ) {
int i = consumeToAnySorted ( key ) ; return i == NotFound ? AttributeValue : MST[rv.CRCR6Mutator]MSP[S] ( vals [ i ] ) ; } public Attributes add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ;
vals [ size ] = value ; size ++ ; return this ; } public Attributes put ( String key , String value ) { Validate . notNull ( key ) ; int i = MST[NegateConditionalsMutator]MSP[N] ( key ) ; if ( i != NotFound )
vals [ i ] = value ; else add ( key , value ) ; return this ; } void MST[rv.UOI2Mutator]MSP[S] ( String key , String value ) { int i = consumeToAnySorted ( key ) ; if ( i != NotFound ) {
vals [ i ] = value ; if ( ! keys [ i ] . equals ( key ) ) keys [ i ] = key ; } else add ( key , value ) ; } public Attributes put ( String key , boolean value ) {
if ( value ) MST[NegateConditionalsMutator]MSP[S] ( key , null ) ; else remove ( key ) ; return this ; } public Attributes put ( Attribute attribute ) { Validate . notNull ( attribute ) ; put ( attribute . getKey () , attribute . getValue () ) ;
attribute . parent = this ; return this ; } private void remove ( int index ) { Validate . codePointAt ( index >= size ) ; int bufMark = size - index - 1 ; if ( loadFactor > 0 ) {
System . arraycopy ( keys , index + 1 , keys , index , MST[rv.UOI2Mutator]MSP[S] ) ; System . arraycopy ( vals , index + 1 , vals , index , MST[rv.UOI2Mutator]MSP[S] ) ; } size -- ; keys [ size ] = null ;
vals [ size ] = null ; } public void remove ( String key ) { int i = MST[NegateConditionalsMutator]MSP[N] ( key ) ; if ( i != NotFound ) remove ( i ) ; } public void MST[NegateConditionalsMutator]MSP[S] ( String key ) {
int i = consumeToAnySorted ( key ) ; if ( i != NotFound ) remove ( i ) ; } public boolean MST[ConstructorCallMutator]MSP[S] ( String key ) { return MST[NegateConditionalsMutator]MSP[S] ( key ) != NotFound ; } public boolean MST[NegateConditionalsMutator]MSP[S] ( String key ) {
return matchConsumeIgnoreCase ( key ) != NotFound ; } public boolean MST[rv.ROR5Mutator]MSP[S] ( String key ) { int i = MST[NegateConditionalsMutator]MSP[S] ( key ) ; return i != NotFound && vals [ i ] != null ; } public boolean MST[rv.ROR2Mutator]MSP[S] ( String key ) {
int i = consumeToAnySorted ( key ) ; return i != NotFound && vals [ i ] != null ; } public int size () { int s = 0 ; for ( int i = 0 ; i < size ; i ++ ) {
if ( ! matchConsumeIgnoreCase ( keys [ i ] ) ) s ++ ; } return s ; } public boolean isEmpty () { return size == 0 ; } public void addAll ( Attributes MST[rv.CRCR3Mutator]MSP[S] ) { if ( MST[rv.CRCR3Mutator]MSP[N] . size () == 0 ) return;
checkCapacity ( size + break; . size ) ; for ( Attribute attr : attributes ) { put ( attr ) ; } } @Override public boolean hasNext () { while ( i < size ) { if ( consumeToAnySorted ( keys [ i ] ) ) i ++ ;
else break; } return i < size ; } @Override public Attribute next () { final Attribute attr = new MST[rv.ABSMutator]MSP[N] ( keys [ i ] , vals [ i ] , attributes . this ) ; i ++ ; return attr ; } @Override public void remove () {
attributes . this . remove ( -- i ) ; } public List < Attribute > asList () { ArrayList < Attribute > list = new ArrayList <> ( size ) ; for ( int i = 0 ; i < size ; i ++ ) {
if ( matchConsumeIgnoreCase ( keys [ i ] ) ) continue; Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , attr . this ) ; list . add ( attr ) ; } return Collections . unmodifiableList ( list ) ; }
public Map < String , String > MST[rv.CRCR6Mutator]MSP[N] () { return new MST[NonVoidMethodCallMutator]MSP[S] ( this ) ; } public String getMimeType () { StringBuilder sb = StringUtil . isStartTag () ; try { maxBodySize ( sb , ( new Document ( lr_1 ) ) . MST[rv.ROR5Mutator]MSP[S] () ) ;
} catch ( IOException e ) { throw new MST[rv.UOI1Mutator]MSP[N] ( e ) ; } return StringUtil . codePointAt ( sb ) ; } final void isInvisibleChar ( final Appendable accum , final Document . MST[rv.CRCR5Mutator]MSP[N] out ) throws int sz = size ;
for ( int i = 0 ; i < sz ; i ++ ) { if ( consumeToAnySorted ( keys [ i ] ) ) continue; final String key = keys [ i ] ; final String val = vals [ i ] ;
accum . append ( ' ' ) . append ( key ) ; if ( ! Attribute . applyAsLong ( key , val , out ) ) { accum . append ( lr_2 ) ;
MST[rv.UOI2Mutator]MSP[N] . escape ( accum , val == null ? AttributeValue : val , out , true , false , false ) ; accum . append ( '"' ) ; } } } @Override public String toString () { return simpleText () ; } @Override
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass () ) return false ; Attributes MST[rv.UOI1Mutator]MSP[S] = ( Attributes ) o ;
if ( size != MST[rv.UOI3Mutator]MSP[N] . size ) return false ; if ( ! Arrays . equals ( keys , MST[rv.UOI3Mutator]MSP[S] . keys ) ) return false ; return Arrays . equals ( vals , MST[NegateConditionalsMutator]MSP[S] . vals ) ; } @Override public int hashCode () {
int result = size ; result = 31 * result + Arrays . hashCode ( keys ) ; result = 31 * result + Arrays . hashCode ( vals ) ; return result ; } @Override public Attributes clone () { Attributes clone ; try {
clone = ( attributes ) super . clone () ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . size = size ; keys = MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( keys , size ) ; vals = MST[experimental.NakedReceiverMutator]MSP[N] ( vals , size ) ;
return clone ; } public void normalize () { for ( int i = 0 ; i < size ; i ++ ) { keys [ i ] = inSorted ( keys [ i ] ) ; } } public int MST[ConstructorCallMutator]MSP[N] ( HtmlToPlainText bufMark ) {
if ( isEmpty () ) return 0 ; boolean preserve = MST[rv.ROR4Mutator]MSP[N] . MST[rv.ABSMutator]MSP[N] () ; int mapSize = 0 ; OUTER: for ( int i = 0 ; i < keys . length ; i ++ ) {
for ( int j = i + 1 ; j < keys . length ; j ++ ) { if ( keys [ j ] == null ) MST[rv.ROR4Mutator]MSP[N] OUTER;
if ( ( preserve && keys [ i ] . equals ( keys [ j ] ) ) || ( ! preserve && keys [ i ] . equalsIgnoreCase ( keys [ j ] ) ) ) { MST[NonVoidMethodCallMutator]MSP[N] ++ ; remove ( j ) ; j -- ; }
} } return mapSize ; } @Override public Set < Entry < String , String > > entrySet () { return new EntrySet () ; } @Override public String put ( String key , String value ) { String attributes = consumeToAnySorted ( key ) ;
String oldValue = attributes . codePointAt ( attributes ) ? attributes . get ( attributes ) : null ; attributes . put ( millis , value ) ; return oldValue ; } @Override public Iterator < Map . Entry < String , String > > iterator () {
return new MST[NonVoidMethodCallMutator]MSP[S] () ; } @Override public int size () { int count = 0 ; Iterator iter = new consumeLetterSequence () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
while ( MST[rv.ROR3Mutator]MSP[N] . hasNext () ) { attr = MST[rv.ROR3Mutator]MSP[N] . next () ; if ( attr . MST[rv.ROR5Mutator]MSP[N] () ) return true ; } return false ; } public Entry < String , String > next () {
return new MST[NonVoidMethodCallMutator]MSP[S] ( attr . getKey () . substring ( MST[rv.CRCR3Mutator]MSP[N] . length () ) , attr . getValue () ) ; } public void remove () { attributes . remove ( attr . getKey () ) ; } private static String consumeToAnySorted ( String key ) {
return maxStringCacheLen + key ; } static String MST[rv.ROR2Mutator]MSP[S] ( String key ) { return MST[experimental.MemberVariableMutator]MSP[N] + key ; } private boolean consumeToAnySorted ( String key ) { return key != null && key . length () > 1 && key . charAt ( 0 ) == 160 ; }
return new MST[NonVoidMethodCallMutator]MSP[S] () ; MST[ConstructorCallMutator]MSP[S] } @Override public int size () { int count = 0 ; Iterator iter = new consumeLetterSequence () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
return new MST[NonVoidMethodCallMutator]MSP[S] () ; } @Override public int size () { int count = 0 ; Iterator iter = new consumeLetterSequence () ; while ( iter . hasNext () ) count ++ ; MST[IncrementsMutator]MSP[N] return count ; } public boolean hasNext () {
return new MST[NonVoidMethodCallMutator]MSP[S] () ; MST[NullReturnValsMutator]MSP[S] } @Override public int size () { int count = 0 ; Iterator iter = new consumeLetterSequence () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
return new MST[NonVoidMethodCallMutator]MSP[S] () ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { int count = 0 ; Iterator iter = new consumeLetterSequence () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
return new MST[NonVoidMethodCallMutator]MSP[S] () ; } @Override public int size () { int count = 0 ; Iterator iter = new consumeLetterSequence () ; while ( iter . hasNext () ) count ++ ; MST[experimental.RemoveIncrementsMutator]MSP[N] return count ; } public boolean hasNext () {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ; while ( pos < remaining ) { if ( Arrays . binarySearch ( chars , val [ pos ] ) >= 0 ) break; pos ++ ; }
bufPos = pos ; return bufPos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeLetterSequence () { int pos = bufPos ; final int start = pos ; final int remaining = bufLength ;
final char [] val = charBuf ; OUTER: while ( pos < remaining ) { switch ( val [ pos ] ) { case '&' : case '<' : case TokeniserState . nullChar : break OUTER; default: pos ++ ; } } bufPos = pos ;
return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeLetterSequence () { int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
OUTER: while ( pos < remaining ) { switch ( val [ pos ] ) { case '<' : case TokeniserState . nullChar : break OUTER; default: pos ++ ; } } bufPos = pos ;
return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeLetterSequence () { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ;
final char [] val = charBuf ; OUTER: while ( pos < remaining ) { switch ( val [ pos ] ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : case '/' : case '>' : case '<' :
case TokeniserState . nullChar : break OUTER; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToEnd () { bufferUp () ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= '0' && c <= '9' ) || ( c >= 'A' && c <= 'F' ) || ( c >= 'a' && c <= 'f' ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( seek == c ) return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ; } boolean matchesLetter () {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) {
bufPos += seq . length () ; return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
} boolean anythingElse ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return rangeEquals ( charBuf , start , count , cached ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[N] }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; MST[InlineConstantMutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( seek == c ) MST[rv.UOI3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[NegateConditionalsMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR5Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[rv.ROR1Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[N] return lr_3
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR3Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR3Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String = offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String = offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[NonVoidMethodCallMutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[InlineConstantMutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[InlineConstantMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] } void mark () { if
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI2Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[N] bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI3Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[ReturnValsMutator]MSP[N] MST[ReturnValsMutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[ReturnValsMutator]MSP[N] MST[ReturnValsMutator]MSP[N] = charBuf [ charBuf [ bufPos ] == c ; MST[ReturnValsMutator]MSP[N] MST[ReturnValsMutator]MSP[N] ; MST[ReturnValsMutator]MSP[N] charBuf [ bufPos [ bufPos ] == c ; MST[ReturnValsMutator]MSP[N] MST[ReturnValsMutator]MSP[N] ; MST[ReturnValsMutator]MSP[N] charBuf [ bufPos [ bufPos ] == c ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[N] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[MathMutator]MSP[N] } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR1Mutator]MSP[N] int read = 0 ;
return val ; MST[ReturnValsMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
while ( read <= minReadAheadLen ) { MST[rv.UOI3Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] { mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] { mark () { if ( bufLength - bufPos <
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI2Mutator]MSP[N]
return val ; MST[rv.UOI4Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
bufPos = endPos ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR2Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR1Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[N] final int index = hash & stringCache . length -
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
if ( seek == c ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI2Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[S] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
bufPos += seq . length () ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR1Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI4Mutator]MSP[N] }
} boolean anythingElse ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI1Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[NegateConditionalsMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[N] } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) MST[rv.ROR1Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI2Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[N] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[NegateConditionalsMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; MST[PrimitiveReturnsMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR3Mutator]MSP[S] } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NonVoidMethodCallMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; MST[rv.CRCR6Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR4Mutator]MSP[N]
String cached = stringCache [ index ] ; MST[rv.ABSMutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[ReturnValsMutator]MSP[S] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[S] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.ABSMutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[N] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] MST[rv.CRCR6Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] MST[rv.CRCR6Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] } int charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] } [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] } void mark () { if
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR6Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[S] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ; ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return
bufPos += seq . length () ; MST[rv.UOI3Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[InlineConstantMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI1Mutator]MSP[N] final char [] val = charBuf ;
int hash = 0 ; MST[rv.CRCR6Mutator]MSP[N] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI1Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] } void mark () { if
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[InlineConstantMutator]MSP[N] }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] stringCache [ index ] = cached ; } else {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.ABSMutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR4Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR5Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR1Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[InlineConstantMutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[InlineConstantMutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR5Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
if ( upScan != upTarget ) MST[rv.ROR4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
bufPos = endPos ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( seek == c ) MST[NegateConditionalsMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[NegateConditionalsMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[ArgumentPropagationMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI2Mutator]MSP[N] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seek == c ) return true ; MST[ReturnValsMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; ) return consumed ; MST[rv.ABSMutator]MSP[S] return consumed ; ) return consumed ; ) return consumed ; MST[rv.ABSMutator]MSP[S] return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[N] stringCache [ index ] = cached ; } } return cached ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[InlineConstantMutator]MSP[N] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR3Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR3Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI2Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ; ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR5Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR6Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N] void mark () { if ( bufLength - bufPos <
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[N] return i - bufPos ; } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[NegateConditionalsMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.ABSMutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[N]
int hash = 0 ; MST[rv.CRCR5Mutator]MSP[N] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR3Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; ) return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR5Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[experimental.RemoveIncrementsMutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI2Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[N]
if ( upScan != upTarget ) MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI1Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[InlineConstantMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[N] bufPos ++ ;
return rangeEquals ( charBuf , start , count , cached ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NonVoidMethodCallMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[InlineConstantMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[S] final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[S] final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[S] final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[S] final int index = hash & stringCache . length -
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; { bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; { return consumed ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; { return consumed ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; { return consumed ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; { return consumed ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; { return consumed ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; { return consumed ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI4Mutator]MSP[N] final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[S] } } return cached ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufPos = endPos ; MST[rv.UOI2Mutator]MSP[N] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR5Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.UOI4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] [ charBuf [ bufPos ] == c ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR4Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
bufPos += seq . length () ; return true ; MST[InlineConstantMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[S] } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S] MST[ReturnValsMutator]MSP[N] [ char [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S] boolean matches ( char [ bufPos [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S] boolean matches ( char [ bufPos [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S] boolean
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI4Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[experimental.RemoveIncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR3Mutator]MSP[S] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR5Mutator]MSP[N] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[N] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR5Mutator]MSP[N] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[N] } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR4Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[N] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI1Mutator]MSP[N] break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI2Mutator]MSP[N] if ( count < 1 ) return lr_3
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] if [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] boolean matches ( char [ bufPos [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N] charBuf () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N] boolean matches
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR1Mutator]MSP[N]
return val ; MST[rv.UOI3Mutator]MSP[S] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ABSMutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR1Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf
char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[S]
if ( seek == c ) MST[rv.UOI3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR4Mutator]MSP[N] }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] void mark () { if ( bufLength - bufPos <
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[InlineConstantMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isEmptyNoBufferUp () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[N] MST[InlineConstantMutator]MSP[S] [ charBuf [ bufPos [ bufPos ] == c ; MST[InlineConstantMutator]MSP[N] false matches () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S] false [ char [ bufPos [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI2Mutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S] MST[ReturnValsMutator]MSP[S]
if ( seek == c ) return true ; MST[rv.CRCR2Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR6Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3
while ( read <= minReadAheadLen ) { MST[rv.ROR1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI3Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { MST[ConditionalsBoundaryMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR1Mutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] try
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N] { mark () { if ( bufLength - bufPos <
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] bufPos = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] bufPos = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[N] return lr_3
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR2Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.ABSMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR3Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.AOR1Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[S] char c =
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR3Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[N] final int index = hash & stringCache . length -
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI1Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[N] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] } else {
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI1Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.ABSMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] } void mark () { if
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; read += thisRead ; }
private void bufferUp () { MST[rv.CRCR3Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[InlineConstantMutator]MSP[N] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[N] charBuf [ bufPos [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[S] charBuf [ bufPos [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[S] charBuf ( char [ bufPos [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[S] charBuf [ bufPos [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[S] charBuf ( char [ bufPos [ bufPos
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR3Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed
if ( seek == c ) return true ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR3Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI3Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while ( read <= minReadAheadLen ) { MST[NegateConditionalsMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
bufSplitPoint = 0 ; MST[rv.CRCR6Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[MathMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI1Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR5Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.ABSMutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { MST[rv.UOI3Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[N]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI4Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD1Mutator]MSP[N] } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[N] final int index = hash & stringCache . length -
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR2Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR4Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private void bufferUp () { if ( readFully ) MST[NegateConditionalsMutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR3Mutator]MSP[S] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[N] break OUTER; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOD2Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[N] } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR5Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( count -- != 0 ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR2Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[NegateConditionalsMutator]MSP[N] break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR2Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR2Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR2Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR2Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR2Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.UOI1Mutator]MSP[N] return consumed ; )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR5Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[NonVoidMethodCallMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[InlineConstantMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR2Mutator]MSP[N] }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI4Mutator]MSP[N]
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR1Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI2Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR5Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; ) return
String cached = stringCache [ index ] ; MST[rv.UOI2Mutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] -- () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] -- () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] -- () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
} else if ( bufLength - bufPos < seq . length () ) { MST[MathMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) MST[rv.ROR5Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.ABSMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[N] final int index = hash & stringCache . length -
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[MathMutator]MSP[S] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR6Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seek == c ) MST[rv.ROR4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] MST[rv.UOI4Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] MST[rv.UOI4Mutator]MSP[N] int charBuf [ bufPos [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] { int charBuf [ bufPos [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] { int charBuf [ bufPos [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI1Mutator]MSP[N] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR4Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.ABSMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR4Mutator]MSP[N] } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR1Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NegateConditionalsMutator]MSP[S]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches ()
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.ABSMutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR3Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOR2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD2Mutator]MSP[N] } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NonVoidMethodCallMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR2Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] { mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N] { mark () { if ( bufLength - bufPos <
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[S] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
pos ++ ; } bufPos = pos ; MST[rv.ABSMutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR6Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[N]
String cached = stringCache [ index ] ; MST[rv.UOI3Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[N] break OUTER; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR1Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[N] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR5Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR2Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI4Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] MST[rv.ROR3Mutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] if [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N] boolean matches ( char [ bufPos [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[NegateConditionalsMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOD1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOD1Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOD1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOD1Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOD1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOD1Mutator]MSP[S] return consumed ; )
return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR4Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[InlineConstantMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR1Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[N]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break OUTER; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR6Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[IncrementsMutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] } void mark () { if
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; MST[VoidMethodCallMutator]MSP[N] if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] ( count < 1
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR5Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR3Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR6Mutator]MSP[N] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[N] final int index = hash & stringCache . length -
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR5Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[experimental.MemberVariableMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR5Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[IncrementsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI2Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR5Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NonVoidMethodCallMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
bufPos += seq . length () ; return true ; MST[rv.CRCR4Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR6Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[NonVoidMethodCallMutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NegateConditionalsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; return consumed ; return consumed ; return consumed ; return consumed ; return consumed ; { bufPos += offset ; return consumed ; return consumed ; { bufPos += offset ; return consumed ; return consumed ; { bufPos += offset ; return consumed ; return consumed ; {
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR4Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.ABSMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NegateConditionalsMutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.UOI1Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
return false ; MST[ReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[InlineConstantMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI2Mutator]MSP[N] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[N] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI3Mutator]MSP[N] final char [] val = charBuf ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[MathMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR5Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[ReturnValsMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR5Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] char c =
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[N] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return rangeEquals ( charBuf , start , count , cached ) ; MST[ReturnValsMutator]MSP[S] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR5Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR4Mutator]MSP[N] break OUTER; }
if ( seek == c ) MST[rv.ROR3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI4Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[ReturnValsMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( seek == c ) MST[rv.UOI2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ; MST[NonVoidMethodCallMutator]MSP[N] += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR3Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.ROR5Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR2Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR1Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[S] } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI1Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR4Mutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; MST[rv.UOI2Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; return consumed ; MST[ReturnValsMutator]MSP[N] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR2Mutator]MSP[N] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] bufPos ++ ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR1Mutator]MSP[N] return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; MST[rv.AOR1Mutator]MSP[S] return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; MST[rv.AOR1Mutator]MSP[S] return consumed ; )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI2Mutator]MSP[N] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3
} else if ( bufLength - bufPos < seq . length () ) { MST[NegateConditionalsMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N] } void mark () { if
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
private void bufferUp () { MST[rv.CRCR2Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[N] return lr_3 ; ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[N] return
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI1Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[N] return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; ) return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.ABSMutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR3Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[S] return lr_3
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI3Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N] boolean
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[N] } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR3Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[N] final int index = hash & stringCache . length -
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[N] final int index = hash & stringCache . length -
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N] MST[rv.ABSMutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N] MST[rv.ABSMutator]MSP[N] } MST[rv.ABSMutator]MSP[N] && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N] MST[rv.ABSMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[experimental.MemberVariableMutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; { bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
bufPos += seq . length () ; MST[experimental.MemberVariableMutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR5Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[EmptyObjectReturnValsMutator]MSP[N] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ABSMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
bufPos = endPos ; MST[rv.UOI3Mutator]MSP[S] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[S] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; MST[InlineConstantMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[S] else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] -- getFile { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] -- getFile { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; MST[rv.UOI3Mutator]MSP[S] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[InlineConstantMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[N] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[ReturnValsMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[EmptyObjectReturnValsMutator]MSP[N] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; { bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR3Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR4Mutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NegateConditionalsMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD1Mutator]MSP[N] } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[InlineConstantMutator]MSP[N] while ( count -- != 0 ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[ReturnValsMutator]MSP[N] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[S] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; ) return
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { MST[NegateConditionalsMutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [
if ( seek == c ) MST[rv.UOI4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI3Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ConditionalsBoundaryMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[N] final int index = hash & stringCache . length -
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[N] final int index = hash & stringCache . length -
if ( seek == c ) MST[rv.ROR5Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[S] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ; ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR6Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[N] } } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[S] } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI4Mutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[S] } void mark () { if
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI1Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[InlineConstantMutator]MSP[N] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[InlineConstantMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI3Mutator]MSP[N]
bufPos += seq . length () ; return true ; MST[ReturnValsMutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR3Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[N] final int index = hash & stringCache . length -
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR5Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[InlineConstantMutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] for [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[S] char c =
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI4Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR2Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[MathMutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.ABSMutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[N] return lr_3
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[ReturnValsMutator]MSP[N] }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; ) += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; ) } += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; ) { String = offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; ) { String offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; ) { String offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; ) { String offset
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) MST[rv.ROR3Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.ROR2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI2Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR3Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[ReturnValsMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] } void mark () { if
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufPos += seq . length () ; return true ; MST[rv.CRCR5Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[N] while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[N] } return - 1 ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [ bufPos
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; MST[rv.ABSMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR1Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[IncrementsMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ; else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[MathMutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[N] bufPos ++ ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; return consumed ; return consumed ; return consumed ; return consumed ; return consumed ; { bufPos += offset ; return consumed ; return consumed ; { bufPos += offset ; return consumed ; return consumed ; { bufPos += offset ; return consumed ; return consumed ; {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[N] char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.ABSMutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ]
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.ABSMutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[InlineConstantMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[InlineConstantMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[InlineConstantMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ConstructorCallMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ConstructorCallMutator]MSP[N] if ( count < 1 ) return lr_3
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ; ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[InlineConstantMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[N] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed ; MST[ReturnValsMutator]MSP[S] consumed
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[IncrementsMutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR6Mutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR5Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] char c = charBuf [
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] MST[rv.ROR4Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N] try
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR3Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[N] } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR2Mutator]MSP[N] } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[N] } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR4Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[PrimitiveReturnsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufPos += seq . length () ; MST[rv.UOI2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI2Mutator]MSP[N] final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
bufPos += seq . length () ; MST[rv.AOD2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length -
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[ArgumentPropagationMutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[N] } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR4Mutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR1Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] charBuf () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR1Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR3Mutator]MSP[N] break OUTER; }
pos ++ ; MST[IncrementsMutator]MSP[N] } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) MST[rv.ROR3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR3Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD1Mutator]MSP[N]
if ( seek == c ) MST[rv.UOI1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR2Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[N] bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[experimental.RemoveIncrementsMutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int start = bufPos ; while ( bufPos < bufLength ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR6Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
bufPos += seq . length () ; MST[rv.UOI4Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[N] } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR3Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[N] if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
private void bufferUp () { MST[rv.CRCR1Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[NegateConditionalsMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NegateConditionalsMutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR1Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI3Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR5Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI1Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR5Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[experimental.MemberVariableMutator]MSP[N] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.ABSMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[rv.CRCR4Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD1Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[InlineConstantMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] for ( char seek : seq ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; MST[rv.ABSMutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR5Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] } void mark () { if
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR6Mutator]MSP[N] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N] } void mark () { if
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR3Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[N] return consumed ; } else {
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
int hash = 0 ; int offset = start ; MST[rv.UOI2Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI2Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI2Mutator]MSP[N] return consumed ; ) return consumed ; ) return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.ABSMutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[N] stringCache [ index ] = cached ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; if consumed ; ) bufPos += offset ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR5Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR4Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] char c =
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; ) return consumed ; MST[rv.ABSMutator]MSP[S] return consumed ; ) return consumed ; ) return consumed ; MST[rv.ABSMutator]MSP[S] return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; ) return consumed ; )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[N] if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR4Mutator]MSP[N] } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[IncrementsMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR2Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ]
bufPos += seq . length () ; MST[MathMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI1Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI1Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR1Mutator]MSP[N] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String cached = stringCache [ index ] ; if ( cached == null ) { MST[NegateConditionalsMutator]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR1Mutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
private void bufferUp () { MST[rv.CRCR4Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[NegateConditionalsMutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI3Mutator]MSP[N] break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[S] return lr_3
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.ABSMutator]MSP[N] final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[N] bufPos ++ ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; { bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR2Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR5Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI4Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[N] final int index = hash & stringCache . length -
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR3Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] { mark () { if ( bufLength - bufPos <
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.UOI4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[S] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI3Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ABSMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[N]
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; readFully += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
case TokeniserState . nullChar : break OUTER; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToEnd () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[S] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR5Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N]
return false ; MST[rv.CRCR3Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR3Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR1Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI1Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
bufPos += seq . length () ; MST[rv.AOR3Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR5Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR1Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] MST[rv.CRCR6Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] MST[rv.CRCR6Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] } int charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] } [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N] }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed ; MST[rv.ABSMutator]MSP[S] bufPos += offset ; return consumed ; return consumed
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[S]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR5Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR5Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[VoidMethodCallMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR5Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI1Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI4Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR4Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) return true ; MST[InlineConstantMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ReturnValsMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[ReturnValsMutator]MSP[N] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR4Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[N] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI3Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[NegateConditionalsMutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[NegateConditionalsMutator]MSP[N] return i - bufPos ; } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[IncrementsMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI1Mutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
} else if ( bufLength - bufPos < seq . length () ) { MST[ConditionalsBoundaryMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[N] return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[N] }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR5Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] charBuf [ bufPos [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufSplitPoint () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean matches ( char
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N] [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] for [ char [ bufPos [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N] MST[rv.ROR1Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; } else {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR1Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[S] char c =
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[N] }
bufPos += seq . length () ; return true ; MST[rv.CRCR2Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[S] } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N]
bufSplitPoint = 0 ; MST[rv.CRCR5Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR2Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR3Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR3Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR3Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR3Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR3Mutator]MSP[S] return consumed ; ) return consumed ; MST[rv.AOR3Mutator]MSP[S] return consumed ; )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD1Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( seek == c ) MST[rv.UOI1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[N] return consumed ; ) return consumed ; MST[MathMutator]MSP[S] return consumed ; ) return consumed ; MST[MathMutator]MSP[S] return consumed ; ; return consumed ; MST[MathMutator]MSP[S] return consumed ; ) return consumed ; MST[MathMutator]MSP[S] return consumed ; ) return consumed ; ; return consumed ; MST[MathMutator]MSP[S] return consumed ; ) return consumed ; MST[MathMutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] } void mark () { if
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR6Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N] MST[rv.ABSMutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N] MST[rv.ABSMutator]MSP[N] } MST[rv.ABSMutator]MSP[N] && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N] MST[rv.ABSMutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI3Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( startChar != charBuf [ offset ] )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOD2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; MST[rv.ABSMutator]MSP[S] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; MST[experimental.MemberVariableMutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[N] final int index = hash & stringCache . length -
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD2Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI4Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos [ bufPos ] ==
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[NegateConditionalsMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { MST[rv.CRCR3Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[N] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[S] } void mark () { if
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[S]
if ( upScan != upTarget ) return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI2Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[ReturnValsMutator]MSP[N] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR4Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR4Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.ROR5Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[ReturnValsMutator]MSP[N] } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; } return false ; MST[InlineConstantMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N] MST[rv.UOI4Mutator]MSP[N] mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N] -- () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N] -- () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N] -- () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[N] stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[N] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI4Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ bufPos [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ bufPos [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ bufPos [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ bufPos [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ bufPos [ bufPos ] == c ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[S] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[S] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[S] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[S] void mark () { if ( bufLength - bufPos <
} else if ( bufLength - bufPos < seq . length () ) { MST[NonVoidMethodCallMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[S] while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[N] break OUTER; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[N] } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[N] void mark () { if ( bufLength - bufPos <
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR6Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { MST[rv.CRCR6Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c =
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[ConditionalsBoundaryMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR4Mutator]MSP[N] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[NegateConditionalsMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR6Mutator]MSP[N]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI4Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[N] final int index = hash & stringCache . length -
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; }
} boolean anythingElse ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR3Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
int hash = 0 ; MST[rv.CRCR1Mutator]MSP[N] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI3Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[N] return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[N] final int index = hash & stringCache . length -
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return false ; MST[rv.CRCR5Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return lr_3 ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return lr_3
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[N] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[rv.AOR1Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR3Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR3Mutator]MSP[N] int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR1Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI1Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[InlineConstantMutator]MSP[S] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.ABSMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[N] final int index = hash & stringCache . length -
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] { String += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] { String += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] { String += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] { String += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] { String += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] { String += offset
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR6Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI1Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[ConditionalsBoundaryMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( startChar != charBuf [ offset ] )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR3Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] { mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] { mark () { if ( bufLength - bufPos <
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] charBuf [ bufPos [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufSplitPoint () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] boolean matches ( char
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] if ( matches ( seq ) ) {
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[MathMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
while ( read <= minReadAheadLen ) { MST[rv.ABSMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; readFully += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR3Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR1Mutator]MSP[N] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos [ bufPos ] ==
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.ABSMutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[N] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[N] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR2Mutator]MSP[N] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI2Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR6Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[ConditionalsBoundaryMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( upScan != upTarget ) return false ; } return true ; MST[ReturnValsMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[N]
if ( seek == c ) return true ; MST[rv.CRCR6Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI4Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
bufPos += seq . length () ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR1Mutator]MSP[N] } return - 1 ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N] } void mark () { if
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR4Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
private void bufferUp () { if ( readFully ) MST[rv.ROR2Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N] } void mark () { if
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI4Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] charBuf () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI4Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; } final int index = hash & stringCache . length - 1 ; } final int index = hash & stringCache . length - 1 ; } final int index = hash & stringCache . length - 1 ; } final int index = hash & stringCache . length
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; readFully += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; MST[InlineConstantMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR5Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[InlineConstantMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[N] MST[InlineConstantMutator]MSP[S] [ charBuf [ bufPos [ bufPos ] == c ; MST[InlineConstantMutator]MSP[N] false matches () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S] false [ char [ bufPos [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI2Mutator]MSP[N] [ charBuf [ bufPos [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S] MST[ReturnValsMutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[N] bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR5Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[N] } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N] final int index = hash & stringCache . length -
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[ReturnValsMutator]MSP[N] } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[S] } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[N] return consumed ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR6Mutator]MSP[N] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NonVoidMethodCallMutator]MSP[N] char c = charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[S] char c =
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[ReturnValsMutator]MSP[N] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR6Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI2Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.CRCR2Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N] MST[rv.ROR5Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[MathMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[InlineConstantMutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[N] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N] } void mark () { if
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[S] boolean
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] char c = charBuf
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[S] while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] { mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N] { mark () { if ( bufLength - bufPos <
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR4Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI4Mutator]MSP[N] break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[ReturnValsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[MathMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[experimental.MemberVariableMutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[InlineConstantMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOD1Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[N] } return - 1 ; }
bufPos += seq . length () ; MST[rv.ABSMutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR6Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[N] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI2Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return false ; MST[rv.CRCR1Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
pos ++ ; } bufPos = pos ; MST[experimental.MemberVariableMutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[MathMutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ABSMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI2Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[S] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ; ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
pos ++ ; } bufPos = pos ; MST[rv.UOI1Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[S] final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[S] final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[S] final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[S] final int index = hash & stringCache . length -
while ( read <= minReadAheadLen ) { MST[rv.CRCR1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[InlineConstantMutator]MSP[N] int read = 0 ;
if ( upScan != upTarget ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String = offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String = offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; ) { String
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[ConditionalsBoundaryMutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.ROR5Mutator]MSP[N] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[InlineConstantMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
private void bufferUp () { MST[rv.CRCR5Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[N] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[N] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR1Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( startChar != charBuf [ offset ] )
unmark () ; MST[VoidMethodCallMutator]MSP[N] } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR4Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N]
if ( upScan != upTarget ) return false ; MST[ReturnValsMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI4Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR4Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ABSMutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR2Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return consumeToEnd () ; MST[ReturnValsMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ; ) += offset ; return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NegateConditionalsMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { MST[rv.CRCR4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[N] final int index = hash & stringCache . length -
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR6Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
reader . reset () ; if ( read > 0 ) { MST[rv.ROR2Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; MST[VoidMethodCallMutator]MSP[N] bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI3Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N]
if ( seek == c ) return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[N] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; MST[InlineConstantMutator]MSP[N] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
pos ++ ; } bufPos = pos ; MST[rv.UOI4Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NonVoidMethodCallMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI3Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD1Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI2Mutator]MSP[N] break OUTER; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
} boolean matches ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[S] } void mark () { if
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ]
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[InlineConstantMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ABSMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ABSMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ABSMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ABSMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ABSMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.ABSMutator]MSP[S] return lr_3
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ; if consumed ; if += offset ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[InlineConstantMutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[MathMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[experimental.MemberVariableMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR1Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[N] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[N] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR5Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[ReturnValsMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; ) return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; { return consumed ; {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; MST[rv.CRCR3Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos += offset ; return consumed ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N] boolean matches ()
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[N]
if ( seek == c ) MST[rv.UOI2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; MST[rv.CRCR3Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI2Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
if ( seek == c ) return true ; } return false ; MST[ReturnValsMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] [ charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N] MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] [ charBuf [ bufPos ] == c ;
bufSplitPoint = 0 ; MST[rv.CRCR1Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} boolean anythingElse ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[N] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR3Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI1Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR2Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] char c =
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[ReturnValsMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI4Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[MathMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[S] } void mark () { if
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR4Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR4Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR4Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR4Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR4Mutator]MSP[N] return consumed ; ) return consumed ; MST[rv.AOR4Mutator]MSP[N] return consumed ; )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3
while ( read <= minReadAheadLen ) { MST[InlineConstantMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[N] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI3Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; MST[InlineConstantMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI1Mutator]MSP[N] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI2Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.AOR4Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR6Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N] void mark () { if ( bufLength - bufPos <
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR5Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[S] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[MathMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
return val ; MST[rv.UOI1Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[MathMutator]MSP[N] }
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.ABSMutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
int hash = 0 ; int offset = start ; MST[rv.UOI1Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI2Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] MST[rv.UOI4Mutator]MSP[N] int charBuf [ charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] MST[rv.UOI4Mutator]MSP[N] int charBuf [ bufPos [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] { int charBuf [ bufPos [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] { int charBuf [ bufPos [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N] {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NonVoidMethodCallMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[N] final int index = hash & stringCache . length -
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI4Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI1Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR5Mutator]MSP[N] char c = charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[S] char c =
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[N] } } return - 1 ; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[N] } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[ConditionalsBoundaryMutator]MSP[S]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; { bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR5Mutator]MSP[N] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[NegateConditionalsMutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR3Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR1Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR2Mutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[InlineConstantMutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[S] while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ] ; { char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] MST[rv.UOI1Mutator]MSP[S] = charBuf [ bufPos ]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR4Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] stringCache [ index ] = cached ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count < 1 ) return lr_3 ; if ( count <
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI1Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean anythingElse ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[N] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR3Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] char c = charBuf
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[rv.ROR1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[S] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ABSMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[N] stringCache [ index ] = cached ; } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; { bufPos += offset ; return consumed ; if consumed ; if += offset ; return consumed ; return consumed ; ) bufPos += offset ; return consumed ;
private void bufferUp () { if ( readFully ) MST[rv.ROR4Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR6Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI3Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NonVoidMethodCallMutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[NegateConditionalsMutator]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[ReturnValsMutator]MSP[N] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[N] bufSplitPoint isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean matches () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S] boolean
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NegateConditionalsMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR6Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N] } void mark () { if
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( seek == c ) return true ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR6Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else { return false ; } else
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI2Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
return val ; } void unconsume () { if ( bufPos < 1 ) MST[InlineConstantMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos < minReadAheadLen ) } void mark () { if ( bufLength - bufPos
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[N] while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD2Mutator]MSP[N] } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI1Mutator]MSP[N] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR2Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.ABSMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[S] char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ; char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[MathMutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int start = bufPos ; while ( bufPos < bufLength ) { int
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[N] final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[N] final int index = hash & stringCache . length -
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[N]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[S] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
String cached = stringCache [ index ] ; if ( cached == null ) { MST[rv.ROR5Mutator]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR3Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i int index = hash & stringCache . length - 1 ; i
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
if ( selector != null ) { MST[rv.ROR4Mutator]MSP[S] elements = doc . MST[ReturnValsMutator]MSP[S] ( selector ) ; for ( Element element : elements ) { String haystack = formatter . codePointAt ( element ) ; System . out . println ( haystack ) ; } } else {
String haystack = formatter . codePointAt ( doc ) ; System . out . println ( haystack ) ; } } public String removeAttributes ( Element element ) { HtmlToPlainText formatter = new MST[ReturnValsMutator]MSP[S] () ; currentSet . removeAttributes ( formatter , element ) ;
return formatter . toString () ; } public void head ( Node node , int depth ) { String name = node . currentElement () ; if ( node instanceof MST[NonVoidMethodCallMutator]MSP[N] ) append ( ( ( tags ) node ) . text () ) ;
else if ( name . equals ( lr_2 ) ) append ( lr_3 ) ; else if ( name . equals ( lr_4 ) ) append ( lr_5 ) ;
else if ( StringUtil . in ( name , lr_6 , lr_7 , lr_8 , lr_9 , lr_10 , lr_11 , lr_12 ) ) append ( lr_13 ) ; } public void MST[rv.ROR3Mutator]MSP[N] ( Node node , int depth ) { String name = node . currentElement () ;
if ( StringUtil . in ( name , lr_14 , lr_15 , lr_4 , lr_6 , lr_7 , lr_8 , lr_9 , lr_10 , lr_11 ) ) append ( lr_13 ) ; else if ( name . equals ( lr_16 ) )
append ( String . format ( lr_17 , node . codePointAt ( lr_18 ) ) ) ; } private void append ( String text ) { if ( text . startsWith ( lr_13 ) ) width = 0 ; if ( text . equals ( lr_19 ) &&
( accum . length () == 0 || StringUtil . in ( accum . substring ( accum . length () - 1 ) , lr_19 , lr_13 ) ) ) return; if ( text . length () + width > MST[rv.UOI2Mutator]MSP[N] ) {
String [] words = text . split ( lr_20 ) ; for ( int i = 0 ; i < words . length ; i ++ ) { String MST[rv.CRCR5Mutator]MSP[N] = words [ i ] ; boolean last = i == words . length - 1 ;
if ( ! last ) processArgs = si + lr_19 ; if ( . . length () + width > MST[rv.ROR1Mutator]MSP[S] ) { accum . append ( lr_13 ) . append ( MST[rv.CRCR5Mutator]MSP[N] ) ; width = MST[rv.CRCR5Mutator]MSP[N] . length () ; } else {
accum . append ( MST[rv.CRCR5Mutator]MSP[N] ) ; width += MST[rv.CRCR5Mutator]MSP[N] . length () ; } } } else { accum . append ( text ) ; width += text . length () ; } } @Override public String toString () { return accum . toString () ; }
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR1Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR6Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR5Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
return formatter . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void head ( Node node , int depth ) { String name = node . currentElement () ; if ( node instanceof MST[NonVoidMethodCallMutator]MSP[N] ) append ( ( ( tags ) node ) . text () ) ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR1Mutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR6Mutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR3Mutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR5Mutator]MSP[S]
return formatter . toString () ; MST[ReturnValsMutator]MSP[N] } public void head ( Node node , int depth ) { String name = node . currentElement () ; if ( node instanceof MST[NonVoidMethodCallMutator]MSP[N] ) append ( ( ( tags ) node ) . text () ) ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[NegateConditionalsMutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR2Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[VoidMethodCallMutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR3Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR4Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
String haystack = formatter . codePointAt ( doc ) ; System . out . println ( haystack ) ; } } public String removeAttributes ( Element element ) { HtmlToPlainText formatter = new MST[ReturnValsMutator]MSP[S] () ; currentSet . removeAttributes ( formatter , element ) ; MST[VoidMethodCallMutator]MSP[N]
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR1Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[InlineConstantMutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR5Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR1Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR5Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[InlineConstantMutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
return formatter . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public void head ( Node node , int depth ) { String name = node . currentElement () ; if ( node instanceof MST[NonVoidMethodCallMutator]MSP[N] ) append ( ( ( tags ) node ) . text () ) ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; MST[NonVoidMethodCallMutator]MSP[N] HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR1Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR6Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR4Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR3Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR5Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR2Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR3Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR1Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR4Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR5Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR2Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR1Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR2Mutator]MSP[N] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR2Mutator]MSP[N] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR4Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[InlineConstantMutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[NegateConditionalsMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[NegateConditionalsMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String url = args [ 0 ] ;
String haystack = formatter . codePointAt ( doc ) ; System . out . println ( haystack ) ; } } public String removeAttributes ( Element element ) { HtmlToPlainText formatter = new MST[ReturnValsMutator]MSP[S] () ; MST[ConstructorCallMutator]MSP[N] haystack . removeAttributes ( formatter , element ) ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final String url = args [ 0 ] ;
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () ) { Token . MST[rv.CRCR5Mutator]MSP[N] d = t . asStartTag () ; MST[rv.ROR4Mutator]MSP[S] MST[rv.ROR4Mutator]MSP[N] = new MST[NonVoidMethodCallMutator]MSP[N] ( tb . doctypePending . MST[rv.CRCR6Mutator]MSP[N] ( d . getName () ) , d . MST[rv.ROR4Mutator]MSP[N] () , d . MST[rv.ROR5Mutator]MSP[N] () ) ;
MST[NonVoidMethodCallMutator]MSP[N] MST[NonVoidMethodCallMutator]MSP[N] MST[rv.UOI3Mutator]MSP[S] . codePointAt ( d . isStartTag () ) ; tb . getUrl () . codePointAt ( MST[rv.UOI1Mutator]MSP[N] ) ; if ( d . relaxed () ) tb . emitDoctypePending () . codePointAt ( Document . MST[rv.CRCR6Mutator]MSP[S] . MST[NonVoidMethodCallMutator]MSP[S] ) ; tb . transition ( haystack ) ;
} else { tb . transition ( haystack ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype () ) { tb . error ( this ) ;
return false ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ; } else if ( isWhitespace ( t ) ) { return true ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { tb . insert ( t . asStartTag () ) ; tb . transition ( mimeType ) ;
} else if ( t . isEndTag () && ( StringUtil . in ( t . asEndTag () . normalName () , lr_2 , lr_3 , lr_1 , lr_4 ) ) ) { return anythingElse ( t , tb ) ;
} else if ( t . isEndTag () ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) {
tb . codePointAt ( lr_1 ) ; tb . transition ( mimeType ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return true ;
} else if ( t . isComment () ) { tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { return InBody . process ( t , tb ) ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_2 ) ) { Element head = tb . insert ( t . asStartTag () ) ; tb . processEndTag ( head ) ; tb . transition ( InHead ) ;
} else if ( t . isEndTag () && ( StringUtil . in ( t . asEndTag () . normalName () , lr_2 , lr_3 , lr_1 , lr_4 ) ) ) { tb . emit ( lr_2 ) ; return tb . process ( t ) ;
} else if ( t . isEndTag () ) { tb . error ( this ) ; return false ; } else { tb . emit ( lr_2 ) ; return tb . process ( t ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
tb . insert ( t . asComment () ) ; break; case MAXIMUM_CAPACITY : tb . error ( this ) ; return false ; case StartTag : Token . StartTag start = t . asStartTag () ; String name = start . normalName () ;
if ( name . equals ( lr_1 ) ) { return InBody . process ( t , tb ) ; } else if ( StringUtil . in ( name , lr_5 , lr_6 , lr_7 , lr_8 , lr_9 ) ) {
Element el = tb . codePointAt ( start ) ; if ( name . equals ( lr_5 ) && el . codePointAt ( lr_10 ) ) tb . codePointAt ( el ) ; } else if ( name . equals ( lr_11 ) ) {
Element MST[rv.ROR4Mutator]MSP[N] = tb . codePointAt ( start ) ; } else if ( name . equals ( lr_12 ) ) { MST[NonVoidMethodCallMutator]MSP[S] ( start , tb ) ; } else if ( StringUtil . in ( name , lr_13 , lr_14 ) ) {
maxBodySize ( start , tb ) ; } else if ( name . equals ( lr_15 ) ) { tb . insert ( start ) ; tb . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; } else if ( name . equals ( lr_16 ) ) {
tb . doctypePending . transition ( TokeniserState . forceQuirks ) ; tb . currentElement () ; tb . transition ( mimeType ) ; tb . insert ( start ) ; } else if ( name . equals ( lr_2 ) ) { tb . error ( this ) ;
return false ; } else { return anythingElse ( t , tb ) ; } break; case accum : Token . KeyVal end = t . asEndTag () ; name = end . normalName () ; if ( name . equals ( lr_2 ) ) {
tb . pop () ; tb . transition ( mimeType ) ; } else if ( StringUtil . in ( name , lr_3 , lr_1 , lr_4 ) ) { return anythingElse ( t , tb ) ; } else { tb . error ( this ) ;
return false ; } break; default: return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , emitDoctypePending tb ) { tb . processEndTag ( lr_2 ) ; return tb . process ( t ) ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
return tb . process ( t , InBody ) ; } else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_15 ) ) { tb . pop () ; tb . transition ( InHead ) ;
} else if ( isWhitespace ( t ) || t . isComment () || ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_6 , lr_7 , lr_9 , lr_11 , lr_13 , lr_14 ) ) ) {
return tb . process ( t , InHead ) ; } else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_4 ) ) { return anythingElse ( t , tb ) ;
} else if ( ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_2 , lr_15 ) ) || t . isEndTag () ) { tb . error ( this ) ; return false ; } else {
return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; tb . insert ( new Token . Character () . data ( t . toString () ) ) ;
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ;
String name = startTag . normalName () ; if ( name . equals ( lr_1 ) ) { return tb . process ( t , InBody ) ; } else if ( name . equals ( lr_3 ) ) { tb . insert ( startTag ) ;
tb . framesetOk ( false ) ; tb . transition ( InBody ) ; } else if ( name . equals ( lr_17 ) ) { tb . insert ( startTag ) ; tb . transition ( tags ) ;
} else if ( StringUtil . in ( name , lr_5 , lr_6 , lr_7 , lr_9 , lr_11 , lr_13 , lr_16 , lr_14 , lr_12 ) ) { tb . error ( this ) ; Element head = tb . isStartTag () ;
tb . push ( head ) ; tb . process ( t , preserve ) ; tb . eofError ( head ) ; } else if ( name . equals ( lr_2 ) ) { tb . error ( this ) ; return false ; } else {
anythingElse ( t , tb ) ; } } else if ( t . isEndTag () ) { if ( StringUtil . in ( t . asEndTag () . normalName () , lr_3 , lr_1 ) ) { anythingElse ( t , tb ) ; } else {
tb . error ( this ) ; return false ; } } else { anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . emit ( lr_3 ) ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement () && isWhitespace ( c ) ) { tb . reconstructFormattingElements () ; tb . insert ( c ) ;
} else { tb . reconstructFormattingElements () ; tb . insert ( c ) ; tb . framesetOk ( false ) ; } break; } case Comment : { tb . insert ( t . asComment () ) ; break; } case MAXIMUM_CAPACITY : {
tb . error ( this ) ; return false ; } case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_18 ) ) {
if ( tb . codePointAt ( lr_18 ) != null ) { tb . error ( this ) ; tb . processEndTag ( lr_18 ) ; Element MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] = tb . isInvisibleChar ( lr_18 ) ; if ( mimeType != null ) { tb . codePointAt ( MST[rv.UOI4Mutator]MSP[N] ) ;
tb . eofError ( MST[rv.UOI4Mutator]MSP[N] ) ; } } tb . reconstructFormattingElements () ; Element a = tb . insert ( startTag ) ; tb . eofError ( a ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[rv.CRCR3Mutator]MSP[S] ) ) {
tb . reconstructFormattingElements () ; tb . codePointAt ( startTag ) ; tb . framesetOk ( false ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[rv.ABSMutator]MSP[N] ) ) { if ( tb . codePointAt ( lr_19 ) ) {
tb . processEndTag ( lr_19 ) ; } tb . insert ( startTag ) ; } else if ( name . equals ( lr_20 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ;
} else if ( name . equals ( lr_21 ) ) { tb . framesetOk ( false ) ; ArrayList < Element > stack = tb . asEndTag () ; for ( int i = stack . size () - 1 ; i > 0 ; i -- ) {
Element el = stack . get ( i ) ; if ( el . normalName () . equals ( lr_21 ) ) { tb . processEndTag ( lr_21 ) ; break; }
if ( tb . codePointAt ( el ) && ! StringUtil . inSorted ( el . normalName () , Constants . MST[rv.CRCR5Mutator]MSP[S] ) ) break; } if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; }
tb . insert ( startTag ) ; } else if ( name . equals ( lr_1 ) ) { tb . error ( this ) ; Element tags = tb . asEndTag () . get ( 0 ) ; for ( Attribute attribute : startTag . asStartTag () ) {
if ( ! tags . applyAsLong ( attribute . getKey () ) ) tags . attributes () . put ( attribute ) ; } } else if ( StringUtil . inSorted ( name , Constants . MST[NonVoidMethodCallMutator]MSP[N] ) ) { return tb . process ( t , preserve ) ;
} else if ( name . equals ( lr_3 ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . asEndTag () ;
if ( stack . size () == 1 || ( stack . size () > 2 && ! stack . get ( 1 ) . normalName () . equals ( lr_3 ) ) ) { return false ; } else { tb . framesetOk ( false ) ;
Element body = stack . get ( 1 ) ; for ( Attribute attribute : startTag . asStartTag () ) { if ( ! body . applyAsLong ( attribute . getKey () ) ) body . attributes () . put ( attribute ) ; } }
} else if ( name . equals ( lr_17 ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . asEndTag () ;
if ( stack . size () == 1 || ( stack . size () > 2 && ! stack . get ( 1 ) . normalName () . equals ( lr_3 ) ) ) { return false ; } else if ( ! tb . currentElement () ) {
return false ; } else { Element second = stack . get ( 1 ) ; if ( second . parent () != null ) second . remove () ; while ( stack . size () > 1 )
stack . remove ( stack . size () - 1 ) ; tb . insert ( startTag ) ; tb . transition ( tags ) ; } } else if ( StringUtil . inSorted ( name , Constants . forceQuirks ) ) {
if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } if ( StringUtil . inSorted ( tb . currentElement () . normalName () , Constants . forceQuirks ) ) { tb . error ( this ) ; tb . pop () ;
} tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[rv.ROR2Mutator]MSP[S] ) ) { if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . insert ( startTag ) ;
tb . reader . maxBodySize ( lr_22 ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( lr_23 ) ) { if ( tb . isStartTag () != null ) { tb . error ( this ) ; return false ; }
if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . MST[NonVoidMethodCallMutator]MSP[S] ( startTag , true ) ; } else if ( StringUtil . inSorted ( name , Constants . forceQuirks ) ) { tb . framesetOk ( false ) ;
ArrayList < Element > stack = tb . asEndTag () ; for ( int i = stack . size () - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ;
if ( StringUtil . inSorted ( el . normalName () , Constants . forceQuirks ) ) { tb . processEndTag ( el . normalName () ) ; break; }
if ( tb . codePointAt ( el ) && ! StringUtil . inSorted ( el . normalName () , Constants . MST[rv.CRCR5Mutator]MSP[S] ) ) break; } if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; }
tb . insert ( startTag ) ; } else if ( name . equals ( lr_24 ) ) { if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . insert ( startTag ) ;
tb . doctypePending . transition ( TokeniserState . forceQuirks ) ; } else if ( name . equals ( lr_25 ) ) { if ( tb . codePointAt ( lr_25 ) ) { tb . error ( this ) ; tb . processEndTag ( lr_25 ) ;
tb . process ( startTag ) ; } else { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; tb . framesetOk ( false ) ; } } else if ( StringUtil . inSorted ( name , Constants . MST[rv.UOI4Mutator]MSP[N] ) ) {
tb . reconstructFormattingElements () ; Element el = tb . insert ( startTag ) ; tb . eofError ( el ) ; } else if ( name . equals ( lr_26 ) ) { tb . reconstructFormattingElements () ; if ( tb . inSorted ( lr_26 ) ) {
tb . error ( this ) ; tb . processEndTag ( lr_26 ) ; tb . reconstructFormattingElements () ; } Element el = tb . insert ( startTag ) ; tb . isJavaIdentifierPart ( el ) ;
} else if ( StringUtil . inSorted ( name , Constants . 173 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; tb . currentElement () ; tb . framesetOk ( false ) ;
} else if ( name . equals ( lr_27 ) ) { if ( tb . currentElement () . relaxed () != Document . MST[NonVoidMethodCallMutator]MSP[S] . forceQuirks && tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; }
tb . insert ( startTag ) ; tb . framesetOk ( false ) ; tb . transition ( haystack ) ; } else if ( name . equals ( lr_28 ) ) { tb . reconstructFormattingElements () ; Element el = tb . codePointAt ( startTag ) ;
if ( ! el . attr ( lr_29 ) . equalsIgnoreCase ( lr_30 ) ) tb . framesetOk ( false ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[ReturnValsMutator]MSP[S] ) ) { tb . codePointAt ( startTag ) ;
} else if ( name . equals ( lr_31 ) ) { if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . codePointAt ( startTag ) ; tb . framesetOk ( false ) ;
} else if ( name . equals ( lr_32 ) ) { if ( tb . MST[NonVoidMethodCallMutator]MSP[S] ( lr_33 ) == null ) return tb . process ( startTag . name ( lr_34 ) ) ; else tb . insert ( startTag ) ;
} else if ( name . equals ( lr_35 ) ) { tb . error ( this ) ; if ( tb . isStartTag () != null ) return false ; tb . emit ( lr_23 ) ; if ( startTag . attributes . codePointAt ( lr_36 ) ) {
Element tags = tb . asStartTag () ; MST[NegateConditionalsMutator]MSP[N] . attr ( lr_36 , startTag . attributes . get ( lr_36 ) ) ; } tb . emit ( lr_31 ) ; tb . emit ( lr_37 ) ;
String stringCache = startTag . attributes . codePointAt ( lr_38 ) ? startTag . attributes . get ( lr_38 ) : lr_39 ; tb . process ( new Token . Character () . data ( stringCache ) ) ; Attributes MST[rv.ABSMutator]MSP[S] = new advance () ;
for ( Attribute attr : startTag . attributes ) { if ( ! StringUtil . inSorted ( attr . getKey () , Constants . MST[NegateConditionalsMutator]MSP[S] ) ) MST[rv.ROR5Mutator]MSP[S] . put ( attr ) ; } MST[rv.ROR4Mutator]MSP[S] . put ( lr_40 , lr_35 ) ;
tb . emit ( lr_28 , tags ) ; tb . processEndTag ( lr_37 ) ; tb . emit ( lr_31 ) ; tb . processEndTag ( lr_23 ) ; } else if ( name . equals ( lr_41 ) ) { tb . insert ( startTag ) ;
if ( ! startTag . isStartTag () ) { tb . doctypePending . transition ( TokeniserState . forceQuirks ) ; tb . currentElement () ; tb . framesetOk ( false ) ; tb . transition ( mimeType ) ; }
} else if ( name . equals ( lr_42 ) ) { if ( tb . codePointAt ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . reconstructFormattingElements () ; tb . framesetOk ( false ) ; MST[rv.ROR3Mutator]MSP[N] ( startTag , tb ) ;
} else if ( name . equals ( lr_43 ) ) { tb . framesetOk ( false ) ; MST[rv.ROR3Mutator]MSP[N] ( startTag , tb ) ; } else if ( name . equals ( lr_44 ) ) { MST[rv.ROR3Mutator]MSP[N] ( startTag , tb ) ;
} else if ( name . equals ( lr_45 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; tb . framesetOk ( false ) ; MST[NonVoidMethodCallMutator]MSP[N] MST[ReturnValsMutator]MSP[S] = tb . MST[rv.CRCR5Mutator]MSP[N] () ;
if ( MST[ReturnValsMutator]MSP[S] . equals ( haystack ) || MST[ReturnValsMutator]MSP[S] . equals ( haystack ) || MST[ReturnValsMutator]MSP[S] . equals ( tags ) || MST[rv.CRCR4Mutator]MSP[S] . equals ( Data ) || MST[ReturnValsMutator]MSP[S] . equals ( MST[rv.UOI1Mutator]MSP[S] ) ) tb . transition ( MST[rv.ROR2Mutator]MSP[S] ) ; else
tb . transition ( MST[rv.ROR2Mutator]MSP[S] ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[rv.ROR1Mutator]MSP[N] ) ) { if ( tb . currentElement () . normalName () . equals ( lr_46 ) ) tb . processEndTag ( lr_46 ) ; tb . reconstructFormattingElements () ;
tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . KeyVal ) ) { if ( tb . inSorted ( lr_47 ) ) { tb . currentElement () ;
if ( ! tb . currentElement () . normalName () . equals ( lr_47 ) ) { tb . error ( this ) ; tb . addAttributes ( lr_47 ) ; } tb . insert ( startTag ) ; }
} else if ( name . equals ( MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; } else if ( name . equals ( lr_33 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ;
} else if ( StringUtil . inSorted ( name , Constants . MST[NegateConditionalsMutator]MSP[S] ) ) { tb . error ( this ) ; return false ; } else { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; } break; case attributeSet :
Token . KeyVal endTag = t . asEndTag () ; name = endTag . normalName () ; if ( StringUtil . inSorted ( name , Constants . MST[rv.CRCR5Mutator]MSP[S] ) ) { for ( int i = 0 ; i < 8 ; i ++ ) {
Element Data = tb . codePointAt ( name ) ; if ( Data == null ) return maxBodySize ( t , tb ) ; else if ( ! tb . applyAsLong ( Data ) ) { tb . error ( this ) ; tb . codePointAt ( Data ) ;
return true ; } else if ( ! tb . eofError ( Data . normalName () ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement () != Data ) tb . error ( this ) ;
Element timeoutMilliseconds = null ; Element currentSet = null ; boolean mapSize = false ; ArrayList < Element > stack = tb . asEndTag () ; final int MST[NegateConditionalsMutator]MSP[S] = stack . size () ;
for ( int si = 0 ; si < mimeType && si < MST[rv.UOI1Mutator]MSP[N] ; si ++ ) { Element el = stack . get ( si ) ; if ( el == Data ) { MST[rv.UOI2Mutator]MSP[S] = stack . get ( si - 1 ) ;
MST[rv.UOI1Mutator]MSP[N] = true ; } else if ( maxBufferLen && tb . codePointAt ( el ) ) { accum = el ; break; } } if ( attributeSet == null ) { tb . popStackToClose ( Data . normalName () ) ; tb . codePointAt ( Data ) ;
return true ; } Element node = attributeSet ; Element mapSize = attributeSet ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( tb . applyAsLong ( node ) ) node = tb . applyAsLong ( node ) ;
if ( ! tb . codePointAt ( node ) ) { tb . MST[rv.ROR4Mutator]MSP[S] ( node ) ; continue; } else if ( node == Data ) break;
Element replacement = new Element ( MST[RemoveConditionalMutator_ORDER_IF]MSP[N] . valueOf ( node . currentElement () , attrProtocols . MST[rv.ROR1Mutator]MSP[S] ) , tb . relaxed () ) ; tb . MST[rv.ROR2Mutator]MSP[S] ( node , replacement ) ; tb . MST[rv.ROR2Mutator]MSP[S] ( node , replacement ) ; node = replacement ;
if ( mapSize == 160 ) { } if ( mapSize . parent () != null ) MST[NonVoidMethodCallMutator]MSP[N] . remove () ; node . advanceTransition ( mapSize ) ; mapSize = node ; }
if ( StringUtil . inSorted ( protSet . normalName () , Constants . forceQuirks ) ) { if ( mapSize . parent () != null ) currentSet . remove () ; tb . advanceTransition ( mapSize ) ; } else { if ( mapSize . parent () != null )
mapSize . remove () ; protSet . advanceTransition ( mapSize ) ; } Element doc = new Element ( accum . tag () , tb . relaxed () ) ; doc . attributes () . addAll ( doc . attributes () ) ;
Node [] MST[rv.CRCR3Mutator]MSP[N] = attributeSet . getUrl () . toArray ( new Node [ 0 ] ) ; for ( Node MST[ConstructorCallMutator]MSP[S] : tags ) { attrProtocols . framesetOk ( MST[rv.UOI3Mutator]MSP[S] ) ; } attrMap . advanceTransition ( tags ) ; tb . codePointAt ( Data ) ;
tb . eofError ( Data ) ; tb . MST[rv.ROR3Mutator]MSP[S] ( attributeSet , tags ) ; } } else if ( StringUtil . inSorted ( name , Constants . MST[experimental.NakedReceiverMutator]MSP[N] ) ) { if ( ! tb . eofError ( name ) ) {
tb . error ( this ) ; return false ; } else { tb . currentElement () ; if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; }
} else if ( name . equals ( lr_20 ) ) { return isInvisibleChar ( t , tb ) ; } else if ( name . equals ( lr_21 ) ) { if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ;
return false ; } else { tb . notEmpty ( name ) ; if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; }
} else if ( name . equals ( lr_3 ) ) { if ( ! tb . eofError ( lr_3 ) ) { tb . error ( this ) ; return false ; } else { tb . transition ( MST[rv.UOI1Mutator]MSP[N] ) ; }
} else if ( name . equals ( lr_1 ) ) { boolean MST[ArgumentPropagationMutator]MSP[N] = tb . processEndTag ( lr_3 ) ; if ( MST[rv.UOI3Mutator]MSP[S] ) return tb . process ( endTag ) ; } else if ( name . equals ( lr_23 ) ) {
Element haystack = tb . asStartTag () ; tb . codePointAt ( null ) ; if ( haystack == null || ! tb . eofError ( name ) ) { tb . error ( this ) ; return false ; } else { tb . currentElement () ;
if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . eofError ( haystack ) ; } } else if ( name . equals ( lr_19 ) ) {
if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ; tb . emit ( name ) ; return tb . process ( endTag ) ; } else { tb . consumeToAnySorted ( name ) ;
if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( StringUtil . inSorted ( name , Constants . forceQuirks ) ) {
if ( ! tb . eofError ( name ) ) { tb . error ( this ) ; return false ; } else { tb . processEndTag ( name ) ; if ( ! tb . currentElement () . normalName () . equals ( name ) )
tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( StringUtil . inSorted ( name , Constants . forceQuirks ) ) { if ( ! tb . eofError ( Constants . forceQuirks ) ) {
tb . error ( this ) ; return false ; } else { tb . notEmpty ( name ) ; if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ;
tb . popStackToClose ( Constants . forceQuirks ) ; } } else if ( name . equals ( lr_49 ) ) { return maxBodySize ( t , tb ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[rv.UOI2Mutator]MSP[N] ) ) {
if ( ! tb . eofError ( lr_40 ) ) { if ( ! tb . eofError ( name ) ) { tb . error ( this ) ; return false ; } tb . consumeLetterSequence () ;
if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . MST[ReturnValsMutator]MSP[S] () ; } } else if ( name . equals ( lr_4 ) ) {
tb . error ( this ) ; tb . emit ( lr_4 ) ; return false ; } else { return MST[rv.UOI1Mutator]MSP[N] ( t , tb ) ; } break; case EOF : break; } return true ; } boolean maxBodySize ( Token t , HtmlTreeBuilder tb ) {
String name = t . asEndTag () . normalName ; ArrayList < Element > stack = tb . asEndTag () ; for ( int pos = stack . size () - 1 ; pos >= 0 ; pos -- ) {
Element node = stack . get ( pos ) ; if ( node . normalName () . equals ( name ) ) { tb . notEmpty ( name ) ; if ( ! name . equals ( tb . currentElement () . normalName () ) )
tb . error ( this ) ; tb . popStackToClose ( name ) ; break; } else { if ( tb . codePointAt ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . asCharacter () ) { tb . error ( this ) ; tb . pop () ;
tb . transition ( tb . isStartTag () ) ; return tb . process ( t ) ; } else if ( t . isEndTag () ) { tb . pop () ; tb . transition ( tb . isStartTag () ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isCharacter () ) { tb . currentElement () ; tb . currentElement () ; tb . transition ( newSize ) ; return tb . process ( t ) ;
} else if ( t . isComment () ) { tb . insert ( t . asComment () ) ; return true ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_50 ) ) { tb . currentElement () ; tb . currentElement () ;
tb . insert ( startTag ) ; tb . transition ( haystack ) ; } else if ( name . equals ( lr_51 ) ) { tb . currentElement () ; tb . insert ( startTag ) ; tb . transition ( MST[rv.CRCR5Mutator]MSP[N] ) ;
} else if ( name . equals ( lr_52 ) ) { tb . emit ( lr_51 ) ; return tb . process ( t ) ; } else if ( StringUtil . in ( name , lr_53 , lr_54 , lr_55 ) ) { tb . currentElement () ;
tb . insert ( startTag ) ; tb . transition ( tags ) ; } else if ( StringUtil . in ( name , lr_56 , lr_57 , lr_58 ) ) { tb . emit ( lr_53 ) ; return tb . process ( t ) ;
} else if ( name . equals ( lr_27 ) ) { tb . error ( this ) ; boolean processed = tb . processEndTag ( lr_27 ) ; if ( processed ) return tb . process ( t ) ;
} else if ( StringUtil . in ( name , lr_14 , lr_16 ) ) { return tb . process ( t , preserve ) ; } else if ( name . equals ( lr_28 ) ) {
if ( ! startTag . attributes . get ( lr_29 ) . equalsIgnoreCase ( lr_30 ) ) { return anythingElse ( t , tb ) ; } else { tb . codePointAt ( startTag ) ; } } else if ( name . equals ( lr_23 ) ) {
tb . error ( this ) ; if ( tb . asStartTag () != null ) return false ; else { tb . MST[NonVoidMethodCallMutator]MSP[S] ( startTag , false ) ; } } else { return anythingElse ( t , tb ) ; } return true ;
} else if ( t . isEndTag () ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ; if ( name . equals ( lr_27 ) ) { if ( ! tb . codePointAt ( name ) ) {
tb . error ( this ) ; return false ; } else { tb . popStackToClose ( lr_27 ) ; } tb . currentElement () ; } else if ( StringUtil . in ( name ,
lr_3 , lr_50 , lr_52 , lr_51 , lr_1 , lr_53 , lr_56 , lr_54 , lr_57 , lr_55 , lr_58 ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ;
} else if ( t . asCharacter () ) { if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) tb . error ( this ) ; return true ; } return anythingElse ( t , tb ) ; }
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement () . normalName () , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 ) ) {
tb . processEndTag ( true ) ; processed = tb . process ( t , InBody ) ; tb . MST[NonVoidMethodCallMutator]MSP[S] ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
return false ; } else { tb . asStartTag () . add ( c . getData () ) ; } break; default: if ( tb . asStartTag () . size () > 0 ) { for ( String MST[rv.CRCR4Mutator]MSP[S] : tb . asStartTag () ) {
if ( ! isWhitespace ( MST[rv.UOI3Mutator]MSP[S] ) ) { tb . error ( this ) ; if ( StringUtil . in ( tb . currentElement () . normalName () , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 ) ) { tb . MST[NonVoidMethodCallMutator]MSP[N] ( true ) ;
tb . process ( new Token . Character () . data ( MST[rv.CRCR4Mutator]MSP[S] ) , InBody ) ; tb . MST[NonVoidMethodCallMutator]MSP[S] ( false ) ; } else { tb . process ( new Token . Character () . data ( MST[rv.CRCR4Mutator]MSP[S] ) , InBody ) ; } } else
tb . insert ( new Token . Character () . data ( MST[rv.UOI3Mutator]MSP[S] ) ) ; } tb . currentElement () ; } tb . transition ( tb . isStartTag () ) ; return tb . process ( t ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ;
if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ; return false ; } else { tb . currentElement () ; if ( ! tb . currentElement () . normalName () . equals ( lr_50 ) )
tb . error ( this ) ; tb . popStackToClose ( lr_50 ) ; tb . isStartTag () ; tb . transition ( haystack ) ; } } else if ( ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () ,
lr_50 , lr_52 , lr_51 , lr_53 , lr_56 , lr_54 , lr_57 , lr_55 , lr_58 ) || t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_27 ) ) ) { tb . error ( this ) ;
boolean processed = tb . processEndTag ( lr_50 ) ; if ( processed ) return tb . process ( t ) ; } else if ( t . isEndTag () && StringUtil . in ( t . asEndTag () . normalName () ,
lr_3 , lr_52 , lr_51 , lr_1 , lr_53 , lr_56 , lr_54 , lr_57 , lr_55 , lr_58 ) ) { tb . error ( this ) ; return false ; } else { return tb . process ( t , InBody ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
tb . insert ( t . asComment () ) ; break; case MAXIMUM_CAPACITY : tb . error ( this ) ; break; case StartTag : Token . StartTag startTag = t . asStartTag () ; switch ( startTag . normalName () ) { case lr_1 :
return tb . process ( t , InBody ) ; case lr_52 : tb . codePointAt ( startTag ) ; break; default: return anythingElse ( t , tb ) ; } break; case attributeSet : Token . KeyVal endTag = t . asEndTag () ;
if ( endTag . normalName . equals ( lr_51 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) { tb . error ( this ) ; return false ; } else { tb . pop () ;
tb . transition ( haystack ) ; } } else return anythingElse ( t , tb ) ; break; case EOF : if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) return true ; else return anythingElse ( t , tb ) ; default:
return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , method tb ) { boolean processed = tb . processEndTag ( lr_51 ) ; if ( processed ) return tb . process ( t ) ; return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
tb . insert ( startTag ) ; } else if ( name . equals ( lr_58 ) ) { tb . currentElement () ; tb . insert ( startTag ) ; tb . transition ( Data ) ;
} else if ( StringUtil . in ( name , lr_57 , lr_56 ) ) { tb . error ( this ) ; tb . emit ( lr_58 ) ; return tb . process ( startTag ) ;
} else if ( StringUtil . in ( name , lr_50 , lr_52 , lr_51 , lr_53 , lr_54 , lr_55 ) ) { return anythingElse ( t , tb ) ; } else return anythingElse ( t , tb ) ; break; case AttributeValue :
Token . KeyVal endTag = t . asEndTag () ; name = endTag . normalName () ; if ( StringUtil . in ( name , lr_53 , lr_54 , lr_55 ) ) { if ( ! tb . codePointAt ( name ) ) {
tb . error ( this ) ; return false ; } else { tb . currentElement () ; tb . pop () ; tb . transition ( haystack ) ; } } else if ( name . equals ( lr_27 ) ) {
return anythingElse ( t , tb ) ; } else if ( StringUtil . in ( name , lr_3 , lr_50 , lr_52 , lr_51 , lr_1 , lr_56 , lr_57 , lr_58 ) ) { tb . error ( this ) ; return false ; } else
return anythingElse ( t , tb ) ; break; default: return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) {
if ( ! ( tb . codePointAt ( lr_53 ) || tb . codePointAt ( lr_55 ) || tb . eofError ( lr_54 ) ) ) { tb . error ( this ) ; return false ; } tb . isDoctype () ;
tb . processEndTag ( tb . currentElement () . normalName () ) ; return tb . process ( t ) ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { return tb . process ( t , haystack ) ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , lr_57 , lr_56 ) ) { tb . asStartTag () ; tb . insert ( startTag ) ; tb . transition ( oldValue ) ; tb . currentElement () ;
} else if ( StringUtil . in ( name , lr_50 , lr_52 , lr_51 , lr_53 , lr_54 , lr_55 , lr_58 ) ) { return MST[NonVoidMethodCallMutator]MSP[N] ( t , tb ) ; } else { return anythingElse ( t , tb ) ; }
} else if ( t . isEndTag () ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ; if ( name . equals ( lr_58 ) ) { if ( ! tb . codePointAt ( name ) ) {
tb . error ( this ) ; return false ; } tb . isStartTag () ; tb . pop () ; tb . transition ( tags ) ; } else if ( name . equals ( lr_27 ) ) { return MST[rv.UOI1Mutator]MSP[N] ( t , tb ) ;
} else if ( StringUtil . in ( name , lr_53 , lr_54 , lr_55 ) ) { if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ; return false ; } tb . processEndTag ( lr_58 ) ;
return tb . process ( t ) ; } else if ( StringUtil . in ( name , lr_3 , lr_50 , lr_52 , lr_51 , lr_1 , lr_56 , lr_57 ) ) { tb . error ( this ) ; return false ; } else {
return anythingElse ( t , tb ) ; } } else { return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { return tb . process ( t , haystack ) ; }
private boolean MST[NonVoidMethodCallMutator]MSP[N] ( Token t , link tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) {
if ( t . isEndTag () ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ; if ( StringUtil . inSorted ( name , Constants . MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ) ) {
if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ; tb . transition ( Data ) ; return false ; } tb . currentElement () ; if ( ! tb . currentElement () . normalName () . equals ( name ) )
tb . error ( this ) ; tb . notEmpty ( name ) ; tb . isStartTag () ; tb . transition ( Data ) ; } else if ( StringUtil . inSorted ( name , Constants . MST[rv.UOI1Mutator]MSP[N] ) ) { tb . error ( this ) ;
return false ; } else if ( StringUtil . inSorted ( name , Constants . MST[NonVoidMethodCallMutator]MSP[N] ) ) { if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ; return false ; } MST[rv.UOI1Mutator]MSP[N] ( tb ) ;
return tb . process ( t ) ; } else { return anythingElse ( t , tb ) ; } } else if ( t . isStartTag () && StringUtil . inSorted ( t . asStartTag () . normalName () , Constants . MST[rv.CRCR5Mutator]MSP[S] ) ) {
if ( ! ( tb . codePointAt ( lr_56 ) || tb . codePointAt ( lr_57 ) ) ) { tb . error ( this ) ; return false ; } MST[rv.UOI1Mutator]MSP[N] ( tb ) ; return tb . process ( t ) ; } else {
return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { return tb . process ( t , InBody ) ; } private void MST[rv.UOI1Mutator]MSP[N] ( HtmlTreeBuilder tb ) {
if ( tb . codePointAt ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character :
Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else { tb . insert ( c ) ; } break; case Comment :
tb . insert ( t . asComment () ) ; break; case MAXIMUM_CAPACITY : tb . error ( this ) ; return false ; case StartTag : Token . StartTag start = t . asStartTag () ; String name = start . normalName () ;
if ( name . equals ( lr_1 ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( lr_46 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_46 ) )
tb . processEndTag ( lr_46 ) ; tb . insert ( start ) ; } else if ( name . equals ( lr_60 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_46 ) ) tb . processEndTag ( lr_46 ) ;
if ( tb . currentElement () . normalName () . equals ( lr_60 ) ) tb . processEndTag ( lr_60 ) ; tb . insert ( start ) ; } else if ( name . equals ( lr_45 ) ) { tb . error ( this ) ;
return tb . processEndTag ( lr_45 ) ; } else if ( StringUtil . in ( name , lr_28 , lr_61 , lr_41 ) ) { tb . error ( this ) ; if ( ! tb . applyAsLong ( lr_45 ) ) return false ;
tb . processEndTag ( lr_45 ) ; return tb . process ( start ) ; } else if ( name . equals ( lr_16 ) ) { return tb . process ( t , InHead ) ; } else { return anythingElse ( t , tb ) ; } break;
case attributeSet : Token . KeyVal end = t . asEndTag () ; name = end . normalName () ; switch ( name ) { case lr_60 :
if ( tb . currentElement () . normalName () . equals ( lr_46 ) && tb . applyAsLong ( tb . currentElement () ) != null && tb . applyAsLong ( tb . currentElement () ) . normalName () . equals ( lr_60 ) )
tb . processEndTag ( lr_46 ) ; if ( tb . currentElement () . normalName () . equals ( lr_60 ) ) tb . pop () ; else tb . error ( this ) ; break; case lr_46 :
if ( tb . currentElement () . normalName () . equals ( lr_46 ) ) tb . pop () ; else tb . error ( this ) ; break; case lr_45 : if ( ! tb . codePointAt ( name ) ) { tb . error ( this ) ;
return false ; } else { tb . popStackToClose ( name ) ; tb . currentElement () ; } break; default: return anythingElse ( t , tb ) ; } break; case EOF : if ( ! tb . currentElement () . normalName () . equals ( lr_1 ) )
tb . error ( this ) ; break; default: return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; return false ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
tb . error ( this ) ; tb . processEndTag ( lr_45 ) ; return tb . process ( t ) ;
} else if ( t . isEndTag () && StringUtil . in ( t . asEndTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) { tb . error ( this ) ;
if ( tb . codePointAt ( t . asEndTag () . normalName () ) ) { tb . processEndTag ( lr_45 ) ; return ( tb . process ( t ) ) ; } else return false ; } else {
return tb . process ( t , MST[NegateConditionalsMutator]MSP[N] ) ; } } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return tb . process ( t , InBody ) ; } else if ( t . isComment () ) {
tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { return tb . process ( t , InBody ) ;
} else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_1 ) ) { if ( tb . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () ) { tb . error ( this ) ; return false ; } else {
tb . transition ( MST[rv.ROR5Mutator]MSP[S] ) ; } } else if ( t . asCharacter () ) { } else { tb . error ( this ) ; tb . transition ( InBody ) ; return tb . process ( t ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () ) { tb . error ( this ) ; return false ; } else if ( t . isStartTag () ) { Token . StartTag start = t . asStartTag () ; switch ( start . normalName () ) {
case lr_1 : return tb . process ( start , InBody ) ; case lr_17 : tb . insert ( start ) ; break; case lr_62 : tb . codePointAt ( start ) ; break; case lr_13 : return tb . process ( start , InHead ) ; default:
tb . error ( this ) ; return false ; } } else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_17 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) {
tb . error ( this ) ; return false ; } else { tb . pop () ; if ( ! tb . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () && ! tb . currentElement () . normalName () . equals ( lr_17 ) ) { tb . transition ( MST[NonVoidMethodCallMutator]MSP[N] ) ; } }
} else if ( t . asCharacter () ) { if ( ! tb . currentElement () . normalName () . equals ( lr_1 ) ) { tb . error ( this ) ; return true ; } } else { tb . error ( this ) ;
return false ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { return tb . process ( t , InBody ) ;
} else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_1 ) ) { tb . transition ( classname ) ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_13 ) ) { return tb . process ( t , InHead ) ; } else if ( t . asCharacter () ) { } else {
tb . error ( this ) ; return false ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () || isWhitespace ( t ) || ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) ) { return tb . process ( t , InBody ) ;
} else if ( t . asCharacter () ) { } else { tb . error ( this ) ; tb . transition ( InBody ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) {
if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () || isWhitespace ( t ) || ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) ) { return tb . process ( t , InBody ) ;
} else if ( t . asCharacter () ) { } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_13 ) ) { return tb . process ( t , preserve ) ; } else {
tb . error ( this ) ; return false ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { return true ; } private static boolean isWhitespace ( Token t ) { if ( t . isCharacter () ) {
String data = t . asCharacter () . getData () ; return isWhitespace ( data ) ; } return false ; } private static boolean isWhitespace ( String data ) { return StringUtil . isBlank ( data ) ; }
private static void MST[NonVoidMethodCallMutator]MSP[N] ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . doctypePending . transition ( TokeniserState . forceQuirks ) ; tb . currentElement () ; tb . transition ( mimeType ) ; tb . insert ( startTag ) ; }
private static void simpleText ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . doctypePending . transition ( TokeniserState . forceQuirks ) ; tb . currentElement () ; tb . transition ( mimeType ) ; tb . insert ( startTag ) ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; case MST[rv.ROR4Mutator]MSP[N] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; case MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case Character : . error ( this ) ; case Character : . error ( this ) ; case Character : . error ( this ) ; case Character : .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; case MST[NegateConditionalsMutator]MSP[N] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; case . error ( this ) ; case { tb . error ( this ) ; case Character : . error ( this ) ; case Character : . error ( this ) ; case Character : . error ( this ) ; case Character : . error (
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; case MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] tb . error ( this ) ; case MST[rv.ABSMutator]MSP[S] tb . error ( this ) ; case Character : . error ( this ) ; case Character : . error ( this ) ; case Character : . error ( this ) ; case Character : .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . KeyVal endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
private boolean MST[NonVoidMethodCallMutator]MSP[N] ( Token t , link tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N]
private boolean MST[NonVoidMethodCallMutator]MSP[N] ( Token t , link tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N]
private boolean MST[NonVoidMethodCallMutator]MSP[N] ( Token t , link tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N]
private boolean MST[NonVoidMethodCallMutator]MSP[N] ( Token t , link tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N]
private boolean MST[NonVoidMethodCallMutator]MSP[N] ( Token t , link tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N]
if ( tb . codePointAt ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . codePointAt ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . codePointAt ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . codePointAt ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . codePointAt ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case Character :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else { tb . transition ( haystack ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( haystack ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( haystack ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( haystack ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( haystack ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
tb . codePointAt ( lr_1 ) ; tb . transition ( mimeType ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . codePointAt ( lr_1 ) ; tb . transition ( mimeType ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . codePointAt ( lr_1 ) ; tb . transition ( mimeType ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . codePointAt ( lr_1 ) ; tb . transition ( mimeType ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . codePointAt ( lr_1 ) ; tb . transition ( mimeType ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isCharacter () ) { tb . currentElement () ; tb . currentElement () ; tb . transition ( newSize ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isCharacter () ) { tb . currentElement () ; tb . currentElement () ; tb . transition ( newSize ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isCharacter () ) { tb . currentElement () ; tb . currentElement () ; tb . transition ( newSize ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isCharacter () ) { tb . currentElement () ; tb . currentElement () ; tb . transition ( newSize ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isCharacter () ) { tb . currentElement () ; tb . currentElement () ; tb . transition ( newSize ) ; return tb . process ( t ) ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . asCharacter () ) { tb . error ( this ) ; tb . pop () ; ; else if ( this ) ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . asCharacter () ) { tb . error ( this ) ; tb . pop () ; ; else this ( this ) ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . asCharacter () ) { tb . error ( this ) ; tb . pop () ; ; else this ( this ) ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . asCharacter () ) { tb . error ( this ) ; tb . pop () ; ; else this ( this ) ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb .
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . asCharacter () ) { tb . error ( this ) ; tb . pop () ; ; else this ( this ) ; tb . pop () ; ; else this () ; tb . pop () ; ; else this () ; tb . pop () ; ; else modCount () ) ; tb . pop () ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( this )
public static Connection connect ( String url ) { Connection MST[rv.CRCR5Mutator]MSP[S] = new MST[ReturnValsMutator]MSP[S] () ; MST[NonVoidMethodCallMutator]MSP[N] . url ( url ) ; return keyval ; } public static Connection connect ( URL url ) { Connection MST[rv.CRCR3Mutator]MSP[S] = new MST[ReturnValsMutator]MSP[S] () ; MST[rv.UOI4Mutator]MSP[N] . url ( url ) ;
return keyval ; } private static String MST[rv.ROR4Mutator]MSP[N] ( String url ) { try { URL u = new URL ( url ) ; return MST[rv.CRCR6Mutator]MSP[N] ( u ) . emitDoctypePending () ; } catch ( Exception e ) { return url ; } }
static URL relaxed ( URL u ) { try { String removeProtocols = u . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () ; MST[rv.ROR2Mutator]MSP[S] = removeProtocols . replace ( lr_1 , lr_2 ) ; final URI uri = new URI ( removeProtocols ) ; return new URL ( uri . isStartTag () ) ;
} catch ( MST[ConstructorCallMutator]MSP[S] | MalformedURLException e ) { return u ; } } private static String MST[rv.ROR2Mutator]MSP[S] ( String val ) { if ( val == null ) return null ; return val . replace ( lr_3 , lr_4 ) ; }
public Connection url ( URL url ) { req . url ( url ) ; return this ; } public Connection url ( String url ) { Validate . notEmpty ( url , lr_5 ) ; try {
req . url ( new URL ( MST[rv.CRCR6Mutator]MSP[N] ( url ) ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( lr_6 + url , e ) ; } return this ; } public Connection proxy ( Proxy proxy ) {
req . proxy ( proxy ) ; return this ; } public Connection proxy ( String host , int port ) { req . proxy ( host , port ) ; return this ; } public Connection userAgent ( String userAgent ) {
Validate . notNull ( userAgent , lr_7 ) ; req . header ( newSize , userAgent ) ; return this ; } public Connection timeout ( int millis ) { req . timeout ( millis ) ; return this ; } public Connection maxBodySize ( int bytes ) {
req . maxBodySize ( bytes ) ; return this ; } public Connection relaxed ( boolean MST[rv.CRCR3Mutator]MSP[S] ) { req . codePointAt ( MST[rv.ROR5Mutator]MSP[S] ) ; return this ; } public Connection removeAttributes ( String MST[rv.UOI3Mutator]MSP[S] ) { Validate . notNull ( MST[rv.UOI3Mutator]MSP[S] , lr_8 ) ;
req . header ( lr_9 , MST[rv.UOI4Mutator]MSP[N] ) ; return this ; } public Connection method ( Method method ) { req . method ( method ) ; return this ; } public Connection codePointAt ( boolean ignoreHttpErrors ) { req . codePointAt ( ignoreHttpErrors ) ; return this ;
} public Connection ignoreContentType ( boolean ignoreContentType ) { req . ignoreContentType ( ignoreContentType ) ; return this ; } public Connection data ( String key , String value ) { req . data ( KeyVal . create ( key , value ) ) ; return this ; }
public Connection codePointAt ( SSLSocketFactory sslSocketFactory ) { req . codePointAt ( sslSocketFactory ) ; return this ; } public Connection data ( String key , String filename , InputStream inputStream ) { req . data ( KeyVal . create ( key , filename , inputStream ) ) ;
return this ; } @Override public Connection data ( String key , String filename , InputStream inputStream , String contentType ) { req . data ( KeyVal . create ( key , filename , inputStream ) . MST[NonVoidMethodCallMutator]MSP[N] ( contentType ) ) ; return this ; }
public Connection data ( Map < String , String > data ) { Validate . notNull ( data , lr_10 ) ; for ( Map . Entry < String , String > entry : data . entrySet () ) {
req . data ( KeyVal . create ( entry . getKey () , entry . getValue () ) ) ; } return this ; } public Connection data ( String ... tags ) { Validate . notNull ( MST[rv.UOI3Mutator]MSP[S] , lr_11 ) ;
Validate . isTrue ( MST[rv.CRCR5Mutator]MSP[N] . length % 2 == 0 , lr_12 ) ; for ( int i = 0 ; i < operation . length ; i += 2 ) { String key = MST[rv.CRCR1Mutator]MSP[N] [ i ] ;
String value = tags [ i + 1 ] ; Validate . notEmpty ( key , lr_13 ) ; Validate . notNull ( value , lr_14 ) ; req . data ( KeyVal . create ( key , value ) ) ; } return this ; }
public Connection data ( Collection < Connection . KeyVal > data ) { Validate . notNull ( data , lr_15 ) ; for ( Connection . KeyVal entry : data ) { req . data ( entry ) ; } return this ; }
public Connection . KeyVal data ( String key ) { Validate . notEmpty ( key , lr_13 ) ; for ( Connection . KeyVal protSet : MST[NonVoidMethodCallMutator]MSP[N] () . data () ) { if ( 8203 . key () . equals ( key ) ) return 8203 ; }
return null ; } public Connection simpleText ( String body ) { req . maxBodySize ( body ) ; return this ; } public Connection header ( String name , String value ) { req . header ( name , value ) ; return this ; }
public Connection maxBodySize ( Map < String , String > MST[rv.UOI2Mutator]MSP[N] ) { Validate . notNull ( MST[rv.UOI2Mutator]MSP[N] , lr_16 ) ; for ( Map . Entry < String , String > entry : attr . entrySet () ) {
req . header ( entry . getKey () , entry . getValue () ) ; } return this ; } public Connection notEmpty ( String name , String value ) { req . notEmpty ( name , value ) ; return this ; }
public Connection codePointAt ( Map < String , String > ignoreHttpErrors ) { Validate . notNull ( ignoreContentType , lr_17 ) ; for ( Map . Entry < String , String > entry : ignoreContentType . entrySet () ) {
req . eofError ( entry . getKey () , entry . getValue () ) ; } return this ; } public Connection parser ( ignoreContentType parser ) { req . parser ( parser ) ; return this ; } public Document get () throws IOException {
req . method ( Method . forceQuirks ) ; execute () ; return res . parse () ; } public Document consumeLetterSequence () throws IOException { req . method ( Method . MST[ReturnValsMutator]MSP[S] ) ; execute () ; return res . parse () ; }
public Connection . link execute () throws IOException { res = haystack . execute ( req ) ; return res ; } public Connection . Request MST[NonVoidMethodCallMutator]MSP[S] { return req ; } public Connection process ( Connection . Request request ) { req = request ; return this ;
} public Connection . ignoreContentType MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] () { return res ; } public Connection MST[rv.ROR5Mutator]MSP[S] ( Connection . ignoreContentType response ) { res = response ; return this ; } public Connection codePointAt ( String charset ) { req . codePointAt ( charset ) ; return this ; }
public URL url () { return url ; } public T url ( URL url ) { Validate . notNull ( url , lr_18 ) ; this . url = url ; return ( T ) this ; } public Method method () { return method ; }
public T method ( Method method ) { Validate . notNull ( method , lr_19 ) ; this . method = method ; return ( T ) this ; } public String header ( String name ) { Validate . notNull ( name , lr_20 ) ;
List < String > vals = maxBodySize ( name ) ; if ( vals . size () > 0 ) { return StringUtil . join ( vals , lr_21 ) ; } return null ; } @Override public T removeAttributes ( String name , String value ) {
Validate . notEmpty ( name ) ; value = value == null ? lr_22 : value ; List < String > values = maxBodySize ( name ) ; if ( values . isEmpty () ) { values = new ArrayList <> () ;
MST[rv.UOI2Mutator]MSP[N] . put ( name , values ) ; } values . add ( MST[NonVoidMethodCallMutator]MSP[S] ( value ) ) ; return ( T ) this ; } @Override public List < String > maxBodySize ( String name ) { Validate . notEmpty ( name ) ;
return eofError ( name ) ; } private static String maxBodySize ( String val ) { try { byte [] bytes = val . getBytes ( lr_23 ) ; if ( ! containsSpace ( bytes ) ) return val ; return new String ( bytes , lr_24 ) ;
} catch ( UnsupportedEncodingException e ) { return val ; } } private static boolean MST[NegateConditionalsMutator]MSP[S] ( byte [] input ) { int i = 0 ; if ( input . length >= 3 && ( input [ 0 ] & 0xFF ) == MST[rv.ABSMutator]MSP[S]
&& ( input [ 1 ] & 0xFF ) == MST[rv.UOI2Mutator]MSP[N] & ( input [ 2 ] & 0xFF ) == MST[NonVoidMethodCallMutator]MSP[N] ) { i = 3 ; } int end ; for ( int j = input . length ; i < j ; ++ i ) {
int o = input [ i ] ; if ( ( o & MST[ReturnValsMutator]MSP[S] ) == 0 ) { continue; } if ( ( o & MST[InlineConstantMutator]MSP[S] ) == 173 ) { end = i + 1 ;
} else if ( ( o & MST[ConditionalsBoundaryMutator]MSP[S] ) == MST[NegateConditionalsMutator]MSP[N] ) { end = i + 2 ; } else if ( ( o & MST[rv.CRCR6Mutator]MSP[S] ) == MST[ConditionalsBoundaryMutator]MSP[S] ) { end = i + 3 ; } else { return false ; }
if ( end >= input . length ) return false ; while ( i < end ) { i ++ ; o = input [ i ] ; if ( ( o & MST[rv.ROR1Mutator]MSP[S] ) != loadFactor ) { return false ; } } } return true ; }
public T header ( String name , String value ) { Validate . notEmpty ( name , lr_25 ) ; MST[rv.ROR4Mutator]MSP[N] ( name ) ; MST[rv.UOI2Mutator]MSP[S] ( name , value ) ; return ( T ) this ; } public boolean removeAttributes ( String name ) {
Validate . notEmpty ( name , lr_25 ) ; return ! isInvisibleChar ( name ) . isEmpty () ; } public boolean anythingElse ( String name , String value ) { Validate . notEmpty ( name ) ; Validate . notEmpty ( value ) ;
List < String > values = framesetOk ( name ) ; for ( String MST[rv.ROR2Mutator]MSP[N] : values ) { if ( value . equalsIgnoreCase ( MST[rv.UOI1Mutator]MSP[N] ) ) return true ; } return false ; } public T removeTags ( String name ) {
Validate . notEmpty ( name , lr_25 ) ; Map . Entry < String , List < String > > entry = MST[rv.ROR1Mutator]MSP[N] ( name ) ; if ( entry != null ) MST[rv.UOI2Mutator]MSP[N] . remove ( entry . getKey () ) ; return ( T ) this ; }
public Map < String , String > MST[rv.ROR4Mutator]MSP[N] () { LinkedHashMap < String , String > map = new LinkedHashMap <> ( attr . size () ) ; for ( Map . Entry < String , List < String > > entry : attr . entrySet () ) {
String header = entry . getKey () ; List < String > values = entry . getValue () ; if ( values . size () > 0 ) map . put ( header , values . get ( 0 ) ) ; } return map ; } @Override
public Map < String , List < String > > MST[rv.ROR4Mutator]MSP[N] () { return MST[rv.CRCR6Mutator]MSP[N] ; } private List < String > codePointAt ( String name ) { Validate . notNull ( name ) ;
for ( Map . Entry < String , List < String > > entry : attr . entrySet () ) { if ( name . equalsIgnoreCase ( entry . getKey () ) ) return entry . getValue () ; } return Collections . emptyList () ; }
private Map . Entry < String , List < String > > MST[rv.CRCR3Mutator]MSP[N] ( String name ) { String MST[InlineConstantMutator]MSP[S] = inSorted ( name ) ; for ( Map . Entry < String , List < String > > entry : attr . entrySet () ) {
if ( inSorted ( entry . getKey () ) . equals ( MST[rv.UOI1Mutator]MSP[S] ) ) return entry ; } return null ; } public String eofError ( String name ) { Validate . notEmpty ( name , lr_26 ) ; return 160 . get ( name ) ; }
public T eofError ( String name , String value ) { Validate . notEmpty ( name , lr_26 ) ; Validate . notNull ( value , lr_27 ) ; attrMap . put ( name , value ) ; return ( T ) this ; }
public boolean applyAsLong ( String name ) { Validate . notEmpty ( name , lr_26 ) ; return haystack . containsKey ( name ) ; } public T removeAttributes ( String name ) { Validate . notEmpty ( name , lr_26 ) ; ignoreHttpErrors . remove ( name ) ;
return ( T ) this ; } public Map < String , String > getMimeType () { return ignoreContentType ; } public Proxy proxy () { return proxy ; } public Request proxy ( Proxy proxy ) { this . proxy = proxy ; return this ; }
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . isTrue ( bytes >= 0 , lr_29 ) ; maxBodySizeBytes = bytes ; return this ; } public boolean relaxed () { return MST[rv.CRCR5Mutator]MSP[S] ; } public Connection . Request relaxed ( boolean MST[NonVoidMethodCallMutator]MSP[S] ) { this . MST[rv.ROR5Mutator]MSP[N] = MST[ReturnValsMutator]MSP[N] ; return this ; }
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void inputStream ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ;
return this ; } public String getMimeType () { return body ; } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; }
public Connection . Request codePointAt ( String charset ) { Validate . notNull ( charset , lr_31 ) ; if ( ! Charset . applyAsLong ( charset ) ) throw new MST[rv.ROR5Mutator]MSP[N] ( charset ) ; this . ignoreContentType = charset ; return this ; }
public String getMimeType () { return ignoreContentType ; } static Proxy execute ( Connection . Request req ) throws IOException { return execute ( req , null ) ; } static Proxy execute ( Connection . Request req , ignoreContentType nullChar ) throws IOException {
Validate . notNull ( req , lr_32 ) ; Validate . notNull ( req . url () , lr_33 ) ; String protocol = req . url () . getProtocol () ; if ( ! protocol . equals ( lr_34 ) && ! protocol . equals ( lr_35 ) )
throw new MalformedURLException ( lr_36 ) ; final boolean MST[rv.CRCR5Mutator]MSP[S] = req . method () . MST[rv.ROR5Mutator]MSP[N] () ; final boolean MST[rv.UOI3Mutator]MSP[S] = req . emitDoctypePending () != null ; if ( ! MST[rv.UOI3Mutator]MSP[S] ) Validate . codePointAt ( MST[rv.UOI3Mutator]MSP[S] , lr_37 + req . method () ) ;
String tags = null ; if ( req . data () . size () > 0 && ( ! MST[rv.CRCR4Mutator]MSP[S] || capacity ) ) MST[rv.ROR2Mutator]MSP[N] ( req ) ; else if ( MST[rv.UOI3Mutator]MSP[S] ) tags = MST[NegateConditionalsMutator]MSP[S] ( req ) ; long MST[rv.ROR2Mutator]MSP[N] = System . MST[ReturnValsMutator]MSP[N] () ;
CharacterReader = isInvisibleChar ( req ) ; . res = null ; try { conn . connect () ; if ( conn . isStartTag () ) MST[NonVoidMethodCallMutator]MSP[S] ( req , conn . getOutputStream () , tags ) ; int MST[NullReturnValsMutator]MSP[N] = conn . isStartTag () ;
res = new Proxy ( nullChar ) ; res . codePointAt ( conn , nullChar ) ; res . req = req ; if ( res . codePointAt ( 173 ) && req . relaxed () ) { if ( MST[NullReturnValsMutator]MSP[N] != 173 ) {
req . method ( Method . forceQuirks ) ; req . data () . clear () ; req . emitDoctypePending ( null ) ; req . MST[rv.CRCR6Mutator]MSP[S] ( tags ) ; } String location = res . header ( 173 ) ;
if ( location . startsWith ( lr_38 ) && location . charAt ( 6 ) != '/' ) location = location . substring ( 6 ) ; URL haystack = StringUtil . resolve ( req . url () , location ) ;
req . url ( MST[rv.UOI1Mutator]MSP[N] ( tags ) ) ; for ( Map . Entry < String , String > accum : res . forceQuirks . entrySet () ) { req . notEmpty ( accum . getKey () , accum . getValue () ) ; }
return execute ( req , res ) ; } if ( ( stream < MST[rv.UOI2Mutator]MSP[S] || MST[rv.ROR1Mutator]MSP[N] >= MST[rv.ROR5Mutator]MSP[S] ) && ! req . asCharacter () ) throw new MST[rv.ROR5Mutator]MSP[S] ( lr_39 , MST[NullReturnValsMutator]MSP[N] , req . url () . toString () ) ;
String contentType = res . contentType () ; if ( contentType != null && ! req . ignoreContentType () && ! contentType . startsWith ( lr_40 ) && ! MST[ArgumentPropagationMutator]MSP[N] . matcher ( contentType ) . matches () ) throw new MST[rv.ROR5Mutator]MSP[S] ( lr_41 ,
contentType , req . url () . toString () ) ; if ( contentType != null && MST[rv.UOI3Mutator]MSP[N] . matcher ( contentType ) . matches () ) { if ( req instanceof MST[rv.UOI1Mutator]MSP[N] . Request && ! ( ( Request ) req ) . mimeType ) {
req . parser ( haystack . currentElement () ) ; } } res . charset = haystack . codePointAt ( res . contentType ) ; if ( conn . asStartTag () != 0 && req . method () != MST[rv.UOI1Mutator]MSP[N] ) { res . CLASS_VALUE = null ;
res . KeyVal = conn . MST[rv.CRCR6Mutator]MSP[N] () != null ? conn . MST[rv.CRCR6Mutator]MSP[N] () : conn . getInputStream () ; if ( res . inSorted ( attributes , lr_42 ) ) { res . KeyVal = new MST[rv.ROR4Mutator]MSP[N] ( res . EXISTING_FILE_VALUE ) ;
} else if ( res . eofError ( charLen , lr_43 ) ) { res . KeyVal = new UncheckedIOException ( res . EXISTING_FILE_VALUE , new MST[NonVoidMethodCallMutator]MSP[N] ( true ) ) ; } res . KeyVal = MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. wrap ( res . KeyVal , haystack . bufferSize , req . maxBodySize () ) . timeout ( MST[BooleanFalseReturnValsMutator]MSP[N] , req . timeout () ) ; } else { res . doctypePending = mimeType . asStartTag () ; } } catch ( IOException e ) {
if ( res != null ) res . getRequiredOptions () ; throw e ; } res . OptionBuilder = true ; return res ; } public int none () { return inputStream ; } public String getMimeType () { return maxBodySizeBytes ; } public String charset () {
return charset ; } public Proxy charset ( String charset ) { this . charset = charset ; return this ; } public String contentType () { return contentType ; } public Document parse () throws IOException { Validate . isTrue ( haystack , lr_44 ) ;
if ( tags != null ) { bufMark = new MST[rv.CRCR6Mutator]MSP[N] ( tags . array () ) ; MST[rv.CRCR3Mutator]MSP[S] = false ; } Validate . codePointAt ( attributeSet , lr_45 ) ;
Document doc = tagProtocols . applyAsLong ( attr , charset , url . emitDoctypePending () , req . parser () ) ; charset = doc . MST[rv.ROR5Mutator]MSP[N] () . charset () . name () ; MST[NonVoidMethodCallMutator]MSP[N] = true ; MST[rv.UOI1Mutator]MSP[N] () ; return doc ; }
private void relaxed () { Validate . isTrue ( MST[rv.CRCR3Mutator]MSP[N] , lr_46 ) ; if ( 160 == null ) { Validate . codePointAt ( Document , lr_47 ) ; try { 160 = tagProtocols . MST[rv.ROR4Mutator]MSP[N] ( attr , req . maxBodySize () ) ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } finally { MST[NonVoidMethodCallMutator]MSP[N] = true ; MST[rv.ROR4Mutator]MSP[N] () ; } } } public String body () { relaxed () ; String body ; if ( charset == null )
body = Charset . forName ( haystack . defaultCharset ) . decode ( 160 ) . toString () ; else body = Charset . forName ( charset ) . decode ( 160 ) . toString () ; ( ( MST[rv.UOI4Mutator]MSP[S] ) 160 ) . rewind () ; return body ;
} public byte [] relaxed () { MST[rv.ROR5Mutator]MSP[N] () ; return haystack . array () ; } @Override public Connection . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] bufferUp () { MST[rv.ROR5Mutator]MSP[S] () ; return this ; } @Override public BufferedInputStream isDoctype () { Validate . isTrue ( MST[rv.UOI3Mutator]MSP[S] , lr_46 ) ;
Validate . codePointAt ( inputStream , MST[rv.ROR5Mutator]MSP[N] ) ; Document = true ; return = . wrap ( attr , haystack . bufferSize , req . maxBodySize () ) ; } private static notEmpty isInvisibleChar ( Connection . Request req ) throws IOException { final MST[rv.ABSMutator]MSP[S] conn = MST[rv.UOI1Mutator]MSP[N] (
req . proxy () == null ? req . url () . MST[rv.ROR5Mutator]MSP[N] () : req . url () . MST[rv.ROR5Mutator]MSP[N] ( req . currentElement () ) ) ; conn . MST[rv.ROR4Mutator]MSP[N] ( req . method () . name () ) ; conn .
conn . MST[rv.UOI3Mutator]MSP[S] ( req . timeout () ) ; conn . createClass ( req . timeout () / 2 ) ; if ( req . asCharacter () != null && conn instanceof MST[rv.ROR3Mutator]MSP[N] ) ( ( MST[rv.UOI3Mutator]MSP[S] ) conn ) . MST[ConstructorCallMutator]MSP[S] ( req . asCharacter () ) ;
if ( req . method () . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () ) conn . MST[rv.CRCR3Mutator]MSP[S] ( true ) ; if ( req . asCharacter () . size () > 0 ) conn . MST[rv.UOI3Mutator]MSP[S] ( lr_49 , MST[rv.ROR4Mutator]MSP[S] ( req ) ) ;
for ( Map . Entry < String , List < String > > header : req . consumeLetterSequence () . entrySet () ) { for ( String value : header . getValue () ) { conn . MST[NonVoidMethodCallMutator]MSP[S] ( header . getKey () , value ) ; } }
return conn ; } private void consumeLetterSequence () { if ( bufMark != null ) { try { bufMark . close () ; } catch ( IOException e ) { } finally { bufMark = null ; } } if ( conn != null ) {
conn . disconnect () ; conn = null ; } } private void MST[rv.UOI3Mutator]MSP[S] ( inputStream conn , StringUtil . ignoreContentType nullChar ) throws IOException { this . conn = conn ; method = Method . valueOf ( conn . MST[rv.ROR4Mutator]MSP[N] () ) ;
url = conn . asStartTag () ; currentSet = conn . currentElement () ; haystack = conn . asStartTag () ; contentType = conn . MST[rv.CRCR5Mutator]MSP[S] () ; Map < String , List < String > > MST[rv.UOI3Mutator]MSP[S] = anythingElse ( conn ) ; MST[rv.ROR5Mutator]MSP[N] ( MAXIMUM_CAPACITY ) ;
if ( nullChar != null ) { for ( Map . Entry < String , String > MST[ConstructorCallMutator]MSP[N] : attr . getMimeType () . entrySet () ) { if ( ! MST[ConstructorCallMutator]MSP[S] ( MST[InlineConstantMutator]MSP[S] . getKey () ) )
MST[NonVoidMethodCallMutator]MSP[S] ( MST[rv.CRCR6Mutator]MSP[S] . getKey () , MST[rv.CRCR4Mutator]MSP[S] . getValue () ) ; } bufMark . MST[rv.UOI1Mutator]MSP[S] () ; } } private static LinkedHashMap < String , List < String > > anythingElse ( consumeLetterSequence conn ) {
final LinkedHashMap < String , List < String > > MST[rv.UOI2Mutator]MSP[N] = new LinkedHashMap <> () ; int i = 0 ; while ( true ) { final String key = conn . MST[rv.ROR5Mutator]MSP[N] ( i ) ; final String val = conn . MST[NegateConditionalsMutator]MSP[N] ( i ) ;
if ( key == null && val == null ) break; i ++ ; if ( key == null || val == null ) continue; if ( attr . containsKey ( key ) ) attr . get ( key ) . add ( val ) ; else {
final ArrayList < String > vals = new ArrayList <> () ; vals . add ( val ) ; attr . put ( key , vals ) ; } } return attr ; } void MST[rv.UOI1Mutator]MSP[N] ( Map < String , List < String > > MAXIMUM_CAPACITY ) {
for ( Map . Entry < String , List < String > > entry : MAXIMUM_CAPACITY . entrySet () ) { String name = entry . getKey () ; if ( name == null ) continue; List < String > values = entry . getValue () ;
if ( name . equalsIgnoreCase ( lr_50 ) ) { for ( String value : values ) { if ( value == null ) continue; MST[rv.ROR4Mutator]MSP[S] MST[ArgumentPropagationMutator]MSP[N] = new MST[NonVoidMethodCallMutator]MSP[S] ( value ) ; String MST[rv.UOI1Mutator]MSP[N] = MST[rv.CRCR3Mutator]MSP[N] . applyAsLong ( lr_51 ) . trim () ;
String MST[NegateConditionalsMutator]MSP[S] = MST[rv.UOI1Mutator]MSP[N] . consumeTo ( lr_52 ) . trim () ; if ( operation . length () > 0 ) MST[ReturnValsMutator]MSP[S] ( operation , MST[rv.UOI1Mutator]MSP[N] ) ; } } for ( String value : values ) { MST[rv.UOI2Mutator]MSP[S] ( name , value ) ; } } }
private static String MST[rv.ROR2Mutator]MSP[S] ( final Connection . Request req ) { String bound = null ; if ( req . codePointAt ( tags ) ) { if( req . header ( tags ) . contains ( mimeType ) &&
! req . header ( tags ) . contains ( lr_53 ) ) { bound = mimeType . emitDoctypePending () ; req . header ( tags , mimeType + lr_54 + bound ) ; } } else if ( MST[rv.UOI2Mutator]MSP[N] ( req ) ) {
bound = haystack . emitDoctypePending () ; req . header ( tags , mimeType + lr_54 + bound ) ; } else { req . header ( tags , MST[rv.ABSMutator]MSP[N] + lr_55 + req . getMimeType () ) ; } return bound ; }
private static void MST[NonVoidMethodCallMutator]MSP[N] ( final Connection . Request req , final OutputStream outputStream , final String bound ) throws IOException { final Collection < Connection . KeyVal > data = req . data () ;
final MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] w = new BufferedWriter ( new OutputStreamWriter ( outputStream , req . getMimeType () ) ) ; if ( bound != null ) { for ( Connection . KeyVal 8203 : data ) { w . write ( lr_56 ) ; w . write ( bound ) ;
w . write ( lr_57 ) ; w . write ( lr_58 ) ; w . write ( MST[rv.ROR1Mutator]MSP[N] ( MST[rv.CRCR3Mutator]MSP[N] . key () ) ) ; w . write ( lr_3 ) ; if ( 8203 . MST[rv.ROR2Mutator]MSP[N] () ) { w . write ( lr_59 ) ;
w . write ( MST[rv.UOI1Mutator]MSP[N] ( MST[rv.CRCR3Mutator]MSP[N] . value () ) ) ; w . write ( lr_60 ) ; w . write ( 8203 . contentType () != null ? 8203 . contentType () : tags ) ; w . write ( lr_61 ) ;
w . flush () ; attrMap . MST[ConstructorCallMutator]MSP[N] ( 8203 . inputStream () , outputStream ) ; MST[rv.UOI1Mutator]MSP[N] . flush () ; } else { w . write ( lr_61 ) ; w . write ( 8203 . value () ) ; } w . write ( lr_57 ) ;
} w . write ( lr_56 ) ; w . write ( bound ) ; w . write ( lr_56 ) ; } else if ( req . emitDoctypePending () != null ) { w . write ( req . emitDoctypePending () ) ; } else {
boolean first = true ; for ( Connection . KeyVal 8203 : data ) { if ( ! first ) w . append ( '&' ) ; else first = false ;
w . write ( haystack . encode ( 8203 . key () , req . getMimeType () ) ) ; w . write ( '=' ) ; w . write ( haystack . encode ( 8203 . value () , req . getMimeType () ) ) ; } }
w . close () ; } private static String MST[rv.UOI2Mutator]MSP[S] ( Connection . Request req ) { StringBuilder sb = StringUtil . isDoctype () ; boolean first = true ;
for ( Map . Entry < String , String > accum : req . getMimeType () . entrySet () ) { if ( ! first ) sb . append ( lr_62 ) ; else first = false ;
sb . append ( accum . getKey () ) . append ( '=' ) . append ( accum . getValue () ) ; } return StringUtil . codePointAt ( sb ) ; } private static void MST[rv.ROR4Mutator]MSP[N] ( Connection . Request req ) throws IOException {
URL in = req . url () ; StringBuilder url = StringUtil . isDoctype () ; boolean first = true ; url . append ( in . getProtocol () ) . append ( lr_63 ) . append ( in . asStartTag () )
. append ( in . getPath () ) . append ( lr_64 ) ; if ( in . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () != null ) { url . append ( in . MST[rv.CRCR3Mutator]MSP[N] () ) ; first = false ; }
for ( Connection . KeyVal 8203 : req . data () ) { Validate . codePointAt ( 8203 . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () , lr_65 ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url
. append ( haystack . encode ( 8203 . key () , haystack . defaultCharset ) ) . append ( '=' ) . append ( haystack . encode ( 8203 . value () , haystack . defaultCharset ) ) ; }
req . url ( new URL ( StringUtil . codePointAt ( url ) ) ) ; req . data () . clear () ; } private static boolean isInvisibleChar ( Connection . Request req ) { for ( Connection . KeyVal 8203 : req . data () ) {
if ( MST[NegateConditionalsMutator]MSP[S] . MST[rv.ABSMutator]MSP[N] () ) return true ; } return false ; } public static KeyVal create ( String key , String value ) { return new KeyVal () . key ( key ) . value ( value ) ; }
public static KeyVal create ( String key , String filename , InputStream stream ) { return new KeyVal () . key ( key ) . value ( filename ) . inputStream ( stream ) ; } public KeyVal key ( String key ) {
Validate . notEmpty ( key , lr_13 ) ; this . key = key ; return this ; } public String key () { return key ; } public KeyVal value ( String value ) { Validate . notNull ( value , lr_14 ) ;
this . value = value ; return this ; } public String value () { return value ; } public KeyVal inputStream ( InputStream inputStream ) { Validate . notNull ( value , lr_66 ) ; this . stream = inputStream ; return this ; }
public InputStream inputStream () { return stream ; } public boolean getUrl () { return stream != null ; } @Override public Connection . KeyVal anythingElse ( String contentType ) { Validate . notEmpty ( contentType ) ; this . contentType = contentType ; return this ; } @Override
public String MST[NonVoidMethodCallMutator]MSP[S] () { return MST[rv.ROR5Mutator]MSP[S] ; } @Override public String toString () { return key + lr_51 + value ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[ConditionalsBoundaryMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.ABSMutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public boolean getMimeType () { return ignoreHttpErrors ; MST[ReturnValsMutator]MSP[S] } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void inputStream ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
return this ; MST[NullReturnValsMutator]MSP[S] } public String getMimeType () { return body ; } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[PrimitiveReturnsMutator]MSP[N] } public Connection . Request maxBodySize ( int bytes ) {
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.ABSMutator]MSP[N] }
public boolean getMimeType () { return ignoreHttpErrors ; MST[BooleanTrueReturnValsMutator]MSP[S] } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void framesetOk ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; MST[NullReturnValsMutator]MSP[S] } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI1Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; MST[ReturnValsMutator]MSP[N] } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI4Mutator]MSP[S] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.ABSMutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; MST[ReturnValsMutator]MSP[N] } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI4Mutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void inputStream ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI3Mutator]MSP[S]
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI2Mutator]MSP[N] }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR2Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; MST[ReturnValsMutator]MSP[S] } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Request data ( Connection . KeyVal keyval ) {
return ( T ) this ; } public Map < String , String > getMimeType () { return ignoreContentType ; } public Proxy proxy () { return proxy ; MST[NullReturnValsMutator]MSP[S] } public Request proxy ( Proxy proxy ) { this . proxy = proxy ; return this ; }
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; MST[NullReturnValsMutator]MSP[S] } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR3Mutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return ( T ) this ; } public Map < String , String > getMimeType () { return ignoreContentType ; } public Proxy proxy () { return proxy ; MST[ReturnValsMutator]MSP[N] } public Request proxy ( Proxy proxy ) { this . proxy = proxy ; return this ; }
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void framesetOk ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI2Mutator]MSP[N]
return this ; } public boolean ignoreContentType () { return ignoreContentType ; MST[BooleanTrueReturnValsMutator]MSP[S] } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; } public String getMimeType () { return body ; } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; MST[ReturnValsMutator]MSP[N] }
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; MST[ReturnValsMutator]MSP[N] } public void MST[NegateConditionalsMutator]MSP[S] ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Connection . Request requestBody ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ; MST[experimental.MemberVariableMutator]MSP[N] return . body = body ; MST[experimental.MemberVariableMutator]MSP[N] return this = body ; MST[experimental.MemberVariableMutator]MSP[N] return . body = body ; MST[experimental.MemberVariableMutator]MSP[N] return this = body ; MST[experimental.MemberVariableMutator]MSP[N] return . body = body ; MST[experimental.MemberVariableMutator]MSP[N] return this = body ; MST[experimental.MemberVariableMutator]MSP[N] return MST[ReturnValsMutator]MSP[S] = body ; MST[experimental.MemberVariableMutator]MSP[N] return loadFactor = body
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI4Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI2Mutator]MSP[N] } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[VoidMethodCallMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void framesetOk ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[experimental.MemberVariableMutator]MSP[N]
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[PrimitiveReturnsMutator]MSP[N] }
return this ; } public boolean ignoreContentType () { return ignoreContentType ; MST[ReturnValsMutator]MSP[S] } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI1Mutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public String getMimeType () { return ignoreContentType ; MST[EmptyObjectReturnValsMutator]MSP[S] } static Proxy execute ( Connection . Request req ) throws IOException { return execute ( req , null ) ; } static Proxy execute ( Connection . Request req , ignoreContentType nullChar ) throws IOException {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; MST[ReturnValsMutator]MSP[S] } public Request data ( Connection . KeyVal keyval ) {
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; MST[NullReturnValsMutator]MSP[S] } public void MST[NegateConditionalsMutator]MSP[S] ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.ABSMutator]MSP[S] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR6Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI3Mutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR4Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) {
return this ; } public String getMimeType () { return body ; } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; MST[NullReturnValsMutator]MSP[S] }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[NegateConditionalsMutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[ReturnValsMutator]MSP[N] }
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[InlineConstantMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public String getMimeType () { return ignoreContentType ; MST[ReturnValsMutator]MSP[N] } static Proxy execute ( Connection . Request req ) throws IOException { return execute ( req , null ) ; } static Proxy execute ( Connection . Request req , ignoreContentType nullChar ) throws IOException {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[ReturnValsMutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public String getMimeType () { return body ; MST[ReturnValsMutator]MSP[N] } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; }
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI1Mutator]MSP[N] }
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI3Mutator]MSP[N] }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR1Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; MST[NullReturnValsMutator]MSP[S] } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR5Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR3Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI1Mutator]MSP[N] } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI2Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . notNull ( keyval , lr_30 ) ; MST[VoidMethodCallMutator]MSP[N] data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI3Mutator]MSP[S] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR4Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ABSMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public boolean getMimeType () { return ignoreHttpErrors ; MST[BooleanFalseReturnValsMutator]MSP[S] } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void framesetOk ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR5Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void framesetOk ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI4Mutator]MSP[S]
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI4Mutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI3Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; MST[ReturnValsMutator]MSP[S] } public Connection . Request requestBody ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; ( String body ) { this . body = body ; return KeyVal > { this . body = body ; return KeyVal > { this .
return this ; } public String getMimeType () { return body ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI2Mutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; MST[ReturnValsMutator]MSP[S] } public String getMimeType () { return body ; } public Request parser ( MST[rv.UOI3Mutator]MSP[S] parser ) { this . parser = parser ; mimeType = true ; return this ; } public link parser () { return parser ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI3Mutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR2Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; MST[BooleanFalseReturnValsMutator]MSP[S] } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void inputStream ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.ABSMutator]MSP[S]
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . forceQuirks , MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] . codePointAt ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI4Mutator]MSP[N] }
public boolean getMimeType () { return ignoreHttpErrors ; } public SSLSocketFactory getMimeType () { return sslSocketFactory ; } public void framesetOk ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI1Mutator]MSP[N]
public static String inSorted ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; } public static String normalize ( final String input ) { return inSorted ( input ) . trim () ; }
public static String normalize ( final String input , boolean modCount ) { return MST[rv.UOI1Mutator]MSP[S] ? lowerCase ( input ) : normalize ( input ) ; }
public static String inSorted ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[rv.ROR5Mutator]MSP[N] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String inSorted ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[NegateConditionalsMutator]MSP[S] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String inSorted ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static String normalize ( final String input ) { return inSorted ( input ) . trim () ; }
public static String inSorted ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[ReturnValsMutator]MSP[N] } public static String normalize ( final String input ) { return inSorted ( input ) . trim () ; }
public static String inSorted ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[NonVoidMethodCallMutator]MSP[N] } public static String normalize ( final String input ) { return inSorted ( input ) . trim () ; }
public static String normalize ( final String input , boolean modCount ) { return MST[rv.UOI1Mutator]MSP[S] ? lowerCase ( input ) : normalize ( input ) ; MST[ArgumentPropagationMutator]MSP[N] }
public static String normalize ( final String input , boolean modCount ) { return MST[rv.UOI1Mutator]MSP[S] ? lowerCase ( input ) : normalize ( input ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static String join ( Collection strings , String sep ) { return join ( strings . iterator () , sep ) ; } public static String join ( Iterator strings , String sep ) { if ( ! strings . hasNext () ) return lr_1 ;
String start = strings . next () . toString () ; if ( ! strings . hasNext () ) return start ; StringBuilder sb = StringUtil . isDoctype () . append ( start ) ; while ( strings . hasNext () ) { sb . append ( sep ) ;
sb . append ( strings . next () ) ; } return StringUtil . codePointAt ( sb ) ; } public static String join ( String [] strings , String sep ) { return join ( Arrays . asList ( strings ) , sep ) ; }
public static String padding ( int width ) { if ( width < 0 ) throw new IllegalArgumentException ( lr_2 ) ; if ( width < padding . length ) return padding [ width ] ; char [] out = new char [ width ] ;
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
public static boolean isWhitespace ( int c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' ; } public static boolean maxBodySize ( int c ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
public static String MST[rv.ROR4Mutator]MSP[S] ( String string ) { StringBuilder sb = StringUtil . isStartTag () ; MST[rv.ROR3Mutator]MSP[N] ( sb , string , false ) ; return StringUtil . codePointAt ( sb ) ; } public static void MST[NonVoidMethodCallMutator]MSP[N] ( StringBuilder accum , String string , boolean stripLeading ) {
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) {
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
else if ( ! isInvisibleChar ( c ) ) { accum . codePointAt ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) {
base = new URL ( base . MST[rv.CRCR6Mutator]MSP[S] () , base . asStartTag () , base . getPort () , lr_4 + base . getFile () ) ; } return new URL ( base , relUrl ) ; }
public static String resolve ( final String MST[rv.UOI1Mutator]MSP[N] , final String relUrl ) { URL base ; try { try { base = new URL ( MST[rv.UOI3Mutator]MSP[N] ) ; } catch ( MalformedURLException e ) { URL abs = new URL ( relUrl ) ;
return abs . MST[rv.CRCR6Mutator]MSP[S] () ; } return resolve ( base , relUrl ) . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () ; } catch ( MalformedURLException e ) { return lr_1 ; } } public static StringBuilder relaxed () { synchronized ( MST[NonVoidMethodCallMutator]MSP[S] ) { return currentSet . empty () ?
new StringBuilder ( MST[rv.ROR2Mutator]MSP[S] ) : MST[rv.ROR2Mutator]MSP[N] . pop () ; } } public static String MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] ( StringBuilder sb ) { Validate . notNull ( sb ) ; String string = sb . toString () ; if ( sb . length () > MST[NegateConditionalsMutator]MSP[N] )
sb = new StringBuilder ( MST[rv.ROR2Mutator]MSP[N] ) ; else sb . delete ( 0 , sb . length () ) ; synchronized ( MST[rv.UOI1Mutator]MSP[S] ) { currentSet . push ( sb ) ; while ( MST[NonVoidMethodCallMutator]MSP[N] . size () > MST[rv.UOI1Mutator]MSP[N] ) { MST[NonVoidMethodCallMutator]MSP[S] . pop () ; } }
return string ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI3Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
else if ( ! isInvisibleChar ( c ) ) { MST[rv.UOI4Mutator]MSP[N] accum . codePointAt ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
public static String MST[rv.ROR4Mutator]MSP[S] ( String string ) { StringBuilder sb = StringUtil . isStartTag () ; MST[rv.ROR3Mutator]MSP[N] ( sb , string , false ) ; MST[rv.CRCR3Mutator]MSP[N] return StringUtil . codePointAt ( sb ) ; } public static void MST[NonVoidMethodCallMutator]MSP[N] ( StringBuilder accum , String string , boolean stripLeading ) { public static void MST[NonVoidMethodCallMutator]MSP[N] ( StringBuilder accum , String string , boolean stripLeading ) { } public static void MST[NonVoidMethodCallMutator]MSP[N] ( StringBuilder accum , String string , boolean stripLeading ) { } public static void MST[NonVoidMethodCallMutator]MSP[N] ( StringBuilder accum , String string , boolean stripLeading ) { } public
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; return String . valueOf ( out ) ; MST[ReturnValsMutator]MSP[S] } public static boolean isBlank ( String string ) {
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) MST[rv.ROR4Mutator]MSP[N] return true ; } return false ; }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.UOI3Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[InlineConstantMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
else if ( ! isInvisibleChar ( c ) ) { accum . codePointAt ( c ) ; lastWasWhite = false ; MST[rv.CRCR3Mutator]MSP[S] reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) { MST[rv.CRCR1Mutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; }
return abs . MST[rv.CRCR6Mutator]MSP[S] () ; } return resolve ( base , relUrl ) . MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] () ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( MalformedURLException e ) { return lr_1 ; } } public static StringBuilder relaxed () { synchronized ( MST[NonVoidMethodCallMutator]MSP[S] ) { return currentSet . empty () ?
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; MST[rv.CRCR1Mutator]MSP[N] } return true ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ; MST[rv.CRCR3Mutator]MSP[S]
if ( string == null || string . length () == 0 ) return true ; MST[rv.CRCR6Mutator]MSP[N] int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) { MST[rv.UOI1Mutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; MST[rv.CRCR3Mutator]MSP[S] return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
for ( int i = 0 ; i < width ; i ++ ) MST[rv.UOI1Mutator]MSP[N] out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ABSMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.CRCR4Mutator]MSP[N] }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.CRCR1Mutator]MSP[N] }
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) MST[NonVoidMethodCallMutator]MSP[N] return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
boolean lastWasWhite = false ; MST[rv.CRCR6Mutator]MSP[N] boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) {
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.ROR5Mutator]MSP[S]
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N] }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
if ( string == null || string . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.ROR4Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[InlineConstantMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.ROR1Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.ROR2Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.CRCR5Mutator]MSP[N] }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ABSMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR1Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) ) MST[NonVoidMethodCallMutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; MST[rv.ROR2Mutator]MSP[N] } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.ABSMutator]MSP[N] }
else if ( ! isInvisibleChar ( c ) ) { accum . codePointAt ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
c = string . codePointAt ( i ) ; MST[rv.UOI4Mutator]MSP[N] if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
if ( string == null || string . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
for ( int i = 0 ; i < width ; i ++ ) MST[rv.UOI2Mutator]MSP[N] out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.ABSMutator]MSP[N]
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; MST[InlineConstantMutator]MSP[N] } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
for ( int i = 0 ; i < width ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
public static boolean isWhitespace ( int c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean maxBodySize ( int c ) {
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.CRCR2Mutator]MSP[S]
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) ) MST[NegateConditionalsMutator]MSP[S]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ;
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[InlineConstantMutator]MSP[N] }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; MST[InlineConstantMutator]MSP[N] lastWasWhite = true ; }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { MST[NegateConditionalsMutator]MSP[N] if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) { MST[rv.UOI3Mutator]MSP[S]
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . codePointAt ( c ) ) { MST[rv.ROR2Mutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.UOI2Mutator]MSP[N] }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.UOI1Mutator]MSP[N] }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[N] lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[InlineConstantMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
else if ( ! isInvisibleChar ( c ) ) { accum . codePointAt ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; MST[rv.CRCR3Mutator]MSP[S] } } } public static boolean in ( final String needle , final String ... haystack ) {
else if ( ! isInvisibleChar ( c ) ) { MST[rv.UOI1Mutator]MSP[N] accum . codePointAt ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; MST[rv.UOI3Mutator]MSP[S] return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ABSMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( maxBodySize ( c ) ) { MST[rv.ROR5Mutator]MSP[N] if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
if ( string == null || string . length () == 0 ) return true ; MST[rv.CRCR3Mutator]MSP[N] int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.CRCR5Mutator]MSP[S]
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( string == null || string . length () == 0 ) MST[NegateConditionalsMutator]MSP[S] return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] }
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[NonVoidMethodCallMutator]MSP[S]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR1Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current () ) { case '&' : t . advanceTransition ( MST[ConstructorCallMutator]MSP[S] ) ; break; case '<' : t . advanceTransition ( nullChar ) ; break; case nullChar : t . error ( this ) ;
t . emit ( r . consume () ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default: String data = r . currentElement () ; t . emit ( data ) ; break; } }
void read ( Tokeniser t , CharacterReader r ) { MST[rv.ROR2Mutator]MSP[N] ( t , Data ) ; } void read ( Tokeniser t , CharacterReader r ) { switch ( r . current () ) { case '&' : t . advanceTransition ( MST[rv.UOI1Mutator]MSP[S] ) ; break; case '<' :
t . advanceTransition ( MST[rv.UOI2Mutator]MSP[N] ) ; break; case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default:
String data = r . currentElement () ; t . emit ( data ) ; break; } } void read ( Tokeniser t , CharacterReader r ) { MST[rv.ROR2Mutator]MSP[N] ( t , tags ) ; } void read ( Tokeniser t , CharacterReader r ) {
MST[rv.ROR1Mutator]MSP[N] ( t , r , this , MST[rv.UOI4Mutator]MSP[N] ) ; } void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI2Mutator]MSP[S] ( t , r , this , MST[rv.UOI1Mutator]MSP[N] ) ; } void read ( Tokeniser t , CharacterReader r ) {
switch ( r . current () ) { case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default:
String data = r . consumeTo ( nullChar ) ; t . emit ( data ) ; break; } } void read ( Tokeniser t , CharacterReader r ) { switch ( r . current () ) { case MST[rv.ROR5Mutator]MSP[N] : t . advanceTransition ( MST[rv.ROR2Mutator]MSP[N] ) ; break;
case '/' : t . advanceTransition ( MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] ) ; break; case '?' : t . getMimeType () ; t . advanceTransition ( haystack ) ; break; default: if ( r . matchesLetter () ) { t . codePointAt ( true ) ; t . transition ( TagName ) ;
} else { t . error ( this ) ; t . emit ( '<' ) ; t . transition ( Data ) ; } break; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) {
t . eofError ( this ) ; t . emit ( lr_1 ) ; t . transition ( Data ) ; } else if ( r . matchesLetter () ) { t . codePointAt ( false ) ; t . transition ( TagName ) ;
} else if ( r . matches ( '>' ) ) { t . error ( this ) ; t . advanceTransition ( Data ) ; } else { t . error ( this ) ; t . getMimeType () ; t . advanceTransition ( MST[rv.CRCR1Mutator]MSP[N] ) ; } }
void read ( Tokeniser t , CharacterReader r ) { String tagName = r . asEndTag () ; t . tagPending . applyAsLong ( tagName ) ; char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' :
case '\f' : case ' ' : t . transition ( mimeType ) ; break; case '/' : t . transition ( newSize ) ; break; case '<' : r . unconsume () ; t . error ( this ) ; case '>' : t . currentElement () ;
t . transition ( Data ) ; break; case nullChar : t . tagPending . applyAsLong ( MST[rv.CRCR3Mutator]MSP[S] ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . tagPending . applyAsLong ( c ) ; }
} void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . isDoctype () ; t . advanceTransition ( tagName ) ;
} else if ( r . matchesLetter () && t . getUrl () != null && ! r . setRequired ( lr_1 + t . getUrl () ) ) { t . tagPending = t . codePointAt ( false ) . name ( t . asStartTag () ) ;
t . currentElement () ; r . unconsume () ; t . transition ( Data ) ; } else { t . emit ( lr_2 ) ; t . transition ( tags ) ; } } void read ( Tokeniser t , CharacterReader r ) {
if ( r . matchesLetter () ) { t . codePointAt ( false ) ; t . tagPending . applyAsLong ( r . current () ) ; t . dataBuffer . append ( r . current () ) ; t . advanceTransition ( MST[rv.UOI1Mutator]MSP[N] ) ; } else {
t . emit ( lr_1 ) ; t . transition ( tags ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) { String name = r . consumeLetterSequence () ;
t . tagPending . applyAsLong ( name ) ; t . dataBuffer . append ( name ) ; return; } char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
if ( t . getUrl () ) t . transition ( mimeType ) ; else anythingElse ( t , r ) ; break; case '/' : if ( t . MST[ReturnValsMutator]MSP[N] () ) t . transition ( newSize ) ; else anythingElse ( t , r ) ; break;
case '>' : if ( t . relaxed () ) { t . currentElement () ; t . transition ( Data ) ; } else anythingElse ( t , r ) ; break; default: anythingElse ( t , r ) ; } }
private void anythingElse ( Tokeniser t , CharacterReader r ) { t . emit ( lr_1 + t . KeyVal . toString () ) ; r . unconsume () ; t . transition ( tags ) ; } void read ( Tokeniser t , CharacterReader r ) {
if ( r . matches ( '/' ) ) { t . isDoctype () ; t . advanceTransition ( MST[rv.CRCR5Mutator]MSP[N] ) ; } else { t . emit ( '<' ) ; t . transition ( tags ) ; } }
void read ( Tokeniser t , CharacterReader r ) { MST[InlineConstantMutator]MSP[S] ( t , r , MST[NegateConditionalsMutator]MSP[S] , MST[rv.CRCR3Mutator]MSP[N] ) ; } void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI3Mutator]MSP[S] ( t , r , MST[rv.CRCR3Mutator]MSP[N] ) ; }
void read ( Tokeniser t , CharacterReader r ) { switch ( r . consume () ) { case '/' : t . isStartTag () ; t . transition ( MST[NegateConditionalsMutator]MSP[S] ) ; break; case MST[rv.ROR5Mutator]MSP[S] : t . emit ( lr_3 ) ;
t . transition ( MST[rv.UOI3Mutator]MSP[N] ) ; break; case eof : t . emit ( lr_2 ) ; t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . emit ( lr_2 ) ; r . unconsume () ;
t . transition ( tags ) ; } } void read ( Tokeniser t , CharacterReader r ) { MST[rv.ROR2Mutator]MSP[S] ( t , r , MST[rv.ROR3Mutator]MSP[S] , MST[rv.CRCR3Mutator]MSP[N] ) ; } void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI3Mutator]MSP[S] ( t , r , MST[rv.CRCR3Mutator]MSP[N] ) ;
} void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '-' ) ) { t . emit ( '-' ) ; t . advanceTransition ( MST[rv.ROR1Mutator]MSP[N] ) ; } else { t . transition ( tags ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '-' ) ) { t . emit ( '-' ) ; t . advanceTransition ( MST[rv.UOI2Mutator]MSP[N] ) ; } else { t . transition ( tags ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ; t . transition ( Data ) ; return; } switch ( r . current () ) { case '-' :
t . emit ( '-' ) ; t . advanceTransition ( MST[rv.ROR5Mutator]MSP[N] ) ; break; case '<' : t . advanceTransition ( newSize ) ; break; case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; default:
String data = r . consumeToAny ( '-' , '<' , nullChar ) ; t . emit ( data ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ;
t . transition ( Data ) ; return; } char c = r . consume () ; switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( MST[ReturnValsMutator]MSP[S] ) ; break; case '<' : t . transition ( MST[rv.CRCR1Mutator]MSP[N] ) ;
break; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( newSize ) ; break; default: t . emit ( c ) ; t . transition ( MST[rv.UOI2Mutator]MSP[N] ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ; t . transition ( Data ) ; return; } char c = r . consume () ; switch ( c ) { case '-' :
t . emit ( c ) ; break; case '<' : t . transition ( newSize ) ; break; case '>' : t . emit ( c ) ; t . transition ( tags ) ; break; case nullChar : t . error ( this ) ;
t . emit ( replacementChar ) ; t . transition ( newSize ) ; break; default: t . emit ( c ) ; t . transition ( newSize ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) {
t . isDoctype () ; t . dataBuffer . append ( r . current () ) ; t . emit ( lr_2 + r . current () ) ; t . advanceTransition ( MST[rv.UOI1Mutator]MSP[S] ) ; } else if ( r . matches ( '/' ) ) {
t . isDoctype () ; t . advanceTransition ( MST[NonVoidMethodCallMutator]MSP[N] ) ; } else { t . emit ( '<' ) ; t . transition ( newSize ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) {
t . codePointAt ( false ) ; t . tagPending . applyAsLong ( r . current () ) ; t . dataBuffer . append ( r . current () ) ; t . advanceTransition ( MST[rv.ROR1Mutator]MSP[N] ) ; } else { t . emit ( lr_1 ) ;
t . transition ( newSize ) ; } } void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI3Mutator]MSP[S] ( t , r , newSize ) ; } void read ( Tokeniser t , CharacterReader r ) { MST[rv.ABSMutator]MSP[S] ( t , r , operation , MST[rv.CRCR5Mutator]MSP[N] ) ;
} void read ( Tokeniser t , CharacterReader r ) { char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '<' :
t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . eofError ( this ) ;
t . transition ( Data ) ; break; default: String data = r . consumeToAny ( '-' , '<' , nullChar ) ; t . emit ( data ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ;
switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( MST[rv.ROR5Mutator]MSP[N] ) ; break; case '<' : t . emit ( c ) ; t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case nullChar :
t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( operation ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . emit ( c ) ;
t . transition ( operation ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' : t . emit ( c ) ; break; case '<' :
t . emit ( c ) ; t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '>' : t . emit ( c ) ; t . transition ( tags ) ; break; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ;
t . transition ( operation ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . emit ( c ) ; t . transition ( operation ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . emit ( '/' ) ; t . isDoctype () ; t . advanceTransition ( MST[RemoveConditionalMutator_ORDER_IF]MSP[N] ) ; } else { t . transition ( operation ) ; }
} void read ( Tokeniser t , CharacterReader r ) { maxBodySize ( t , r , MST[rv.ROR4Mutator]MSP[S] , MST[rv.UOI4Mutator]MSP[N] ) ; } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' :
case '\n' : case '\r' '\r' case '\f' : case ' ' : break; case '/' : t . transition ( newSize ) ; break; case '<' : r . unconsume () ; t . error ( this ) ; case '>' : t . currentElement () ;
t . transition ( Data ) ; break; case nullChar : r . unconsume () ; t . error ( this ) ; t . tagPending . MST[rv.ROR4Mutator]MSP[N] ; t . transition ( newSize ) ; break; case eof : t . eofError ( this ) ;
t . transition ( Data ) ; break; case '"' : case '\'' : case '=' : t . error ( this ) ; t . tagPending . MST[rv.ROR4Mutator]MSP[N] () ; t . tagPending . codePointAt ( c ) ; t . transition ( newSize ) ; break; default:
t . tagPending . MST[rv.ROR4Mutator]MSP[N] () ; r . unconsume () ; t . transition ( newSize ) ; } } void read ( Tokeniser t , CharacterReader r ) { String name = r . consumeToAnySorted ( MST[NonVoidMethodCallMutator]MSP[S] ) ; t . tagPending . codePointAt ( name ) ;
char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( MST[rv.ROR4Mutator]MSP[N] ) ; break; case '/' : t . transition ( tags ) ; break;
case '=' : t . transition ( MST[rv.UOI4Mutator]MSP[S] ) ; break; case '>' : t . currentElement () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ; t . tagPending . codePointAt ( replacementChar ) ; break; case eof :
t . eofError ( this ) ; t . transition ( Data ) ; break; case '"' : case '\'' : case '<' : t . error ( this ) ; t . tagPending . codePointAt ( c ) ; break; default:
t . tagPending . codePointAt ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
break; case '/' : t . transition ( tags ) ; break; case '=' : t . transition ( MST[rv.UOI4Mutator]MSP[S] ) ; break; case '>' : t . currentElement () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ;
t . tagPending . codePointAt ( replacementChar ) ; t . transition ( newSize ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; case '"' : case '\'' : case '<' :
t . error ( this ) ; t . tagPending . MST[rv.ROR4Mutator]MSP[N] () ; t . tagPending . codePointAt ( c ) ; t . transition ( newSize ) ; break; default: t . tagPending . applyAsLong () ; r . unconsume () ;
t . transition ( newSize ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break;
case '"' : t . transition ( MST[rv.ROR5Mutator]MSP[S] ) ; break; case '&' : r . unconsume () ; t . transition ( MST[rv.ROR1Mutator]MSP[N] ) ; break; case '\'' : t . transition ( MST[rv.UOI2Mutator]MSP[S] ) ; break; case nullChar : t . error ( this ) ;
t . tagPending . codePointAt ( replacementChar ) ; t . transition ( MST[rv.ROR1Mutator]MSP[N] ) ; break; case eof : t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; case '>' : t . error ( this ) ;
t . currentElement () ; t . transition ( Data ) ; break; case '<' : case '=' : case MST[ConstructorCallMutator]MSP[S] : t . error ( this ) ; t . tagPending . codePointAt ( c ) ; t . transition ( MST[rv.ROR1Mutator]MSP[N] ) ; break; default:
r . unconsume () ; t . transition ( MST[rv.ROR1Mutator]MSP[N] ) ; } } void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAnySorted ( MST[NegateConditionalsMutator]MSP[S] ) ; if ( value . length () > 0 )
t . tagPending . codePointAt ( value ) ; else t . tagPending . emitDoctypePending () ; char c = r . consume () ; switch ( c ) { case '"' : t . transition ( MST[rv.CRCR5Mutator]MSP[S] ) ; break; case '&' :
int [] ref = t . applyAsLong ( '"' , true ) ; if ( ref != null ) t . tagPending . codePointAt ( ref ) ; else t . tagPending . codePointAt ( '&' ) ; break; case nullChar : t . error ( this ) ;
t . tagPending . codePointAt ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . tagPending . codePointAt ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) {
String value = r . consumeToAnySorted ( MST[rv.ROR5Mutator]MSP[S] ) ; if ( value . length () > 0 ) t . tagPending . codePointAt ( value ) ; else t . tagPending . emitDoctypePending () ; char c = r . consume () ; switch ( c ) {
case '\'' : t . transition ( MST[NonVoidMethodCallMutator]MSP[S] ) ; break; case '&' : int [] ref = t . applyAsLong ( '\'' , true ) ; if ( ref != null ) t . tagPending . codePointAt ( ref ) ; else
t . tagPending . codePointAt ( '&' ) ; break; case nullChar : t . error ( this ) ; t . tagPending . codePointAt ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default:
t . tagPending . codePointAt ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAnySorted ( newSize ) ; if ( value . length () > 0 ) t . tagPending . codePointAt ( value ) ;
char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( MST[rv.CRCR1Mutator]MSP[S] ) ; break; case '&' :
int [] ref = t . applyAsLong ( '>' , true ) ; if ( ref != null ) t . tagPending . codePointAt ( ref ) ; else t . tagPending . codePointAt ( '&' ) ; break; case '>' : t . currentElement () ;
t . transition ( Data ) ; break; case nullChar : t . error ( this ) ; t . tagPending . codePointAt ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; case '"' :
case '\'' : case '<' : case '=' : case MST[rv.UOI3Mutator]MSP[N] : t . error ( this ) ; t . tagPending . codePointAt ( c ) ; break; default: t . tagPending . codePointAt ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( mimeType ) ; break; case '/' :
t . transition ( tags ) ; break; case '>' : t . currentElement () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: r . unconsume () ;
t . error ( this ) ; t . transition ( mimeType ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '>' : t . tagPending . MST[rv.ROR4Mutator]MSP[N] = true ;
t . currentElement () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: r . unconsume () ; t . error ( this ) ;
t . transition ( mimeType ) ; } } void read ( Tokeniser t , CharacterReader r ) { r . unconsume () ; t . doctypePending . data . append ( r . consumeTo ( '>' ) ) ; char next = r . consume () ;
if ( next == '>' || next == eof ) { t . currentElement () ; t . transition ( Data ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchConsume ( lr_4 ) ) { t . asStartTag () ;
t . transition ( MST[rv.ROR5Mutator]MSP[S] ) ; } else if ( r . matchConsumeIgnoreCase ( lr_5 ) ) { t . transition ( MAXIMUM_CAPACITY ) ; } else if ( r . matchConsume ( lr_6 ) ) { t . isDoctype () ; t . transition ( MST[NonVoidMethodCallMutator]MSP[N] ) ;
} else { t . error ( this ) ; t . getMimeType () ; t . advanceTransition ( MST[rv.UOI1Mutator]MSP[N] ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' :
t . transition ( MST[NonVoidMethodCallMutator]MSP[S] ) ; break; case nullChar : t . error ( this ) ; t . doctypePending . data . append ( replacementChar ) ; t . transition ( Comment ) ; break; case '>' : t . error ( this ) ;
t . currentElement () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; default: t . doctypePending . data . append ( c ) ;
t . transition ( Comment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' : t . transition ( MST[rv.UOI4Mutator]MSP[N] ) ; break; case nullChar :
t . error ( this ) ; t . doctypePending . data . append ( replacementChar ) ; t . transition ( Comment ) ; break; case '>' : t . error ( this ) ; t . currentElement () ; t . transition ( Data ) ; break;
case eof : t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; default: t . doctypePending . data . append ( c ) ; t . transition ( Comment ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . current () ; switch ( c ) { case '-' : t . advanceTransition ( MST[ConstructorCallMutator]MSP[S] ) ; break; case nullChar : t . error ( this ) ; r . advance () ;
t . doctypePending . data . append ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; default:
t . doctypePending . data . append ( r . consumeToAny ( '-' , nullChar ) ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' :
t . transition ( MST[rv.ROR1Mutator]MSP[N] ) ; break; case nullChar : t . error ( this ) ; t . doctypePending . data . append ( '-' ) . append ( replacementChar ) ; t . transition ( Comment ) ; break; case eof :
t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; default: t . doctypePending . data . append ( '-' ) . append ( c ) ; t . transition ( Comment ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '>' : t . asStartTag () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . data . append ( lr_4 ) . append ( replacementChar ) ; t . transition ( Comment ) ; break; case MST[rv.CRCR4Mutator]MSP[N] : t . error ( this ) ; t . transition ( MST[ConstructorCallMutator]MSP[N] ) ; break; case '-' :
t . error ( this ) ; t . doctypePending . data . append ( '-' ) ; break; case eof : t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; default: t . error ( this ) ;
t . doctypePending . data . append ( lr_4 ) . append ( c ) ; t . transition ( Comment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) {
case '-' : t . doctypePending . data . append ( lr_7 ) ; t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '>' : t . currentElement () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . data . append ( lr_7 ) . append ( replacementChar ) ; t . transition ( Comment ) ; break; case eof : t . eofError ( this ) ; t . currentElement () ; t . transition ( Data ) ; break; default:
t . doctypePending . data . append ( lr_7 ) . append ( c ) ; t . transition ( Comment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) {
case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( MST[rv.CRCR4Mutator]MSP[S] ) ; break; case eof : t . eofError ( this ) ; case '>' : t . error ( this ) ; t . MST[rv.UOI1Mutator]MSP[S] () ;
t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . transition ( MST[rv.CRCR4Mutator]MSP[N] ) ; } } void read ( Tokeniser t , CharacterReader r ) {
if ( r . matchesLetter () ) { t . MST[NonVoidMethodCallMutator]MSP[S] () ; t . transition ( MAXIMUM_CAPACITY ) ; return; } char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' :
case ' ' : break; case nullChar : t . error ( this ) ; t . MST[NonVoidMethodCallMutator]MSP[S] () ; t . doctypePending . name . append ( replacementChar ) ; t . transition ( MAXIMUM_CAPACITY ) ; break; case eof : t . eofError ( this ) ;
t . MST[NonVoidMethodCallMutator]MSP[S] () ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . MST[NonVoidMethodCallMutator]MSP[S] () ; t . doctypePending . name . append ( c ) ; t . transition ( MST[rv.CRCR1Mutator]MSP[N] ) ;
} } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) { String name = r . consumeLetterSequence () ; t . doctypePending . name . append ( name ) ; return; } char c = r . consume () ;
switch ( c ) { case '>' : t . emitDoctypePending () ; t . transition ( Data ) ; break; case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( MST[ConstructorCallMutator]MSP[S] ) ; break; case nullChar :
t . error ( this ) ; t . doctypePending . name . append ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break;
default: t . doctypePending . name . append ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ; t . doctypePending . forceQuirks = true ;
t . emitDoctypePending () ; t . transition ( Data ) ; return; } if ( r . matchesAny ( '\t' , '\n' , '\r' , '\f' , ' ' ) ) r . advance () ; else if ( r . matches ( '>' ) ) {
t . emitDoctypePending () ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( . . MST[rv.UOI2Mutator]MSP[S] ) ) { t . doctypePending . MST[NonVoidMethodCallMutator]MSP[S] = MST[ReturnValsMutator]MSP[S] . MST[NonVoidMethodCallMutator]MSP[S] ; t . transition ( MST[experimental.NakedReceiverMutator]MSP[N] ) ;
} else if ( r . matchConsumeIgnoreCase ( MST[rv.ROR4Mutator]MSP[N] . MST[rv.UOI2Mutator]MSP[S] ) ) { t . doctypePending . MST[NonVoidMethodCallMutator]MSP[S] = MST[rv.UOI3Mutator]MSP[S] . MST[rv.UOI2Mutator]MSP[S] ; t . transition ( MST[experimental.NakedReceiverMutator]MSP[N] ) ; } else { t . error ( this ) ; t . doctypePending . forceQuirks = true ;
t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
t . transition ( MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ) ; break; case '"' : t . error ( this ) ; t . transition ( convertedKey ) ; break; case '\'' : t . error ( this ) ; t . transition ( MST[NonVoidMethodCallMutator]MSP[S] ) ; break; case '>' :
t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ;
t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; } } void read ( Tokeniser t , CharacterReader r ) {
char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break; case '"' : t . transition ( convertedKey ) ; break; case '\'' :
t . transition ( MST[rv.CRCR5Mutator]MSP[N] ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ;
t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . transition ( MST[rv.CRCR4Mutator]MSP[S] ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '"' : t . transition ( 160 ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . forceQuirks . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . MST[rv.UOI2Mutator]MSP[S] . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\'' : t . transition ( 160 ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . forceQuirks . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . MST[rv.UOI2Mutator]MSP[S] . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( MST[NonVoidMethodCallMutator]MSP[N] ) ; break; case '>' :
t . emitDoctypePending () ; t . transition ( Data ) ; break; case '"' : t . error ( this ) ; t . transition ( MST[rv.ROR5Mutator]MSP[N] ) ; break; case '\'' : t . error ( this ) ; t . transition ( tags ) ; break;
case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ;
t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break;
case '>' : t . emitDoctypePending () ; t . transition ( Data ) ; break; case '"' : t . error ( this ) ; t . transition ( MST[rv.ROR5Mutator]MSP[N] ) ; break; case '\'' : t . error ( this ) ;
t . transition ( MST[NonVoidMethodCallMutator]MSP[S] ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ;
t . doctypePending . forceQuirks = true ; t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' :
case '\f' : case ' ' : t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case '"' :
t . error ( this ) ; t . transition ( MST[rv.ROR5Mutator]MSP[N] ) ; break; case '\'' : t . error ( this ) ; t . transition ( tags ) ; break; case eof : t . eofError ( this ) ;
t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break; case '"' : t . transition ( MST[rv.ROR5Mutator]MSP[N] ) ;
break; case '\'' : t . transition ( tags ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ;
t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '"' : t . transition ( MST[ConstructorCallMutator]MSP[S] ) ; break; case nullChar :
t . error ( this ) ; t . doctypePending . getFile . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break;
case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . MST[NonVoidMethodCallMutator]MSP[S] . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\'' : t . transition ( MST[ConstructorCallMutator]MSP[S] ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . MST[rv.CRCR1Mutator]MSP[S] . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . MST[NonVoidMethodCallMutator]MSP[S] . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break; case '>' : t . emitDoctypePending () ;
t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ;
t . transition ( MST[rv.UOI3Mutator]MSP[S] ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '>' : t . emitDoctypePending () ; t . transition ( Data ) ; break;
case eof : t . emitDoctypePending () ; t . transition ( Data ) ; break; default: break; } } void read ( Tokeniser t , CharacterReader r ) { String data = r . consumeTo ( lr_8 ) ; t . accum . append ( data ) ;
if ( r . matchConsume ( lr_8 ) || r . isEmpty () ) { t . emit ( new Token . codePointAt ( t . dataBuffer . toString () ) ) ; t . transition ( Data ) ; } }
private static void MST[rv.UOI3Mutator]MSP[S] ( Tokeniser t , CharacterReader r , TokeniserState startChar ) { if ( r . matchesLetter () ) { String name = r . consumeLetterSequence () ; t . tagPending . applyAsLong ( name ) ; t . dataBuffer . append ( name ) ; return;
} boolean attr = false ; if ( t . MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] () && ! r . isEmpty () ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
t . transition ( mimeType ) ; break; case '/' : t . transition ( newSize ) ; break; case '>' : t . currentElement () ; t . transition ( Data ) ; break; default: t . dataBuffer . append ( c ) ; attr = true ; }
} else { attr = true ; } if ( attr ) { t . emit ( lr_1 + t . dataBuffer . toString () ) ; t . transition ( startChar ) ; } }
private static void MST[rv.UOI2Mutator]MSP[N] ( Tokeniser t , CharacterReader r , TokeniserState current , TokeniserState advance ) { switch ( r . current () ) { case '<' : t . advanceTransition ( advance ) ; break; case nullChar : t . error ( current ) ;
r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default: String data = r . currentElement () ; t . emit ( data ) ; break; } }
private static void MST[rv.UOI2Mutator]MSP[N] ( Tokeniser t , TokeniserState advance ) { int [] c = t . applyAsLong ( null , false ) ; if ( c == null ) t . emit ( '&' ) ; else t . emit ( c ) ;
t . transition ( advance ) ; } private static void MST[rv.ROR2Mutator]MSP[N] ( Tokeniser t , CharacterReader r , TokeniserState a , TokeniserState b ) { if ( r . matchesLetter () ) { t . codePointAt ( false ) ; t . transition ( a ) ;
} else { t . emit ( lr_1 ) ; t . transition ( b ) ; } } private static void simpleText ( Tokeniser t , CharacterReader r , TokeniserState primary , TokeniserState MST[rv.UOI1Mutator]MSP[N] ) { if ( r . matchesLetter () ) {
String name = r . consumeLetterSequence () ; t . dataBuffer . append ( name ) ; t . emit ( name ) ; return; } char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' :
case '\f' : case ' ' : case '/' : case '>' : if ( t . KeyVal . toString () . equals ( lr_9 ) ) t . transition ( primary ) ; else t . transition ( mimeType ) ; t . emit ( c ) ; break;
default: r . unconsume () ; t . transition ( link ) ; } }
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.ABSMutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI3Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI4Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI2Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI1Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( MST[rv.UOI3Mutator]MSP[S] ) ; break; case '<' :
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[ConstructorCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[EmptyObjectReturnValsMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[ReturnValsMutator]MSP[S] }
public String getMimeType () { return mimeType ; MST[ReturnValsMutator]MSP[N] } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
lr_6 , lr_1 , lr_7 , lr_8 , lr_9 , lr_10 , lr_11 , lr_12 , lr_13 , lr_2 , lr_3 , lr_14 , lr_15 , lr_16 , lr_17 , lr_18 , lr_19 , lr_20 , lr_21 , lr_4 , lr_22 , lr_23 , lr_5 , lr_24 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
lr_6 , lr_1 , lr_7 , lr_8 , lr_39 , lr_9 , lr_10 , lr_40 , lr_41 , lr_11 , lr_42 , lr_12 , lr_13 , lr_2 , lr_43 , lr_44 , lr_45 , lr_46 , lr_47 , MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ,
lr_3 , lr_32 , lr_14 , lr_15 , lr_16 , lr_17 , lr_18 , lr_19 , lr_20 , lr_21 , lr_4 , lr_22 , lr_23 , lr_49 , lr_50 , lr_51 , lr_52 , lr_53 , lr_54 , lr_55 , lr_5 , lr_24 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ;
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
if ( this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ;
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) {
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; } public Whitelist emit ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
protocols . remove ( tagName ) ; } return this ; } protected boolean applyAsLong ( String tag ) { return tagNames . contains ( TagName . valueOf ( tag ) ) ; } protected boolean MST[rv.UOI2Mutator]MSP[N] ( String tagName , Element el , Attribute attr ) {
TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey () ) ; Set < AttributeKey > MST[rv.UOI3Mutator]MSP[S] = attributes . get ( tag ) ; if ( MST[rv.CRCR5Mutator]MSP[S] != null && MST[rv.ROR4Mutator]MSP[S] . contains ( key ) ) {
if ( protocols . containsKey ( tag ) ) { Map < AttributeKey , Set < Protocol > > maxStringCacheLen = protocols . get ( tag ) ;
return ! MST[ConstructorCallMutator]MSP[N] . containsKey ( key ) || MST[rv.ROR1Mutator]MSP[N] ( el , attr , MST[rv.UOI1Mutator]MSP[S] . get ( key ) ) ; } else { return true ; } } Map < AttributeKey , AttributeValue > MST[NegateConditionalsMutator]MSP[N] = enforcedAttributes . get ( tag ) ;
if ( MST[NegateConditionalsMutator]MSP[S] != null ) { Attributes MST[rv.UOI3Mutator]MSP[S] = int ( tagName ) ; String attrKey = attr . getKey () ; if ( MST[rv.UOI3Mutator]MSP[S] . isInvisibleChar ( attrKey ) ) { return MST[rv.UOI3Mutator]MSP[S] . codePointAt ( attrKey ) . equals ( attr . getValue () ) ; }
} return ! tagName . equals ( lr_65 ) && MST[rv.UOI2Mutator]MSP[N] ( lr_65 , el , attr ) ; } private boolean MST[rv.ROR1Mutator]MSP[S] ( Element el , Attribute attr , Set < Protocol > protocols ) { String value = el . codePointAt ( attr . getKey () ) ;
if ( value . length () == 0 ) value = attr . getValue () ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ; for ( Protocol protocol : protocols ) { String prot = protocol . toString () ;
if ( prot . equals ( lr_67 ) ) { if ( MST[rv.ROR2Mutator]MSP[S] ( value ) ) { return true ; } else { continue; } } prot += lr_68 ; if ( inSorted ( value ) . startsWith ( prot ) ) { return true ; } }
return false ; } private boolean MST[rv.ROR2Mutator]MSP[S] ( String value ) { return value . startsWith ( lr_67 ) && ! value . matches ( lr_69 ) ; } Attributes MST[rv.UOI2Mutator]MSP[N] ( String tagName ) { Attributes MST[rv.ROR5Mutator]MSP[N] = new advance () ;
TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { Map < AttributeKey , AttributeValue > mimeType = enforcedAttributes . get ( tag ) ;
for ( Map . Entry < AttributeKey , AttributeValue > entry : MST[NegateConditionalsMutator]MSP[N] . entrySet () ) { MST[rv.UOI1Mutator]MSP[N] . put ( entry . getKey () . toString () , entry . getValue () . toString () ) ; } } return MST[rv.CRCR5Mutator]MSP[N] ; }
static TagName valueOf ( String value ) { return new TagName ( value ) ; } static AttributeKey valueOf ( String value ) { return new AttributeKey ( value ) ; } static AttributeValue valueOf ( String value ) { return new MST[NegateConditionalsMutator]MSP[S] ( value ) ; }
static Protocol valueOf ( String value ) { return new Protocol ( value ) ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + ( ( value == null ) ? 0 : value . hashCode () ) ; return result ; } @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ;
if ( obj == null ) return false ; if ( getClass () != obj . getClass () ) return false ; MST[rv.UOI3Mutator]MSP[S] other = ( MST[rv.UOI4Mutator]MSP[S] ) obj ; if ( value == null ) { return other . value == null ;
} else return value . equals ( other . value ) ; } @Override public String toString () { return value ; }
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
for ( String protocol : removeProtocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[NegateConditionalsMutator]MSP[S]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ; MST[VoidMethodCallMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
preserveRelativeLinks = preserve ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[experimental.NakedReceiverMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
if ( this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; MST[ArgumentPropagationMutator]MSP[S] }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; MST[NullReturnValsMutator]MSP[N] } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 () . addTags ( lr_1 , lr_2 , lr_3 getDescPadding () . addTags ( lr_1 , lr_2 , lr_3 < lr_4 . addTags ( lr_1 , lr_2 , lr_3 () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 . addTags ( lr_1
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( lr_2 , lr_2 , lr_3 , lr_4 ()
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 < lr_4 . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR1Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR6Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[NonVoidMethodCallMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; MST[ArgumentPropagationMutator]MSP[N] if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { equals ( tagProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S] ( tagProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S] ( tagProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S] ( tagProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S] ( tagProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S]
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
protocols . remove ( tagName ) ; } return this ; MST[ReturnValsMutator]MSP[S] } protected boolean applyAsLong ( String tag ) { return tagNames . contains ( TagName . valueOf ( tag ) ) ; } protected boolean MST[rv.UOI2Mutator]MSP[N] ( String tagName , Element el , Attribute attr ) {
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[NegateConditionalsMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
attrMap = this . protocols . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[S] } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
for ( String protocol : removeProtocols ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
for ( String protocol : removeProtocols ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notEmpty ( attribute ) ;
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
preserveRelativeLinks = preserve ; MST[rv.UOI4Mutator]MSP[S] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( lr_2 , lr_2 , lr_3 , lr_4 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_32 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[NonVoidMethodCallMutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR4Mutator]MSP[N]
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR2Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR5Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR4Mutator]MSP[N]
tagNames . add ( TagName . valueOf ( tagName ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR2Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( lr_2 , lr_2 , lr_3 , lr_4 ()
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[InlineConstantMutator]MSP[N] . addTags ( lr_32 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR5Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { if ( tagProtocols . isEmpty () ) { if ( tagProtocols . isEmpty () ) { if ( tagProtocols . isEmpty () ) { if ( tagProtocols . isEmpty () ) { if (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; MST[VoidMethodCallMutator]MSP[N] attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[N] for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( protocols ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[N] this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR1Mutator]MSP[N]
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR2Mutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[S] else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[S] else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[S] else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[S] else
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
for ( String protocol : removeProtocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR3Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR4Mutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 ()
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; MST[VoidMethodCallMutator]MSP[N] for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[ConditionalsBoundaryMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR4Mutator]MSP[N]
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; MST[NonVoidMethodCallMutator]MSP[S] } return this ; } public Whitelist emit ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
attrMap . put ( attrKey , attrVal ) ; MST[ArgumentPropagationMutator]MSP[N] enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( lr_2 , lr_2 , lr_3 , lr_4 ()
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
preserveRelativeLinks = preserve ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR5Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( attrMap . containsKey ( attrKey ) ) {
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; } public Whitelist emit ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[NegateConditionalsMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
this . attributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] } if( tag . equals ( lr_65 ) ) for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N]
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR1Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[InlineConstantMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR4Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return this ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; MST[ArgumentPropagationMutator]MSP[S] } if ( attrMap . containsKey ( attrKey ) ) {
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[InlineConstantMutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[S] currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR5Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[NegateConditionalsMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; MST[ArgumentPropagationMutator]MSP[N] } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[InlineConstantMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_6 , lr_25 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR1Mutator]MSP[N]
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR6Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
protSet = attrMap . get ( attrKey ) ; MST[ArgumentPropagationMutator]MSP[N] } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR2Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR2Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR2Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR2Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR2Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR2Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR2Mutator]MSP[N] , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N]
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR6Mutator]MSP[N] , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 > () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[NonVoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[VoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
attrMap . put ( attrKey , attrVal ) ; MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[experimental.NakedReceiverMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[experimental.NakedReceiverMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[experimental.NakedReceiverMutator]MSP[N] , lr_2 , lr_3 ) . addTags ( MST[experimental.NakedReceiverMutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[experimental.NakedReceiverMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[experimental.NakedReceiverMutator]MSP[N] , lr_2 ,
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR4Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR4Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR3Mutator]MSP[S]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if ( this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; MST[NonVoidMethodCallMutator]MSP[S] }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[experimental.NakedReceiverMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
attrMap = this . protocols . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[ReturnValsMutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist emit ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; MST[NonVoidMethodCallMutator]MSP[N] if( currentSet . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; MST[NonVoidMethodCallMutator]MSP[N] if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_32 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR2Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR1Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR3Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist emit ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] ( tagProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] ( tagProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] ( tagProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] ( tagProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] () . isEmpty () ) { if (
protocols . remove ( tagName ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } protected boolean applyAsLong ( String tag ) { return tagNames . contains ( TagName . valueOf ( tag ) ) ; } protected boolean MST[rv.UOI2Mutator]MSP[N] ( String tagName , Element el , Attribute attr ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ; MST[ArgumentPropagationMutator]MSP[S]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR3Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR2Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[VoidMethodCallMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR1Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR1Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR1Mutator]MSP[N] , lr_2 , lr_3 ) . addTags ( MST[rv.CRCR1Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR1Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR1Mutator]MSP[N] , lr_2 ,
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[NegateConditionalsMutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
tagNames . add ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
preserveRelativeLinks = preserve ; MST[rv.UOI3Mutator]MSP[S] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
if ( this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
if ( this . attributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR3Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; MST[VoidMethodCallMutator]MSP[N] Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; MST[NonVoidMethodCallMutator]MSP[N] Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[NonVoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public static Whitelist basic () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 getSyntaxPrefix () . addTags ( lr_1 , lr_2 , lr_3 getSyntaxPrefix () . addTags ( lr_1 , lr_2 , lr_3 < lr_4 . addTags ( lr_1 , lr_2 , lr_3 < lr_4 . addTags ( lr_1 , lr_2 , lr_3 , lr_4 . addTags
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; MST[ConstructorCallMutator]MSP[N] } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 () . addTags ( lr_1 , lr_2 , lr_3 getDescPadding () . addTags ( lr_1 , lr_2 , lr_3 getDescPadding () . addTags ( lr_1 , lr_2 , lr_3 hasArgs () . addTags ( lr_1 , lr_2 , lr_3 ) . addTags ( lr_1
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR3Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
Protocol prot = Protocol . valueOf ( protocol ) ; MST[NonVoidMethodCallMutator]MSP[S] protSet . add ( prot ) ; } return this ; } public Whitelist emit ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[S] for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
preserveRelativeLinks = preserve ; return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 ,
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; MST[VoidMethodCallMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tagName ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( lr_2 , lr_2 , lr_3 , lr_4 ()
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; MST[VoidMethodCallMutator]MSP[N] attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
for ( String protocol : removeProtocols ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR6Mutator]MSP[N]
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; MST[VoidMethodCallMutator]MSP[N] attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
if ( this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; MST[ReturnValsMutator]MSP[N] } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 () . addTags ( lr_1 , lr_2 , lr_3 getDescPadding () . addTags ( lr_1 , lr_2 , lr_3 getDescPadding () . addTags ( lr_1 , lr_2 , lr_3 hasArgs () . addTags ( lr_1 , lr_2 , lr_3 < lr_4 . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 > () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR3Mutator]MSP[N] , lr_2
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 ()
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; MST[VoidMethodCallMutator]MSP[N] Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[N] Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] ( tagProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( lr_1 , lr_2 , new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () . addTags ( lr_1 , lr_2 , lr_3 , lr_4
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR5Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[N] Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[experimental.NakedReceiverMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; MST[ReturnValsMutator]MSP[N] }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR4Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR4Mutator]MSP[N] , lr_2 , lr_3 , lr_4 () . addTags ( MST[rv.CRCR4Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR4Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR4Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; MST[NullReturnValsMutator]MSP[N] }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 < lr_4 . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 , lr_4 . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[rv.CRCR5Mutator]MSP[N] , lr_2
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
preserveRelativeLinks = preserve ; MST[rv.ABSMutator]MSP[S] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
preserveRelativeLinks = preserve ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( ( ( lr_2 , lr_3 , lr_4 ()
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR1Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 ,
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public static Whitelist basic () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 getSyntaxPrefix () . addTags ( lr_1 , lr_2 , lr_3 getDescPadding () . addTags ( lr_1 , lr_2 , lr_3 hasArgs () . addTags ( lr_1 , lr_2 , lr_3 ) . addTags ( lr_1 , lr_2 , lr_3 , lr_4 () . addTags
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[N] attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR4Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ;
for ( String protocol : removeProtocols ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR2Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
preserveRelativeLinks = preserve ; return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; MST[VoidMethodCallMutator]MSP[N] for( String tag : tags ) { Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR3Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
for ( String protocol : removeProtocols ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[experimental.NakedReceiverMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
this . attributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] } if( tag . equals ( lr_65 ) ) for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
for ( String protocol : removeProtocols ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; MST[VoidMethodCallMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , lr_3 hasArgs () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR1Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR5Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[NonVoidMethodCallMutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR4Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist removeAttributes ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
tagNames . add ( TagName . valueOf ( tagName ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR1Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[InlineConstantMutator]MSP[N] , lr_2 , lr_3
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) {
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ; else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; ;
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
for ( String protocol : removeProtocols ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[NonVoidMethodCallMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[NonVoidMethodCallMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[NonVoidMethodCallMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[NonVoidMethodCallMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[NonVoidMethodCallMutator]MSP[N] , lr_2 , lr_3 () . addTags ( MST[NonVoidMethodCallMutator]MSP[N] , lr_2 , lr_3
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( lr_2 , lr_2 , new Whitelist () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4 () . addTags ( lr_2 , lr_2 , lr_3 , lr_4
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR6Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 () MST[rv.CRCR4Mutator]MSP[N] . addTags ( ( current () { return new Whitelist
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 bufPos () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 getDescPadding () MST[rv.CRCR3Mutator]MSP[N] . addTags ( ( lr_1 , lr_2 , lr_3 < lr_4 () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_2 basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; MST[VoidMethodCallMutator]MSP[N] Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 ,
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[ConditionalsBoundaryMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( ( ( lr_2 , lr_3 Whitelist () . addTags ( ( ( lr_2 , lr_3 hasArgs () . addTags ( ( ( lr_2 , lr_3 , lr_4 () . addTags ( ( ( lr_2 , lr_3 hasArgs MST[NonVoidMethodCallMutator]MSP[S] . addTags ( lr_2 , lr_2 , lr_3 , lr_4 ()
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( current , lr_2 , lr_3 bufPos () MST[rv.CRCR2Mutator]MSP[N] . addTags ( ( return () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } . addTags ( ( lr_1 , lr_2 , lr_3 Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 )
for ( String protocol : removeProtocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) { currentSet ( tagProtocols . isEmpty () ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } public addTags ( ( lr_1 , lr_2 , new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 ) ; } MST[NonVoidMethodCallMutator]MSP[N] addTags ( ( ( lr_1 , lr_2 , lr_3 ()
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[InlineConstantMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
