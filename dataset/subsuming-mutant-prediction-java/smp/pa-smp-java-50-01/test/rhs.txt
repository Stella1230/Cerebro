public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[S] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[S] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ; MST[NonVoidMethodCallMutator]MSP[N]
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
public Collection < String > getMatchingOptions () { return matchingOptions ; MST[ReturnValsMutator]MSP[N] } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ;
public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ; MST[experimental.NakedReceiverMutator]MSP[N]
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( it . next () ) ;
public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] buf . append ( option ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
public Collection < String > getMatchingOptions () { return matchingOptions ; MST[EmptyObjectReturnValsMutator]MSP[S] } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ;
buf . append ( lr_3 ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( it . next () ) ;
public Collection < String > getMatchingOptions () { return matchingOptions ; } private static String createMessage ( final String option , final Collection < String > matchingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
buf . append ( lr_3 ) ; if ( it . hasNext () ) { buf . append ( lr_4 ) ; } } buf . append ( lr_5 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_3 ) ; buf . append ( it . next () ) ;
buf . append ( lr_2 ) ; final Iterator < String > it = matchingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( lr_3 ) ; buf . append ( it . next () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
@Override protected String [] flatten ( @SuppressWarnings ( lr_1 ) final Options options , final String [] arguments , @SuppressWarnings ( lr_1 ) final boolean stopAtNonOption ) { return arguments ; }
@Override protected String [] flatten ( @SuppressWarnings ( lr_1 ) final Options options , final String [] arguments , @SuppressWarnings ( lr_1 ) final boolean stopAtNonOption ) { return arguments ; MST[ReturnValsMutator]MSP[N] }
@Override protected String [] flatten ( @SuppressWarnings ( lr_1 ) final Options options , final String [] arguments , @SuppressWarnings ( lr_1 ) final boolean stopAtNonOption ) { return arguments ; MST[NullReturnValsMutator]MSP[S] }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
public Iterator < Option > iterator () { return options . iterator () ; } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public CommandLine build () { return commandLine ; }
else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[N] {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { final List < String > values = option . getValuesList () ;
if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[S] } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[ArgumentPropagationMutator]MSP[N]
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { final List < String > values = option . getValuesList () ;
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[N] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] }
return answer ; MST[NullReturnValsMutator]MSP[N] } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] {
return getOptionValue ( String . valueOf ( opt ) ) ; } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N] for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[ReturnValsMutator]MSP[N] } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI1Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[ArgumentPropagationMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[N] {
else if ( values . size () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[N] for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } else if ( values . size () == 1 ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; MST[ReturnValsMutator]MSP[S] } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final Option option : options ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[S] } public String getOptionValue ( final char opt , final String defaultValue ) {
else if ( values . size () == 1 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[NullReturnValsMutator]MSP[N] } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; MST[ReturnValsMutator]MSP[S] } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] }
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR5Mutator]MSP[N] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; MST[NegateConditionalsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[N] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[ReturnValsMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[rv.ROR5Mutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; MST[ReturnValsMutator]MSP[N] } public String [] getOptionValues ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public Object getOptionObject ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public Object getOptionObject ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( opt . equals ( option . getOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return hasOption ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NullReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } else if ( values . size () == 1 ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return processed . toArray ( optionsArray ) ; MST[ArgumentPropagationMutator]MSP[S] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[ReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[S] } } return null ; } public String [] getOptionValues ( final char opt ) {
return answer ; } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
return answer ; } public List < String > getArgList () { return args ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt ) {
else if ( values . size () == 1 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR4Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { final List < String > values = option . getValuesList () ;
public Iterator < Option > iterator () { return options . iterator () ; } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ; MST[NonVoidMethodCallMutator]MSP[N]
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; }
if ( processedOption . equals ( option ) ) MST[rv.ROR4Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( processedOption . equals ( option ) ) MST[rv.ROR2Mutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
else if ( values . size () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return answer ; MST[ReturnValsMutator]MSP[N] } public List < String > getArgList () { return args ; } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ; MST[ConstructorCallMutator]MSP[N]
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI4Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI2Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ArgumentPropagationMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NullReturnValsMutator]MSP[N] } catch ( final ParseException pe ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[N] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NonVoidMethodCallMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[NullReturnValsMutator]MSP[N] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[ConstructorCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[S] { final List < String > values = option . getValuesList () ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[ArgumentPropagationMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
if ( values . size () >= 2 ) MST[ConditionalsBoundaryMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return ( values == null ) ? null : values [ 0 ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public Object getOptionObject ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[VoidMethodCallMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[S] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[experimental.NakedReceiverMutator]MSP[N] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( values . size () == 1 ) {
return answer ; } public List < String > getArgList () { return args ; MST[ReturnValsMutator]MSP[N] } protected void addArg ( final String arg ) { args . add ( arg ) ; } protected void addOption ( final Option opt ) { options . add ( opt ) ; }
return hasOption ( String . valueOf ( opt ) ) ; } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final ParseException pe ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; } public Object getOptionObject ( final char opt ) {
public Iterator < Option > iterator () { return options . iterator () ; MST[NullReturnValsMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; }
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt , final String defaultValue ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NonVoidMethodCallMutator]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; MST[ReturnValsMutator]MSP[N] } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[ArgumentPropagationMutator]MSP[S] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.ABSMutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR5Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Object getOptionObject ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] return ( answer != null ) ? answer : defaultValue ; }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR1Mutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR2Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR1Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NullReturnValsMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
if ( values . size () >= 2 ) MST[rv.CRCR5Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NonVoidMethodCallMutator]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
props . put ( values . get ( 0 ) , lr_3 ) ; MST[ArgumentPropagationMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( processedOption . equals ( option ) ) MST[NonVoidMethodCallMutator]MSP[N] { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] }
public Iterator < Option > iterator () { return options . iterator () ; MST[ReturnValsMutator]MSP[S] } public Option [] getOptions () { final Collection < Option > processed = options ; final Option [] optionsArray = new Option [ processed . size () ] ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[InlineConstantMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; MST[NonVoidMethodCallMutator]MSP[N] args . toArray ( answer ) ;
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
public boolean hasOption ( final Option opt ) MST[ConstructorCallMutator]MSP[N] { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR3Mutator]MSP[N] {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[InlineConstantMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return hasOption ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR1Mutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[rv.ROR1Mutator]MSP[S] {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt . equals ( option . getOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[NegateConditionalsMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } final String [] values = getOptionValues ( option ) ;
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return ( values == null ) ? null : values [ 0 ] ; } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getOptionValue ( final char opt ) {
if ( opt . equals ( option . getOpt () ) ) MST[NonVoidMethodCallMutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[N] if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[S] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
final String res = getOptionValue ( option ) ; if ( res == null ) { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Object getParsedOptionValue ( final String opt ) throws ParseException {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR1Mutator]MSP[N] { final List < String > values = option . getValuesList () ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR2Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR3Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) MST[rv.ROR5Mutator]MSP[N] { return option ; } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return getParsedOptionValue ( resolveOption ( opt ) ) ; } public Object getParsedOptionValue ( final char opt ) throws ParseException { return getParsedOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[S] } public Object getOptionObject ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.ROR4Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) { final List < String > values = option . getValuesList () ; MST[NonVoidMethodCallMutator]MSP[N]
return hasOption ( String . valueOf ( opt ) ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Deprecated public Object getOptionObject ( final String opt ) { try { return getParsedOptionValue ( opt ) ; } catch ( final ParseException pe ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return processed . toArray ( optionsArray ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( final char opt ) {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( final Option option : options ) {
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR3Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
return getOptionValues ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { props . put ( values . get ( 0 ) , lr_3 ) ; } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return getOptionValues ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
final String res = getOptionValue ( option ) ; if ( res == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } return TypeHandler . createValue ( res , option . getType () ) ; } public Object getParsedOptionValue ( final String opt ) throws ParseException {
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[N] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
return getOptionValue ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR3Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR6Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] }
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] }
return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; MST[rv.UOI3Mutator]MSP[N] } public Properties getOptionProperties ( final Option option ) { final Properties props = new Properties () ; for ( final Option processedOption : options ) { if ( processedOption . equals ( option ) ) {
System . err . println ( lr_1 + opt + lr_2 + pe . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[S] return null ; } } public Object getParsedOptionValue ( final Option option ) throws ParseException { if ( option == null ) { return null ; }
return ( values == null ) ? null : values [ 0 ] ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
public String getOptionValue ( final String opt , final String defaultValue ) { return getOptionValue ( resolveOption ( opt ) , defaultValue ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getOptionValue ( final char opt , final String defaultValue ) {
props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[N] } } } return props ; } public String [] getArgs () { final String [] answer = new String [ args . size () ] ; args . toArray ( answer ) ;
if ( processedOption . equals ( option ) ) { values . addAll ( processedOption . getValuesList () ) ; } } return values . isEmpty () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public String [] getOptionValues ( final String opt ) { return getOptionValues ( resolveOption ( opt ) ) ; } private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[S] for ( final Option option : options ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > values = processedOption . getValuesList () ; if ( values . size () >= 2 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; }
if ( opt . equals ( option . getOpt () ) ) { return option ; MST[ReturnValsMutator]MSP[N] } if ( opt . equals ( option . getLongOpt () ) ) { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) MST[rv.CRCR4Mutator]MSP[N] {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.ROR5Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
return getOptionObject ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; MST[ReturnValsMutator]MSP[S] } final String [] values = getOptionValues ( option ) ;
return getOptionObject ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[S] } public String getOptionValue ( final Option option ) { if ( option == null ) { return null ; } final String [] values = getOptionValues ( option ) ;
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[S] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
if ( values . size () >= 2 ) MST[rv.CRCR3Mutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
return ( values == null ) ? null : values [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } public String getOptionValue ( final String opt ) { return getOptionValue ( resolveOption ( opt ) ) ; } public String getOptionValue ( final char opt ) {
public boolean hasOption ( final Option opt ) { return options . contains ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasOption ( final String opt ) { return hasOption ( resolveOption ( opt ) ) ; } public boolean hasOption ( final char opt ) {
return getOptionValue ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public String [] getOptionValues ( final Option option ) { final List < String > values = new ArrayList < String > () ; for ( final Option processedOption : options ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[ReturnValsMutator]MSP[N] }
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else if ( values . size () == 1 ) {
if ( values . size () >= 2 ) { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else if ( values . size () == 1 ) {
else if ( values . size () == 1 ) { props . put ( values . get ( 0 ) , lr_3 ) ; MST[rv.CRCR6Mutator]MSP[S] } } } return props ; } public Properties getOptionProperties ( final String opt ) { final Properties props = new Properties () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[rv.ROR4Mutator]MSP[S] { final List < String > values = option . getValuesList () ;
if ( values . size () >= 2 ) MST[InlineConstantMutator]MSP[N] { props . put ( values . get ( 0 ) , values . get ( 1 ) ) ; } else if ( values . size () == 1 ) {
if ( opt . equals ( option . getOpt () ) ) { return option ; } if ( opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { return option ; } } return null ; } public String [] getOptionValues ( final char opt ) {
return getOptionValues ( String . valueOf ( opt ) ) ; } public String getOptionValue ( final Option option , final String defaultValue ) { final String answer = getOptionValue ( option ) ; return ( answer != null ) ? answer : defaultValue ; MST[NegateConditionalsMutator]MSP[N] }
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { final List < String > values = option . getValuesList () ;
for ( final Option option : options ) { if ( opt . equals ( option . getOpt () ) || opt . equals ( option . getLongOpt () ) ) MST[NegateConditionalsMutator]MSP[N] { final List < String > values = option . getValuesList () ;
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; MST[VoidMethodCallMutator]MSP[N] return this ; }
public CommandLine build () { return commandLine ; MST[ReturnValsMutator]MSP[N] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[ReturnValsMutator]MSP[S] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[experimental.MemberVariableMutator]MSP[N] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; MST[ReturnValsMutator]MSP[S] } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
public CommandLine build () { return commandLine ; MST[NullReturnValsMutator]MSP[N] }
return processed . toArray ( optionsArray ) ; } public Builder addOption ( final Option opt ) MST[ConstructorCallMutator]MSP[N] { commandLine . addOption ( opt ) ; return this ; } public Builder addArg ( final String arg ) { commandLine . addArg ( arg ) ; return this ; }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( ch ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[InlineConstantMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[N] } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[experimental.MemberVariableMutator]MSP[S] currentOption = null ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[S] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[S] break; } } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR3Mutator]MSP[N] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final int pos = t . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final String value = t . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[S] break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR4Mutator]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[ReturnValsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NegateConditionalsMutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[S] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[S] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[S] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR6Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[ConditionalsBoundaryMutator]MSP[N] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; MST[VoidMethodCallMutator]MSP[N] } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR2Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt . hasArg () ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[InlineConstantMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] {
return false ; MST[rv.CRCR1Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[S] break; } } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return false ; MST[rv.CRCR6Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR4Mutator]MSP[S] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[S] {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR5Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String value = t . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { skipParsing = true ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[ConditionalsBoundaryMutator]MSP[S] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[ConditionalsBoundaryMutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( options . hasShortOption ( optName ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
} else if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
} else if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[ReturnValsMutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[S] break; } } else {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { return true ; }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[EmptyObjectReturnValsMutator]MSP[S] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR5Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR6Mutator]MSP[N] break; } } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR2Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[InlineConstantMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } private boolean isLongOption ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N]
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR1Mutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NonVoidMethodCallMutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[S] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[experimental.NakedReceiverMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( allowPartialMatching ) MST[NegateConditionalsMutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[N] if ( arguments != null ) {
handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[S] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[InlineConstantMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR1Mutator]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[S] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR5Mutator]MSP[N] currentOption = null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR1Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD2Mutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[VoidMethodCallMutator]MSP[N] } }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = option ; } else {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR3Mutator]MSP[N] {
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NegateConditionalsMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR5Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR1Mutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[IncrementsMutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasLongOption ( token ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[N]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[S] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR5Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( options . getOptionGroup ( option ) != null ) {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR5Mutator]MSP[S] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI3Mutator]MSP[N] skipParsing = false ; currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N]
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR4Mutator]MSP[S] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = option ; } else {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR3Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ; MST[VoidMethodCallMutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[N] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] final boolean selected = group != null && group . getSelected () != null ;
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; MST[NonVoidMethodCallMutator]MSP[N] updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
return true ; MST[rv.CRCR6Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR4Mutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[rv.ROR5Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N]
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[ReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[ReturnValsMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR5Mutator]MSP[N] } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR4Mutator]MSP[N] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR2Mutator]MSP[S] break; } } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[N] }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[N] handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[S] break; } } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
} else if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[ArgumentPropagationMutator]MSP[N] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR5Mutator]MSP[S] break; } } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[S]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[InlineConstantMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[S]
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
} else if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S]
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[S] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR4Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N]
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[NegateConditionalsMutator]MSP[N] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N]
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[MathMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
currentOption = null ; MST[experimental.MemberVariableMutator]MSP[S] } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR5Mutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
return false ; MST[rv.CRCR3Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ReturnValsMutator]MSP[N] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; MST[experimental.MemberVariableMutator]MSP[N] this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[S] } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleLongOptionWithEqual ( token ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[S] break; } } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[S] { return true ; }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR2Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = option ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[S] } } else if ( isJavaProperty ( opt ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N]
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR5Mutator]MSP[N] {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { currentOption = option ; } else {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NegateConditionalsMutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; MST[rv.CRCR5Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[S] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( opt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
handleOption ( options . getOption ( ch ) ) ; MST[VoidMethodCallMutator]MSP[N] if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . acceptsArg () )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[N] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[ConditionalsBoundaryMutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[InlineConstantMutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[S] { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final String prefix = t . substring ( 0 , i ) ; MST[rv.UOI2Mutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[InlineConstantMutator]MSP[S] } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[ConstructorCallMutator]MSP[S] if ( options . hasLongOption ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isLongOption ( final String token ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[VoidMethodCallMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[N] }
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
} else if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[N] }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR2Mutator]MSP[N] } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR2Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[S] break; } } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR4Mutator]MSP[N] {
Option option = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] matches . add ( option . getLongOpt () ) ; } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[S] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; MST[NonVoidMethodCallMutator]MSP[N] final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NonVoidMethodCallMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR3Mutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR6Mutator]MSP[N] {
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[S] } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NegateConditionalsMutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[MathMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR5Mutator]MSP[S] {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR1Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI4Mutator]MSP[N] {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR5Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; MST[InlineConstantMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[S] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[S] break; } } }
cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR5Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[InlineConstantMutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR1Mutator]MSP[N] {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) MST[rv.ROR2Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; MST[ConstructorCallMutator]MSP[N] } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String prefix = t . substring ( 0 , i ) ; MST[experimental.NakedReceiverMutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI3Mutator]MSP[S] break; } } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[InlineConstantMutator]MSP[N] currentOption = null ;
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR3Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ handleOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR6Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_3 . equalsIgnoreCase ( value )
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[ConstructorCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ABSMutator]MSP[S] break; } } }
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[ArgumentPropagationMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR3Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[InlineConstantMutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return true ; MST[rv.CRCR3Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { currentOption = option ; } else {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { skipParsing = true ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR3Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[InlineConstantMutator]MSP[S] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[ReturnValsMutator]MSP[N] } private boolean isLongOption ( final String token ) {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[NegateConditionalsMutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR3Mutator]MSP[N] currentOption = null ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[N] } cmd = new CommandLine () ; if ( arguments != null ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; MST[VoidMethodCallMutator]MSP[N] if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[rv.ROR5Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[S] break; } } else {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR2Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR1Mutator]MSP[N] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[N] { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; MST[VoidMethodCallMutator]MSP[N] option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[N] }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[ArgumentPropagationMutator]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR3Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { skipParsing = true ; } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NonVoidMethodCallMutator]MSP[S] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR2Mutator]MSP[N] }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR4Mutator]MSP[N] break; } } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR4Mutator]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[S] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return true ; MST[InlineConstantMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; MST[VoidMethodCallMutator]MSP[N] if ( option . hasArg () ) { currentOption = option ; } else {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; } } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[InlineConstantMutator]MSP[S] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] break; } } }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N]
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR5Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR3Mutator]MSP[N] break; } } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[S] { return true ; }
} else if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR6Mutator]MSP[N] currentOption = null ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR2Mutator]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[N] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[S] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR6Mutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR2Mutator]MSP[N] }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR2Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N]
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[S] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[S] break; } } }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; MST[NonVoidMethodCallMutator]MSP[N] } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[InlineConstantMutator]MSP[N] } }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[InlineConstantMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI1Mutator]MSP[N] skipParsing = false ; currentOption = null ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR5Mutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[ConditionalsBoundaryMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR4Mutator]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.UOI2Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[InlineConstantMutator]MSP[N] break; } } }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[NegateConditionalsMutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[ReturnValsMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break; } } else {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR2Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR4Mutator]MSP[S]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[N] currentOption = null ; } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[N] checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[N] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI4Mutator]MSP[N] skipParsing = false ; currentOption = null ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[ConditionalsBoundaryMutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( option != null && option . acceptsArg () ) {
return true ; MST[rv.CRCR2Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.UOI2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR3Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; MST[ConstructorCallMutator]MSP[S] } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S]
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[N] } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR4Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR5Mutator]MSP[N] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[S]
for ( final String argument : arguments ) MST[rv.ABSMutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[NegateConditionalsMutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR5Mutator]MSP[S] {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; MST[ConstructorCallMutator]MSP[S] } }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
for ( final String argument : arguments ) MST[rv.UOI4Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[N] } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
{ handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleUnknownToken ( currentToken ) ; } } } private void handleShortAndLongOption ( final String token ) throws ParseException { final String t = Util . stripLeadingHyphens ( token ) ;
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; MST[VoidMethodCallMutator]MSP[S] } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR3Mutator]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[S]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[experimental.MemberVariableMutator]MSP[N] } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { handleLongOptionWithoutEqual ( token ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR1Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( options . hasShortOption ( optName ) ) {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
} else if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR3Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[S] break; } } else {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI3Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[InlineConstantMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
} else if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; skipParsing = false ; MST[rv.CRCR1Mutator]MSP[N] currentOption = null ;
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[experimental.MemberVariableMutator]MSP[N] skipParsing = false ; currentOption = null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR1Mutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; MST[VoidMethodCallMutator]MSP[N] } } private List < String > getMatchingLongOptions ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR6Mutator]MSP[S] {
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return matches ; } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] || lr_3 . equalsIgnoreCase ( value )
return true ; MST[ReturnValsMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
} else if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[N] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR3Mutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[NonVoidMethodCallMutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
return false ; MST[ReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
Option option = options . getOption ( token ) ; matches . add ( option . getLongOpt () ) ; } return matches ; MST[ReturnValsMutator]MSP[S] } } protected void handleConcatenatedOptions ( final String token ) throws ParseException {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI2Mutator]MSP[N] break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOD1Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[S] { return true ; }
final String opt = token . substring ( 0 , 1 ) ; MST[InlineConstantMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } private boolean isArgument ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR1Mutator]MSP[N] {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR3Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
if ( allowPartialMatching ) MST[rv.ROR4Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.ABSMutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[N] }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NonVoidMethodCallMutator]MSP[N] }
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[VoidMethodCallMutator]MSP[S] break; } } else {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR1Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String value = t . substring ( pos + 1 ) ; MST[rv.UOI4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isLongOption ( final String token ) {
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[S] handleOption ( options . getOption ( key ) ) ; } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[N] return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
return false ; MST[rv.CRCR5Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR3Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; MST[ReturnValsMutator]MSP[N] } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[N] }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( options . getOptionGroup ( option ) != null ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR4Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR2Mutator]MSP[N] break; } } }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = option ; } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR3Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.ROR5Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[InlineConstantMutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[InlineConstantMutator]MSP[N] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR5Mutator]MSP[N] }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[InlineConstantMutator]MSP[S]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NegateConditionalsMutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] return true ; } catch ( final NumberFormatException e ) { return false ; } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[N] }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR6Mutator]MSP[S]
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[S] { handleLongOptionWithoutEqual ( token ) ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { skipParsing = true ; } }
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR2Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
} else if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; MST[ArgumentPropagationMutator]MSP[N] } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; MST[VoidMethodCallMutator]MSP[N] } } } else { final String opt = t . substring ( 0 , pos ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[InlineConstantMutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } catch ( final NumberFormatException e ) { return false ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR6Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { skipParsing = true ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N]
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ROR2Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[N]
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR4Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[ReturnValsMutator]MSP[N] } private boolean isJavaProperty ( final String token ) {
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR2Mutator]MSP[S]
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
final String opt = token . substring ( 0 , 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[ReturnValsMutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[InlineConstantMutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; MST[experimental.MemberVariableMutator]MSP[N] if ( skipParsing ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[InlineConstantMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[S]
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[S]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { skipParsing = true ; } }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.UOI2Mutator]MSP[N] skipParsing = false ; currentOption = null ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[N] }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
return true ; MST[rv.CRCR4Mutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[S] }
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return true ; }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_3 . equalsIgnoreCase ( value )
if ( allowPartialMatching ) MST[rv.ROR3Mutator]MSP[N] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR4Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N]
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isLongOption ( final String token ) {
final int pos = t . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; if ( arguments != null ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[N] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR2Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[NegateConditionalsMutator]MSP[N] break; } } }
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[MathMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[rv.ROR4Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI1Mutator]MSP[N] break; } } }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[InlineConstantMutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[S] break; } } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; MST[VoidMethodCallMutator]MSP[N] }
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.ROR3Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ;
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N]
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
public CommandLine parse ( final Options options , final String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { this . options = options ; this . stopAtNonOption = stopAtNonOption ; MST[rv.ABSMutator]MSP[N] skipParsing = false ; currentOption = null ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR3Mutator]MSP[N] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = option ; } else {
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; MST[rv.CRCR3Mutator]MSP[N] } catch ( final NumberFormatException e ) { return false ; } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[rv.ROR4Mutator]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { currentOption = option ; } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[ReturnValsMutator]MSP[N] } }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOD2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[rv.ROR4Mutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR1Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N]
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
final int pos = t . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[NegateConditionalsMutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
final OptionGroup group = options . getOptionGroup ( option ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { expectedOpts . remove ( group ) ; } group . setSelected ( option ) ; } } private List < String > getMatchingLongOptions ( final String token ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N]
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR4Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.CRCR4Mutator]MSP[S] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR4Mutator]MSP[S] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
final String value = t . substring ( pos + 1 ) ; MST[rv.CRCR4Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; MST[experimental.MemberVariableMutator]MSP[N] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR6Mutator]MSP[N] }
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR1Mutator]MSP[S]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () ) MST[rv.ROR3Mutator]MSP[N]
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.ROR4Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR2Mutator]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.ROR3Mutator]MSP[N] }
if ( ! cmd . hasOption ( option ) && ! selected ) { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; MST[rv.CRCR6Mutator]MSP[N] } }
for ( final String argument : arguments ) { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[rv.ROR5Mutator]MSP[S] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR1Mutator]MSP[S]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { return true ; }
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] break; } } else {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] break; } } else {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) MST[rv.ROR4Mutator]MSP[N] { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String opt = token . substring ( 0 , 1 ) ; MST[rv.CRCR5Mutator]MSP[N] final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; }
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[S] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { opt . addValueForProcessing ( value ) ; } } else if ( ! ( lr_2 . equalsIgnoreCase ( value ) || lr_3 . equalsIgnoreCase ( value )
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( final String argument : arguments ) MST[rv.UOI3Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
for ( final String argument : arguments ) MST[rv.UOI2Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N]
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[rv.CRCR1Mutator]MSP[S] }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) {
for ( final String argument : arguments ) MST[rv.UOI1Mutator]MSP[N] { handleToken ( argument ) ; } } checkRequiredArgs () ; handleProperties ( properties ) ; checkRequiredOptions () ; return cmd ; } private void handleProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return;
} else if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { currentOption = option ; } else {
return ! isOption ( token ) || isNegativeNumber ( token ) ; } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N] final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) { return true ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } private void handleUnknownToken ( final String token ) throws ParseException {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[S] break; } } else {
else if ( getLongPrefix ( token ) != null && ! token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return true ; } return false ; } private void handleUnknownToken ( final String token ) throws ParseException {
else { final String opt = getLongPrefix ( t ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt != null && options . getOption ( opt ) . acceptsArg () ) { handleOption ( options . getOption ( opt ) ) ;
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOptionWithoutEqual ( token ) ; }
throw new AmbiguousOptionException ( token , matchingOpts ) ; } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] handleOption ( options . getOption ( key ) ) ; } }
handleShortAndLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) { currentOption = null ; } } private boolean isArgument ( final String token ) {
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) {
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; MST[experimental.MemberVariableMutator]MSP[N] } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N] { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S]
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR1Mutator]MSP[N] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N]
final String t = pos == - 1 ? token : token . substring ( 0 , pos ) ; if ( ! getMatchingLongOptions ( t ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[S] { return true ; }
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N]
throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.CRCR5Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleOption ( options . getOption ( opt ) ) ;
if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) MST[rv.ROR1Mutator]MSP[N] { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.ROR1Mutator]MSP[S] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.CRCR2Mutator]MSP[S] {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[S] break; } } else {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[NonVoidMethodCallMutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.CRCR4Mutator]MSP[N] break; } } }
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) { final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ;
return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } private boolean isLongOption ( final String token ) {
if ( allowPartialMatching ) MST[rv.ROR1Mutator]MSP[S] { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; if ( options . hasLongOption ( token ) ) {
handleOption ( options . getOption ( ch ) ) ; if ( currentOption != null && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[S] { currentOption . addValueForProcessing ( token . substring ( i + 1 ) ) ; break; } } else {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N]
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR5Mutator]MSP[S] {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[VoidMethodCallMutator]MSP[N] break; } } }
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N]
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] {
currentOption . addValueForProcessing ( t . substring ( opt . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[S] currentOption = null ; } else if ( isJavaProperty ( t ) ) { handleOption ( options . getOption ( t . substring ( 0 , 1 ) ) ) ;
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.UOI4Mutator]MSP[S] break; } } }
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] if ( options . hasShortOption ( optName ) ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[S]
|| lr_4 . equalsIgnoreCase ( value ) ) ) { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] }
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; MST[rv.ROR2Mutator]MSP[N] } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } else { final String key = options . hasLongOption ( token ) ? token : matchingOpts . get ( 0 ) ; handleOption ( options . getOption ( key ) ) ; } }
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) MST[NonVoidMethodCallMutator]MSP[N] {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] } private boolean isLongOption ( final String token ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isLongOption ( final String token ) {
final String prefix = t . substring ( 0 , i ) ; MST[rv.CRCR1Mutator]MSP[S] if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; } private boolean isJavaProperty ( final String token ) {
final String opt = token . substring ( 0 , 1 ) ; final Option option = options . getOption ( opt ) ; return option != null && ( option . getArgs () >= 2 || option . getArgs () == Option . UNLIMITED_VALUES ) ; MST[InlineConstantMutator]MSP[N] }
handleOption ( option ) ; currentOption . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[S] currentOption = null ; } else { handleUnknownToken ( token ) ; } } else if ( isJavaProperty ( opt ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; MST[VoidMethodCallMutator]MSP[S] }
private void checkRequiredArgs () throws ParseException { if ( currentOption != null && currentOption . requiresArg () ) { throw new MissingArgumentException ( currentOption ) ; } } private void handleToken ( final String token ) throws ParseException { currentToken = token ; if ( skipParsing ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
private void handleOption ( Option option ) throws ParseException { checkRequiredArgs () ; option = ( Option ) option . clone () ; updateRequiredOptions ( option ) ; MST[VoidMethodCallMutator]MSP[N] cmd . addOption ( option ) ; if ( option . hasArg () ) { currentOption = option ; } else {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.AOR2Mutator]MSP[N] {
return true ; } return optName . length () > 0 && options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; MST[NegateConditionalsMutator]MSP[N] } private boolean isLongOption ( final String token ) {
else { final String opt = getLongPrefix ( t ) ; if ( opt != null && options . getOption ( opt ) . acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[S] { handleOption ( options . getOption ( opt ) ) ;
if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[S] { return false ; } final int pos = token . indexOf ( lr_7 ) ;
|| lr_4 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[S] { continue; } handleOption ( opt ) ; currentOption = null ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! expectedOpts . isEmpty () ) { throw new MissingOptionException ( expectedOpts ) ; } }
final List < String > matchingOpts = getMatchingLongOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( opt ) ) MST[rv.ROR4Mutator]MSP[N] {
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; MST[rv.CRCR2Mutator]MSP[N] final String opt = token . substring ( 0 , pos ) ;
expectedOpts = new ArrayList ( options . getRequiredOptions () ) ; for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[N] if ( arguments != null ) {
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; MST[rv.CRCR2Mutator]MSP[S] if ( options . hasShortOption ( optName ) ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[MathMutator]MSP[N] {
final int pos = t . indexOf ( '=' ) ; if ( t . length () == 1 ) { if ( options . hasShortOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { handleOption ( options . getOption ( t ) ) ; } else { handleUnknownToken ( token ) ; }
final String value = t . substring ( pos + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } else { final String key = options . hasLongOption ( opt ) ? opt : matchingOpts . get ( 0 ) ; final Option option = options . getOption ( key ) ; if ( option . acceptsArg () )
final String value = t . substring ( pos + 1 ) ; if ( opt . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleOption ( options . getOption ( opt . substring ( 0 , 1 ) ) ) ; MST[VoidMethodCallMutator]MSP[N] currentOption . addValueForProcessing ( opt . substring ( 1 ) ) ; currentOption . addValueForProcessing ( value ) ; currentOption = null ; } else { handleLongOptionWithEqual ( token ) ; } }
final String value = t . substring ( pos + 1 ) ; MST[rv.AOR1Mutator]MSP[N] if ( opt . length () == 1 ) { final Option option = options . getOption ( opt ) ; if ( option != null && option . acceptsArg () ) {
handleUnknownToken ( stopAtNonOption && i > 1 ? token . substring ( i ) : token ) ; MST[rv.ROR5Mutator]MSP[N] break; } } }
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return ! isOption ( token ) || isNegativeNumber ( token ) ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isNegativeNumber ( final String token ) { try { Double . parseDouble ( token ) ; return true ; } catch ( final NumberFormatException e ) { return false ; } }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[InlineConstantMutator]MSP[N] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
if ( opt == null ) { throw new UnrecognizedOptionException ( lr_1 , option ) ; } final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[N]
if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] { final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR5Mutator]MSP[N] {
handleShortAndLongOption ( token ) ; } else { handleUnknownToken ( token ) ; } if ( currentOption != null && ! currentOption . acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] { currentOption = null ; } } private boolean isArgument ( final String token ) {
} else if ( pos == - 1 ) { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.CRCR3Mutator]MSP[N] {
private boolean isOption ( final String token ) { return isLongOption ( token ) || isShortOption ( token ) ; } private boolean isShortOption ( final String token ) { if ( ! token . startsWith ( lr_6 ) || token . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] {
final String prefix = t . substring ( 0 , i ) ; if ( options . hasLongOption ( prefix ) ) { opt = prefix ; break; } } return opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } private boolean isJavaProperty ( final String token ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
} else if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( options . hasShortOption ( t ) ) { handleOption ( options . getOption ( t ) ) ; } else if ( ! getMatchingLongOptions ( t ) . isEmpty () ) { handleLongOptionWithoutEqual ( token ) ; }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] {
cmd . addArg ( token ) ; } else if ( lr_5 . equals ( token ) ) { skipParsing = true ; } else if ( currentOption != null && currentOption . acceptsArg () && isArgument ( token ) ) MST[rv.ROR2Mutator]MSP[N] {
currentOption . addValueForProcessing ( t . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] currentOption = null ; } else { handleConcatenatedOptions ( token ) ; } } } else { final String opt = t . substring ( 0 , pos ) ;
} for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[N] { final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ;
private void handleLongOptionWithEqual ( final String token ) throws ParseException { final int pos = token . indexOf ( '=' ) ; final String value = token . substring ( pos + 1 ) ; final String opt = token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N]
if ( allowPartialMatching ) { return options . getMatchingOptions ( token ) ; } else { List < String > matches = new ArrayList < String > ( 1 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( options . hasLongOption ( token ) ) {
private void handleLongOption ( final String token ) throws ParseException { if ( token . indexOf ( '=' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { handleLongOptionWithoutEqual ( token ) ; } else { handleLongOptionWithEqual ( token ) ; } } private void handleLongOptionWithoutEqual ( final String token ) throws ParseException {
currentOption . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( token ) ) ; } else if ( token . startsWith ( lr_5 ) ) { handleLongOption ( token ) ; } else if ( token . startsWith ( lr_6 ) && ! lr_6 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } final int pos = token . indexOf ( lr_7 ) ; final String optName = pos == - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
currentOption = null ; } } private void updateRequiredOptions ( final Option option ) throws AlreadySelectedException { if ( option . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { expectedOpts . remove ( option . getKey () ) ; } if ( options . getOptionGroup ( option ) != null ) {
if ( token . startsWith ( lr_6 ) && token . length () > 1 && ! stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new UnrecognizedOptionException ( lr_8 + token , token ) ; } cmd . addArg ( token ) ; if ( stopAtNonOption ) { skipParsing = true ; } }
final List < String > matchingOpts = getMatchingLongOptions ( token ) ; if ( matchingOpts . isEmpty () ) { handleUnknownToken ( currentToken ) ; } else if ( matchingOpts . size () > 1 && ! options . hasLongOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
} private String getLongPrefix ( final String token ) { final String t = Util . stripLeadingHyphens ( token ) ; int i ; String opt = null ; for ( i = t . length () - 2 ; i > 1 ; i -- ) MST[rv.ABSMutator]MSP[S] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ;
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR1Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR3Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[InlineConstantMutator]MSP[N]
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR3Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR2Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR5Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[IncrementsMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[InlineConstantMutator]MSP[N] } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR1Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[ArgumentPropagationMutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[experimental.NakedReceiverMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S]
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; MST[ArgumentPropagationMutator]MSP[N] if ( options . hasOption ( opt ) )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR5Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR3Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR4Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.UOI4Mutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR2Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[S] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[IncrementsMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arguments [ i ] ) ; MST[rv.UOI1Mutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[InlineConstantMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ABSMutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.UOI1Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[NegateConditionalsMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[experimental.NakedReceiverMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR2Mutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[MathMutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR2Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI4Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR3Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; MST[rv.UOI2Mutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
else if ( lr_2 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NegateConditionalsMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR3Mutator]MSP[N]
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR1Mutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
tokens . add ( arguments [ i ] ) ; MST[rv.ABSMutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR5Mutator]MSP[N]
tokens . add ( arguments [ i ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR3Mutator]MSP[N] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N]
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR3Mutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR4Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI2Mutator]MSP[S] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ABSMutator]MSP[N] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N]
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR4Mutator]MSP[N] } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR6Mutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR2Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR2Mutator]MSP[N]
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[InlineConstantMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
{ tokens . add ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) {
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR4Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[experimental.RemoveIncrementsMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[S] { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[S] }
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR1Mutator]MSP[N] } else {
else if ( lr_2 . equals ( arg ) ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR5Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR2Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR1Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NonVoidMethodCallMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[InlineConstantMutator]MSP[S] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR2Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR5Mutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR1Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; MST[rv.UOI3Mutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
eatTheRest = stopAtNonOption ; MST[rv.UOI1Mutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[ArgumentPropagationMutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR1Mutator]MSP[S] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[ArgumentPropagationMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[InlineConstantMutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR3Mutator]MSP[N] } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR5Mutator]MSP[S] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.UOI3Mutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[InlineConstantMutator]MSP[N] }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR4Mutator]MSP[S]
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR2Mutator]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[ArgumentPropagationMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR1Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR2Mutator]MSP[N] {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N]
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI1Mutator]MSP[S] { for ( i ++ ; i < arguments . length ; i ++ ) {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.UOI3Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
else if ( lr_2 . equals ( arg ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR4Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.CRCR1Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } else {
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; boolean eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N]
else if ( lr_2 . equals ( arg ) ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NullReturnValsMutator]MSP[N] }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( opt ) )
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[NegateConditionalsMutator]MSP[N] {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; MST[rv.ABSMutator]MSP[N] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] }
@Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) { final List < String > tokens = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N] boolean eatTheRest = false ;
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[NegateConditionalsMutator]MSP[N]
for ( int i = 0 ; i < arguments . length ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] }
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( lr_1 ) ; }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arguments [ i ] ) ; MST[rv.UOI3Mutator]MSP[N] } } } return tokens . toArray ( new String [ tokens . size () ] ) ; }
else if ( lr_2 . equals ( arg ) ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( 2 ) ) ; } else {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) MST[rv.UOI3Mutator]MSP[N] {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) )
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { tokens . add ( arg . substring ( 0 , 2 ) ) ; tokens . add ( arg . substring ( 2 ) ) ; MST[rv.CRCR5Mutator]MSP[N] } else {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; tokens . add ( lr_1 ) ; }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR6Mutator]MSP[N] {
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.ROR1Mutator]MSP[N] {
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] tokens . add ( lr_1 ) ; }
tokens . add ( arguments [ i ] ) ; } } } return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ReturnValsMutator]MSP[N] }
{ tokens . add ( arg ) ; } else { if ( opt . indexOf ( '=' ) != - 1 && options . hasOption ( opt . substring ( 0 , opt . indexOf ( '=' ) ) ) ) MST[rv.CRCR4Mutator]MSP[N] {
eatTheRest = stopAtNonOption ; tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { for ( i ++ ; i < arguments . length ; i ++ ) {
else if ( lr_2 . equals ( arg ) ) { tokens . add ( lr_2 ) ; } else if ( arg . startsWith ( lr_2 ) ) { final String opt = Util . stripLeadingHyphens ( arg ) ; if ( options . hasOption ( opt ) ) MST[rv.ROR1Mutator]MSP[N]
eatTheRest = stopAtNonOption ; MST[rv.UOI4Mutator]MSP[S] tokens . add ( arg ) ; } } } else { tokens . add ( arg ) ; } if ( eatTheRest ) { for ( i ++ ; i < arguments . length ; i ++ ) {
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[InlineConstantMutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.ABSMutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
tokens . add ( arg . substring ( 0 , arg . indexOf ( '=' ) ) ) ; tokens . add ( arg . substring ( arg . indexOf ( '=' ) + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] }
for ( int i = 0 ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; MST[rv.UOI1Mutator]MSP[N] if ( lr_1 . equals ( arg ) ) { eatTheRest = true ; tokens . add ( lr_1 ) ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; }
public void printHelp ( final String cmdLineSyntax , final Options options , final boolean autoUsage ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , autoUsage ) ; }
public void printHelp ( final String cmdLineSyntax , final String header , final Options options , final String footer ) { printHelp ( cmdLineSyntax , header , options , footer , false ) ; }
public void printHelp ( final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { printHelp ( getWidth () , cmdLineSyntax , header , options , footer , autoUsage ) ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer ) { printHelp ( width , cmdLineSyntax , header , options , footer , false ) ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { final PrintWriter pw = new PrintWriter ( System . out ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; }
public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax , final String header , final Options options , final int leftPad , final int descPad , final String footer , final boolean autoUsage ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } } prefixList . add ( optBuf ) ;
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR5Mutator]MSP[S]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR3Mutator]MSP[S] { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[S] { return pos + 1 ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR5Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[NegateConditionalsMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return sb ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_5 ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR6Mutator]MSP[N]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR2Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI4Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOD1Mutator]MSP[N] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR5Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[PrimitiveReturnsMutator]MSP[N] }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR6Mutator]MSP[S] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI3Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[MathMutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR3Mutator]MSP[N] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR6Mutator]MSP[S] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[N] appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
if ( argName != null && argName . length () == 0 ) MST[rv.ROR3Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } } prefixList . add ( optBuf ) ; MST[NonVoidMethodCallMutator]MSP[N]
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR3Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR2Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR2Mutator]MSP[N]
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } prefixList . add ( optBuf ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR5Mutator]MSP[N] {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI4Mutator]MSP[N] {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[N] } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ABSMutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ; MST[IncrementsMutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR4Mutator]MSP[N] { -- pos ;
if ( option . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
} return s . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR4Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[InlineConstantMutator]MSP[S] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[N]
} return s . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[ArgumentPropagationMutator]MSP[N] } }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; MST[ReturnValsMutator]MSP[N] }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.ABSMutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; MST[rv.CRCR6Mutator]MSP[N] } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[InlineConstantMutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR1Mutator]MSP[S] { buff . append ( lr_5 ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( option . getOpt () != null ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[N] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR4Mutator]MSP[N]
if ( argName != null && argName . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[S] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
} return s . substring ( 0 , pos ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( ! group . isRequired () ) MST[rv.ROR1Mutator]MSP[S] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( text ) ; return sb ; }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI2Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR5Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI3Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI3Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[MathMutator]MSP[N] { final char c = text . charAt ( pos ) ;
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR3Mutator]MSP[S] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[NonVoidMethodCallMutator]MSP[S] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
catch ( final IOException e ) { } return sb ; MST[ReturnValsMutator]MSP[N] } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.ABSMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI4Mutator]MSP[S] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ABSMutator]MSP[N] }
if ( argName != null && argName . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR4Mutator]MSP[S] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[InlineConstantMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[NonVoidMethodCallMutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( ! group . isRequired () ) MST[rv.ROR4Mutator]MSP[S] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR3Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI1Mutator]MSP[N] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( getOptionComparator () != null ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI2Mutator]MSP[N] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR5Mutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR1Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[MathMutator]MSP[S] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR3Mutator]MSP[S] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR1Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[N] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[ConditionalsBoundaryMutator]MSP[N] { -- pos ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[InlineConstantMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR1Mutator]MSP[N] }
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[rv.ROR5Mutator]MSP[N] } } prefixList . add ( optBuf ) ;
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR2Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR3Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI1Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR4Mutator]MSP[S] { buff . append ( lr_5 ) ; } }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI3Mutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI1Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI3Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI1Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI2Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ABSMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[NegateConditionalsMutator]MSP[N] {
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[ConstructorCallMutator]MSP[N] if ( optBuf . length () < max ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; MST[VoidMethodCallMutator]MSP[N] } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI2Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { final String argName = option . getArgName () ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[InlineConstantMutator]MSP[S] }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI2Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[InlineConstantMutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOD2Mutator]MSP[N] { -- pos ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
if ( s == null || s . length () == 0 ) MST[rv.ROR1Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR6Mutator]MSP[N] { -- pos ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } protected String rtrim ( final String s ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) MST[rv.AOD1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[IncrementsMutator]MSP[N] if ( optBuf . length () < max ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[N] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR5Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR1Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[NonVoidMethodCallMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI3Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI3Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI2Mutator]MSP[N] } }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.ABSMutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOD1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
} return s . substring ( 0 , pos ) ; MST[ReturnValsMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOD1Mutator]MSP[S] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR4Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI4Mutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; }
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR4Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI1Mutator]MSP[S] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI3Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR2Mutator]MSP[S] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.ABSMutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[NegateConditionalsMutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.ABSMutator]MSP[S] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR5Mutator]MSP[N] }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR1Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI1Mutator]MSP[N] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.ABSMutator]MSP[N] } }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR3Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR4Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[S] } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI3Mutator]MSP[N] if ( optBuf . length () < max ) {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.ABSMutator]MSP[N] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR1Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( s == null || s . length () == 0 ) { return s ; MST[ReturnValsMutator]MSP[N] } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOD2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR5Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( startPos + width >= text . length () ) MST[rv.UOI3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N]
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[ConditionalsBoundaryMutator]MSP[N] {
if ( startPos + width >= text . length () ) MST[rv.ROR1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI1Mutator]MSP[N] } }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR5Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } prefixList . add ( optBuf ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI3Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; MST[ReturnValsMutator]MSP[S] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[NonVoidMethodCallMutator]MSP[N]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.ABSMutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR2Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[S] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.ABSMutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI3Mutator]MSP[N] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[VoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.ABSMutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR1Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR2Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR5Mutator]MSP[N] } }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[NonVoidMethodCallMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR3Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.ABSMutator]MSP[S] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[InlineConstantMutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ABSMutator]MSP[N] }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.ABSMutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR1Mutator]MSP[N] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI2Mutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[NonVoidMethodCallMutator]MSP[N] {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
max = optBuf . length () > max ? optBuf . length () : max ; MST[ConditionalsBoundaryMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI1Mutator]MSP[N] } public int getLeftPadding () { return defaultLeftPad ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; MST[NullReturnValsMutator]MSP[N] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR1Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR2Mutator]MSP[N] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; MST[ConstructorCallMutator]MSP[N] String line ; boolean firstLine = true ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) MST[rv.ROR4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[ConditionalsBoundaryMutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI1Mutator]MSP[N] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[experimental.MemberVariableMutator]MSP[N] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( s == null || s . length () == 0 ) { return s ; MST[EmptyObjectReturnValsMutator]MSP[S] } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR1Mutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[NonVoidMethodCallMutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; MST[NullReturnValsMutator]MSP[N] }
if ( startPos + width >= text . length () ) MST[MathMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI4Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[S] { return pos + 1 ; }
} return s . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI4Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR3Mutator]MSP[N]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[VoidMethodCallMutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR4Mutator]MSP[N] }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[ConstructorCallMutator]MSP[N] } protected String rtrim ( final String s ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR5Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[experimental.NakedReceiverMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[InlineConstantMutator]MSP[N]
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI2Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR2Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR3Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI3Mutator]MSP[N] }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[experimental.MemberVariableMutator]MSP[S] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[ArgumentPropagationMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.ABSMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR4Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.ABSMutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI2Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR3Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR4Mutator]MSP[S] }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; MST[VoidMethodCallMutator]MSP[N] } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { final String argName = option . getArgName () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NegateConditionalsMutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { -- pos ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[NonVoidMethodCallMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI1Mutator]MSP[N] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI2Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR2Mutator]MSP[N]
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[InlineConstantMutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI1Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI4Mutator]MSP[N] } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR1Mutator]MSP[S]
} return s . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.UOI4Mutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { -- pos ;
if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( ! group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR1Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) {
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI2Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[rv.ROR5Mutator]MSP[N] {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI4Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( footer != null && footer . trim () . length () > 0 ) MST[ConditionalsBoundaryMutator]MSP[S] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.ABSMutator]MSP[S] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[InlineConstantMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR2Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI4Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI2Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR4Mutator]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR2Mutator]MSP[N]
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD2Mutator]MSP[S] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR6Mutator]MSP[S] }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( optBuf . length () < max ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[experimental.NakedReceiverMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR3Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR3Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR3Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
} return s . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.UOI1Mutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR2Mutator]MSP[N] if ( option . getDescription () != null ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ABSMutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[ReturnValsMutator]MSP[N] }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI1Mutator]MSP[N] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR6Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI3Mutator]MSP[S] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[NonVoidMethodCallMutator]MSP[N] {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR1Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return pos + 1 ; }
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI1Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[experimental.MemberVariableMutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; }
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI4Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI3Mutator]MSP[N] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.ABSMutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
printWrapped ( pw , width , 0 , text ) ; MST[InlineConstantMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[InlineConstantMutator]MSP[N]
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[ReturnValsMutator]MSP[N] }
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI1Mutator]MSP[S] { sb . append ( rtrim ( text ) ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI1Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR2Mutator]MSP[N] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR4Mutator]MSP[S]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ABSMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.UOI1Mutator]MSP[N] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI4Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR6Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR4Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOD2Mutator]MSP[N] if ( option . getDescription () != null ) {
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR3Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { appendOption ( buff , it . next () , true ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR2Mutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI4Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[N] }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI3Mutator]MSP[N]
buff . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOD1Mutator]MSP[N] { -- pos ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI4Mutator]MSP[N] { -- pos ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ABSMutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ABSMutator]MSP[N] { sb . append ( text ) ; return sb ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[VoidMethodCallMutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } } prefixList . add ( optBuf ) ;
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI1Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR6Mutator]MSP[N]
} return s . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI2Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI4Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.UOI4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI3Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR2Mutator]MSP[N] }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR1Mutator]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR6Mutator]MSP[N] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( ! group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; MST[VoidMethodCallMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[VoidMethodCallMutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI3Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; MST[NonVoidMethodCallMutator]MSP[N] while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR5Mutator]MSP[N]
while ( ( line = in . readLine () ) != null ) MST[NegateConditionalsMutator]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[MathMutator]MSP[S] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI4Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( startPos + width >= text . length () ) MST[rv.ROR2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR3Mutator]MSP[S] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR5Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( ! group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI2Mutator]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S] { buff . append ( lr_5 ) ; } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
while ( ( line = in . readLine () ) != null ) MST[rv.ROR5Mutator]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[VoidMethodCallMutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( startPos + width >= text . length () ) MST[NegateConditionalsMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[ConditionalsBoundaryMutator]MSP[S] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
while ( ( line = in . readLine () ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.ABSMutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.ABSMutator]MSP[N] } }
if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI4Mutator]MSP[S] } printOptions ( pw , width , options , leftPad , descPad ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.UOI2Mutator]MSP[N] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI1Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[N] }
} if ( header != null && header . trim () . length () > 0 ) MST[experimental.NakedReceiverMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[NegateConditionalsMutator]MSP[N] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI2Mutator]MSP[N] } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR2Mutator]MSP[N]
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI3Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR3Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI2Mutator]MSP[N] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( getOptionComparator () != null ) MST[rv.ROR5Mutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR6Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[PrimitiveReturnsMutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[PrimitiveReturnsMutator]MSP[S] }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI1Mutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( option . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR2Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI3Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ; MST[NonVoidMethodCallMutator]MSP[S]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NonVoidMethodCallMutator]MSP[N] { -- pos ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.ABSMutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR4Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NegateConditionalsMutator]MSP[S]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI4Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI4Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ABSMutator]MSP[N] {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOD2Mutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.ABSMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ABSMutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( startPos + width >= text . length () ) MST[rv.UOI3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR5Mutator]MSP[N] { -- pos ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[S] } public String getOptPrefix () { return defaultOptPrefix ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N]
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI2Mutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
} return s . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ABSMutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[N] } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR3Mutator]MSP[N] {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N]
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI1Mutator]MSP[N] } printOptions ( pw , width , options , leftPad , descPad ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI4Mutator]MSP[N] }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR5Mutator]MSP[N]
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI1Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR3Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI3Mutator]MSP[N]
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[VoidMethodCallMutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR6Mutator]MSP[N]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.ABSMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[ConstructorCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI2Mutator]MSP[N] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR4Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI1Mutator]MSP[N] } }
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR3Mutator]MSP[S]
if ( ! group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR6Mutator]MSP[S] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI4Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI1Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR4Mutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[S] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR5Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR3Mutator]MSP[S] }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[InlineConstantMutator]MSP[N] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI2Mutator]MSP[N] }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR5Mutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( s == null || s . length () == 0 ) MST[rv.ROR4Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[rv.ROR5Mutator]MSP[S]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String argName = option . getArgName () ;
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[NegateConditionalsMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOD1Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI4Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI1Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[S] { return pos + 1 ; }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; MST[ConstructorCallMutator]MSP[N] String line ; boolean firstLine = true ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR5Mutator]MSP[N] }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
if ( startPos + width >= text . length () ) MST[rv.AOR1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR1Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( startPos + width >= text . length () ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( ! processedGroups . contains ( group ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ABSMutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; MST[ReturnValsMutator]MSP[N] } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[ArgumentPropagationMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( startPos + width >= text . length () ) MST[rv.ROR5Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
final String lpad = createPadding ( leftPad ) ; MST[rv.ABSMutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } prefixList . add ( optBuf ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR1Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR4Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[ArgumentPropagationMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[MathMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR2Mutator]MSP[N] { -- pos ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[NegateConditionalsMutator]MSP[N] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[ConditionalsBoundaryMutator]MSP[S] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.UOI2Mutator]MSP[N] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR1Mutator]MSP[N] { -- pos ;
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI1Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR4Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR3Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[ArgumentPropagationMutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI2Mutator]MSP[N] { -- pos ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.UOI3Mutator]MSP[N] { -- pos ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.ABSMutator]MSP[N] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR6Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR3Mutator]MSP[N] { -- pos ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; MST[rv.ABSMutator]MSP[N] } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { Collections . sort ( optList , getOptionComparator () ) ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR4Mutator]MSP[S] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR2Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) MST[rv.ROR3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR3Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[MathMutator]MSP[N] { -- pos ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; MST[rv.UOI2Mutator]MSP[N] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[ConditionalsBoundaryMutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI4Mutator]MSP[S] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[InlineConstantMutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR4Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI4Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[S] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR2Mutator]MSP[N]
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI2Mutator]MSP[N] if ( option . getDescription () != null ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI1Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.ROR3Mutator]MSP[N] }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR6Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[rv.ROR5Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[NegateConditionalsMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI1Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; MST[ReturnValsMutator]MSP[N] }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI2Mutator]MSP[N] } public int getLeftPadding () { return defaultLeftPad ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR5Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ROR3Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI3Mutator]MSP[S] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR3Mutator]MSP[S] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR5Mutator]MSP[S] }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.AOR1Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; MST[ConstructorCallMutator]MSP[N] final List < Option > optList = options . helpOptions () ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR5Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR1Mutator]MSP[S] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; MST[ReturnValsMutator]MSP[N] }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR4Mutator]MSP[S] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI1Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR1Mutator]MSP[N]
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI3Mutator]MSP[N] }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI4Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR1Mutator]MSP[S] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[InlineConstantMutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR2Mutator]MSP[S] }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR3Mutator]MSP[N]
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI1Mutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR4Mutator]MSP[N] { -- pos ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.ABSMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI4Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR1Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; MST[VoidMethodCallMutator]MSP[N] } if ( it . hasNext () ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI3Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.ABSMutator]MSP[S] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI1Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR1Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR2Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR5Mutator]MSP[N]
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR2Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR4Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void printHelp ( final int width , final String cmdLineSyntax , final String header , final Options options , final String footer , final boolean autoUsage ) { final PrintWriter pw = new PrintWriter ( System . out ) ; MST[ConstructorCallMutator]MSP[S]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } return sb ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( startPos + width >= text . length () ) MST[rv.AOR4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR6Mutator]MSP[N] } }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI4Mutator]MSP[N] if ( optBuf . length () < max ) {
if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
optBuf . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.ABSMutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; }
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ; MST[ConstructorCallMutator]MSP[N]
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR3Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
catch ( final IOException e ) { } return sb ; MST[NullReturnValsMutator]MSP[N] } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOD1Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; MST[NonVoidMethodCallMutator]MSP[N] final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_5 ) ; } }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( ! required ) { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI4Mutator]MSP[N] } }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ABSMutator]MSP[N] { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI2Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI4Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.ABSMutator]MSP[S] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR1Mutator]MSP[S] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI4Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ROR5Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.ABSMutator]MSP[N] if ( option . getDescription () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI4Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR6Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOD1Mutator]MSP[N]
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR2Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI3Mutator]MSP[S] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR4Mutator]MSP[N]
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.ABSMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR1Mutator]MSP[N] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR3Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR4Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( argName != null && argName . length () == 0 ) MST[NegateConditionalsMutator]MSP[S] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI2Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR3Mutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N]
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[InlineConstantMutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } prefixList . add ( optBuf ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI4Mutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[N] }
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR6Mutator]MSP[N]
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI2Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[MathMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; MST[experimental.NakedReceiverMutator]MSP[N] return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { sb . append ( rtrim ( text ) ) ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NegateConditionalsMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI4Mutator]MSP[N]
if ( option . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR1Mutator]MSP[N] }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR5Mutator]MSP[N]
if ( pos != - 1 && pos <= width ) MST[ConditionalsBoundaryMutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.UOI3Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( ! group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI1Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[ReturnValsMutator]MSP[S] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR5Mutator]MSP[S] }
} if ( header != null && header . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI2Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR6Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S]
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI2Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI4Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[rv.ROR5Mutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR1Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[InlineConstantMutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
final String lpad = createPadding ( leftPad ) ; MST[NonVoidMethodCallMutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; MST[rv.CRCR4Mutator]MSP[S] } final String padding = createPadding ( nextLineTabStop ) ;
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI4Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( argName != null && argName . length () == 0 ) MST[rv.ROR5Mutator]MSP[S] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[N]
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR6Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( ! processedGroups . contains ( group ) ) MST[NonVoidMethodCallMutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI3Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N]
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; MST[VoidMethodCallMutator]MSP[N] }
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[experimental.RemoveIncrementsMutator]MSP[N] if ( optBuf . length () < max ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI1Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[InlineConstantMutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[InlineConstantMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR2Mutator]MSP[N] { -- pos ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI3Mutator]MSP[S] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI3Mutator]MSP[N] }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR4Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; pw . flush () ; MST[VoidMethodCallMutator]MSP[S] } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; MST[ArgumentPropagationMutator]MSP[N]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR4Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { appendOption ( buff , it . next () , true ) ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
if ( startPos + width >= text . length () ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[S] { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR1Mutator]MSP[S] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[NonVoidMethodCallMutator]MSP[N] }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
final StringBuffer sb = new StringBuffer () ; MST[ConstructorCallMutator]MSP[N] renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.AOR3Mutator]MSP[N] { -- pos ;
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR5Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ; MST[rv.ABSMutator]MSP[N]
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N]
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR5Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI1Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI4Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[N] }
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; MST[ConstructorCallMutator]MSP[N] if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; }
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
private Appendable renderWrappedTextBlock ( final StringBuffer sb , final int width , final int nextLineTabStop , final String text ) { try { final BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; MST[rv.CRCR3Mutator]MSP[N]
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.CRCR4Mutator]MSP[N] { -- pos ;
if ( s == null || s . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[ReturnValsMutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.ABSMutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI1Mutator]MSP[N] } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
if ( pos != - 1 && pos <= width ) MST[NegateConditionalsMutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; MST[rv.UOI1Mutator]MSP[N] Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[InlineConstantMutator]MSP[N] } }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI3Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
printWrapped ( pw , width , 0 , text ) ; MST[rv.CRCR5Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR3Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; } public String getNewLine () { return defaultNewLine ; MST[ReturnValsMutator]MSP[N] } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
} return s . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI3Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR3Mutator]MSP[N] } }
public void setArgName ( final String name ) { this . defaultArgName = name ; MST[experimental.MemberVariableMutator]MSP[N] } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } } prefixList . add ( optBuf ) ;
if ( startPos + width >= text . length () ) MST[rv.UOI1Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR5Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI1Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR1Mutator]MSP[N] if ( option . getDescription () != null ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.ROR2Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; MST[rv.CRCR3Mutator]MSP[N] final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
return sb ; MST[ReturnValsMutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI3Mutator]MSP[N] } }
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI3Mutator]MSP[S] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[NegateConditionalsMutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( option . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI3Mutator]MSP[N] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
this . optionComparator = comparator ; MST[experimental.MemberVariableMutator]MSP[N] } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; MST[NullReturnValsMutator]MSP[N] } public void setOptionComparator ( final Comparator < Option > comparator ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[N] }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[InlineConstantMutator]MSP[N] }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[VoidMethodCallMutator]MSP[N] }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[InlineConstantMutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; MST[rv.UOI2Mutator]MSP[N] } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( startPos + width >= text . length () ) MST[NonVoidMethodCallMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[MathMutator]MSP[N]
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[rv.UOI3Mutator]MSP[N]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI3Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[VoidMethodCallMutator]MSP[N] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( optBuf . length () < max ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI1Mutator]MSP[N] if ( optBuf . length () < max ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; MST[rv.UOI3Mutator]MSP[S] } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR1Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.ABSMutator]MSP[N] if ( option . getDescription () != null ) {
while ( ( line = in . readLine () ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[S] } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; } public String getLongOptSeparator () { return longOptSeparator ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI4Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR6Mutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[N] }
if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; MST[rv.UOI2Mutator]MSP[S] } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[S] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[NegateConditionalsMutator]MSP[N] {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR3Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI2Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.UOI3Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group != null ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR1Mutator]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[N] }
printWrapped ( pw , width , 0 , text ) ; MST[rv.ABSMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR2Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; MST[ConstructorCallMutator]MSP[N] if ( getOptionComparator () != null ) {
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR6Mutator]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR3Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } if ( ! required ) { buff . append ( lr_5 ) ; } }
return sb ; MST[NullReturnValsMutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.UOI2Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { sb . append ( rtrim ( text ) ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[rv.ROR5Mutator]MSP[N] { -- pos ;
final String lpad = createPadding ( leftPad ) ; MST[rv.UOI3Mutator]MSP[N] final String dpad = createPadding ( descPad ) ; int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( footer != null && footer . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ABSMutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.ABSMutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[rv.ROR5Mutator]MSP[N] {
if ( getOptionComparator () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI3Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR6Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( startPos + width >= text . length () ) MST[rv.AOR2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[NegateConditionalsMutator]MSP[N] {
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N]
printWrapped ( pw , width , 0 , text ) ; MST[rv.UOI2Mutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR1Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD1Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( s == null || s . length () == 0 ) { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) MST[NegateConditionalsMutator]MSP[N] { -- pos ;
if ( footer != null && footer . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.UOI2Mutator]MSP[N] if ( optBuf . length () < max ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[rv.UOI2Mutator]MSP[N] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.CRCR5Mutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[N] { return pos + 1 ; }
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.ABSMutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR2Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI3Mutator]MSP[N] } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI1Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( argName != null && argName . length () == 0 ) MST[rv.ROR2Mutator]MSP[S] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[rv.UOI3Mutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR6Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
if ( s == null || s . length () == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.UOI2Mutator]MSP[N]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.ABSMutator]MSP[N] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR6Mutator]MSP[S]
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.UOI2Mutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR2Mutator]MSP[S] { return pos + 1 ; }
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR1Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
if ( startPos + width >= text . length () ) MST[rv.ABSMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
public void setLongOptPrefix ( final String prefix ) { this . defaultLongOptPrefix = prefix ; } public String getLongOptPrefix () { return defaultLongOptPrefix ; } public void setLongOptSeparator ( final String longOptSeparator ) { this . longOptSeparator = longOptSeparator ; MST[experimental.MemberVariableMutator]MSP[N] } public String getLongOptSeparator () { return longOptSeparator ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[rv.ROR1Mutator]MSP[S]
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOR2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.UOI3Mutator]MSP[N] {
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; MST[rv.CRCR3Mutator]MSP[N] return new String ( padding ) ; } protected String rtrim ( final String s ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[rv.CRCR4Mutator]MSP[N]
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) MST[rv.ROR5Mutator]MSP[N] {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI1Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOD2Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[NegateConditionalsMutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( option . getOpt () != null ) {
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[InlineConstantMutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR1Mutator]MSP[S] }
final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; MST[rv.ABSMutator]MSP[N] int max = 0 ; final List < StringBuffer > prefixList = new ArrayList < StringBuffer > () ; final List < Option > optList = options . helpOptions () ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR4Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI4Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.ABSMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
protected StringBuffer renderWrappedText ( final StringBuffer sb , final int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ;
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
optBuf . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
} return s . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR1Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR5Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[InlineConstantMutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.CRCR1Mutator]MSP[N] } }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; MST[rv.UOI3Mutator]MSP[N] } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR3Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[NonVoidMethodCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI1Mutator]MSP[N] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.AOR4Mutator]MSP[N] if ( option . getDescription () != null ) {
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] {
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; if ( optBuf . length () < max ) MST[rv.ROR4Mutator]MSP[N] {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; MST[rv.UOI2Mutator]MSP[N] if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
} return s . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( option . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; MST[rv.UOI3Mutator]MSP[S] } public int getLeftPadding () { return defaultLeftPad ; }
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[VoidMethodCallMutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOR3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[N] { return pos + 1 ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.ABSMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[rv.CRCR1Mutator]MSP[S] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI2Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; MST[rv.UOI4Mutator]MSP[S] } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI4Mutator]MSP[N] }
if ( s == null || s . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( ! processedGroups . contains ( group ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; MST[rv.CRCR3Mutator]MSP[S] } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( pos != - 1 && pos <= width ) MST[rv.ABSMutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR4Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { appendOption ( buff , it . next () , true ) ; MST[InlineConstantMutator]MSP[N]
final Option option = it . next () ; final StringBuilder optBuf = new StringBuilder ( prefixList . get ( x ++ ) . toString () ) ; MST[rv.ABSMutator]MSP[N] if ( optBuf . length () < max ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI4Mutator]MSP[N] }
this . optionComparator = comparator ; } public void printHelp ( final String cmdLineSyntax , final Options options ) { printHelp ( getWidth () , cmdLineSyntax , null , options , null , false ) ; MST[VoidMethodCallMutator]MSP[N] }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; MST[ReturnValsMutator]MSP[N] } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[ConstructorCallMutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR5Mutator]MSP[N] { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
public void setNewLine ( final String newline ) { this . defaultNewLine = newline ; MST[experimental.MemberVariableMutator]MSP[N] } public String getNewLine () { return defaultNewLine ; } public void setOptPrefix ( final String prefix ) { this . defaultOptPrefix = prefix ; } public String getOptPrefix () { return defaultOptPrefix ; }
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR2Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( s == null || s . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_5 ) ; } }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
} if ( header != null && header . trim () . length () > 0 ) MST[NonVoidMethodCallMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ABSMutator]MSP[N] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( startPos + width >= text . length () ) MST[rv.AOD2Mutator]MSP[S] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ; MST[NonVoidMethodCallMutator]MSP[N]
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
if ( argName != null && argName . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.UOI2Mutator]MSP[N] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[rv.ROR5Mutator]MSP[N] {
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI3Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.UOI4Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI1Mutator]MSP[N] }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI1Mutator]MSP[N] }
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buff . append ( lr_5 ) ; } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( footer != null && footer . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , footer ) ; } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI3Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ABSMutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! processedGroups . contains ( group ) ) MST[NegateConditionalsMutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; MST[experimental.NakedReceiverMutator]MSP[N] final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; MST[rv.UOI2Mutator]MSP[N] } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
protected String createPadding ( final int len ) { final char [] padding = new char [ len ] ; Arrays . fill ( padding , ' ' ) ; return new String ( padding ) ; MST[ReturnValsMutator]MSP[N] } protected String rtrim ( final String s ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.UOI1Mutator]MSP[N] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[NonVoidMethodCallMutator]MSP[S] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( argName != null && argName . length () == 0 ) { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ; MST[NegateConditionalsMutator]MSP[S]
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR4Mutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.ABSMutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
if ( startPos + width >= text . length () ) MST[rv.UOI2Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } prefixList . add ( optBuf ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.UOI1Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[rv.UOI3Mutator]MSP[N] if ( option . getDescription () != null ) {
if ( startPos + width >= text . length () ) MST[rv.AOR3Mutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
printWrapped ( pw , width , 0 , text ) ; MST[VoidMethodCallMutator]MSP[N] } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[rv.UOI1Mutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
if ( option . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
public void setDescPadding ( final int padding ) { this . defaultDescPad = padding ; } public int getDescPadding () { return defaultDescPad ; } public void setSyntaxPrefix ( final String prefix ) { this . defaultSyntaxPrefix = prefix ; MST[experimental.MemberVariableMutator]MSP[S] } public String getSyntaxPrefix () { return defaultSyntaxPrefix ; }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
optBuf . append ( lr_8 ) . append ( argName != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[NegateConditionalsMutator]MSP[N] } } prefixList . add ( optBuf ) ;
while ( ( line = in . readLine () ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
printHelp ( pw , width , cmdLineSyntax , header , options , getLeftPadding () , getDescPadding () , footer , autoUsage ) ; MST[rv.UOI3Mutator]MSP[S] pw . flush () ; } public void printHelp ( final PrintWriter pw , final int width , final String cmdLineSyntax ,
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.UOI3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[ConditionalsBoundaryMutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR1Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[NegateConditionalsMutator]MSP[S] { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.UOI4Mutator]MSP[S] { return pos + 1 ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( ! required ) { buff . append ( lr_5 ) ; } }
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; MST[NonVoidMethodCallMutator]MSP[N] return sb ; }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI4Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( ! processedGroups . contains ( group ) ) { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
if ( argName != null && argName . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] { optBuf . append ( ' ' ) ; } else { optBuf . append ( option . hasLongOpt () ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.UOI1Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
if ( s == null || s . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[ArgumentPropagationMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( getNewLine () ) ; } } return sb ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
} if ( header != null && header . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[IncrementsMutator]MSP[N] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[VoidMethodCallMutator]MSP[N]
if ( pos != - 1 && pos <= width ) MST[rv.UOI2Mutator]MSP[S] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
final StringBuffer sb = new StringBuffer () ; renderOptions ( sb , width , options , leftPad , descPad ) ; MST[ArgumentPropagationMutator]MSP[N] pw . println ( sb . toString () ) ; } public void printWrapped ( final PrintWriter pw , final int width , final String text ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.ABSMutator]MSP[N] }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.CRCR3Mutator]MSP[N]
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N]
renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; MST[rv.UOI2Mutator]MSP[N] pw . println ( sb . toString () ) ; } protected StringBuffer renderOptions ( final StringBuffer sb , final int width , final Options options , final int leftPad , final int descPad ) {
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI4Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
final String header , final Options options , final int leftPad , final int descPad , final String footer ) { printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , false ) ; MST[rv.UOI1Mutator]MSP[N] }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { return pos + 1 ; }
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.UOI1Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) MST[rv.UOI2Mutator]MSP[N] { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; MST[rv.UOI3Mutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final char c = text . charAt ( pos ) ;
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.CRCR4Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.CRCR2Mutator]MSP[S]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[rv.ROR5Mutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.UOI3Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) { buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.AOD2Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void printUsage ( final PrintWriter pw , final int width , final String cmdLineSyntax ) { final int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ; MST[rv.AOR1Mutator]MSP[N]
max = optBuf . length () > max ? optBuf . length () : max ; } int x = 0 ; MST[rv.CRCR1Mutator]MSP[N] for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOD1Mutator]MSP[S] }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[rv.AOR2Mutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { final String argName = option . getArgName () ;
final List < Option > optList = new ArrayList < Option > ( options . getOptions () ) ; if ( getOptionComparator () != null ) MST[NonVoidMethodCallMutator]MSP[N] { Collections . sort ( optList , getOptionComparator () ) ; }
if ( text . length () > width && pos == nextLineTabStop - 1 ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[ArgumentPropagationMutator]MSP[N] } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI2Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
} if ( header != null && header . trim () . length () > 0 ) MST[rv.ROR5Mutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) {
if ( ! group . isRequired () ) { buff . append ( lr_3 ) ; } final List < Option > optList = new ArrayList < Option > ( group . getOptions () ) ; if ( getOptionComparator () != null ) MST[NegateConditionalsMutator]MSP[N] {
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.ROR3Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( ! processedGroups . contains ( group ) ) MST[rv.ROR5Mutator]MSP[N] { processedGroups . add ( group ) ; appendOptionGroup ( buff , group ) ; } } else { appendOption ( buff , option , option . isRequired () ) ; } if ( it . hasNext () ) {
optBuf . append ( lpad ) . append ( lr_10 ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { optBuf . append ( lpad ) . append ( getOptPrefix () ) . append ( option . getOpt () ) ;
if ( startPos + width >= text . length () ) MST[ConditionalsBoundaryMutator]MSP[N] { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) { final char c = text . charAt ( pos ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[rv.UOI2Mutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; if ( nextLineTabStop >= width ) MST[rv.UOI4Mutator]MSP[N] { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( footer != null && footer . trim () . length () > 0 ) { printWrapped ( pw , width , footer ) ; MST[rv.UOI3Mutator]MSP[N] } } public void printUsage ( final PrintWriter pw , final int width , final String app , final Options options ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.CRCR4Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
private void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) MST[rv.ROR4Mutator]MSP[N] { buff . append ( lr_3 ) ; } if ( option . getOpt () != null ) {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[InlineConstantMutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI3Mutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.UOI1Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.UOI4Mutator]MSP[N]
if ( startPos + width >= text . length () ) { return - 1 ; } for ( pos = startPos + width ; pos >= startPos ; -- pos ) MST[rv.ROR4Mutator]MSP[N] { final char c = text . charAt ( pos ) ;
public void setWidth ( final int width ) { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; MST[rv.UOI4Mutator]MSP[S] } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
} return s . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
buff . append ( lr_8 ) . append ( option . getArgName () != null ? option . getArgName () : getArgName () ) . append ( lr_9 ) ; } if ( ! required ) MST[rv.ROR2Mutator]MSP[N] { buff . append ( lr_5 ) ; } }
for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NonVoidMethodCallMutator]MSP[N] { final Option option = it . next () ; final OptionGroup group = options . getOptionGroup ( option ) ; if ( group != null ) {
buff . append ( lr_2 ) ; } } printWrapped ( pw , width , buff . toString () . indexOf ( ' ' ) + 1 , buff . toString () ) ; MST[rv.AOR3Mutator]MSP[S] } private void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
} if ( header != null && header . trim () . length () > 0 ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; MST[rv.ABSMutator]MSP[N]
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; } public Comparator < Option > getOptionComparator () { return optionComparator ; MST[ReturnValsMutator]MSP[N] } public void setOptionComparator ( final Comparator < Option > comparator ) {
} return s . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; }
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; if ( option . getDescription () != null ) {
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; if ( option . getOpt () == null ) MST[NegateConditionalsMutator]MSP[N] {
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; MST[rv.CRCR6Mutator]MSP[S] if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; MST[rv.CRCR5Mutator]MSP[N] } } if ( option . hasArg () ) { final String argName = option . getArgName () ;
if ( text . length () > width && pos == nextLineTabStop - 1 ) MST[rv.ROR4Mutator]MSP[N] { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; } }
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) MST[rv.ROR2Mutator]MSP[N] { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( nextLineTabStop >= width ) { nextLineTabStop = 1 ; } final String padding = createPadding ( nextLineTabStop ) ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
public void setArgName ( final String name ) { this . defaultArgName = name ; } public String getArgName () { return defaultArgName ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Comparator < Option > getOptionComparator () { return optionComparator ; } public void setOptionComparator ( final Comparator < Option > comparator ) {
buff . append ( lr_6 ) . append ( option . getOpt () ) ; } else { buff . append ( lr_7 ) . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
catch ( final IOException e ) { } return sb ; } protected int findWrapPos ( final String text , final int width , final int startPos ) { int pos = text . indexOf ( '\n' , startPos ) ; MST[rv.ABSMutator]MSP[N]
if ( s == null || s . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return s ; } int pos = s . length () ; while ( pos > 0 && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { -- pos ;
optBuf . append ( createPadding ( max - optBuf . length () ) ) ; } optBuf . append ( dpad ) ; final int nextLineTabStop = max + descPad ; MST[MathMutator]MSP[N] if ( option . getDescription () != null ) {
if ( it . hasNext () ) { buff . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } if ( ! group . isRequired () ) { buff . append ( lr_5 ) ; } }
optBuf . append ( option . getDescription () ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString () ) ; MST[rv.UOI3Mutator]MSP[N] if ( it . hasNext () ) { sb . append ( getNewLine () ) ; } } return sb ; }
public void setWidth ( final int width ) MST[experimental.MemberVariableMutator]MSP[N] { this . defaultWidth = width ; } public int getWidth () { return defaultWidth ; } public void setLeftPadding ( final int padding ) { this . defaultLeftPad = padding ; } public int getLeftPadding () { return defaultLeftPad ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.AOR2Mutator]MSP[S] } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; MST[rv.UOI4Mutator]MSP[S] }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.ROR1Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) MST[rv.ROR4Mutator]MSP[N] { sb . append ( text ) ; return sb ; }
printWrapped ( pw , width , 0 , text ) ; } public void printWrapped ( final PrintWriter pw , final int width , final int nextLineTabStop , final String text ) { final StringBuffer sb = new StringBuffer ( text . length () ) ; MST[ConstructorCallMutator]MSP[N]
Collections . sort ( optList , getOptionComparator () ) ; } for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) MST[NegateConditionalsMutator]MSP[N] { appendOption ( buff , it . next () , true ) ;
if ( pos != - 1 && pos <= width ) { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) MST[rv.ROR4Mutator]MSP[S] { return pos + 1 ; }
} if ( header != null && header . trim () . length () > 0 ) MST[NegateConditionalsMutator]MSP[N] { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;
if ( option . hasLongOpt () ) { optBuf . append ( ',' ) . append ( getLongOptPrefix () ) . append ( option . getLongOpt () ) ; } } if ( option . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { final String argName = option . getArgName () ;
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR4Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; MST[rv.UOI4Mutator]MSP[N] }
if ( c == ' ' || c == '\n' || c == '\r' ) MST[rv.CRCR2Mutator]MSP[N] { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; return pos == text . length () ? - 1 : pos ; }
max = optBuf . length () > max ? optBuf . length () : max ; MST[rv.UOI1Mutator]MSP[N] } int x = 0 ; for ( final Iterator < Option > it = optList . iterator () ; it . hasNext () ; ) {
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[rv.ROR1Mutator]MSP[N] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( cmdLineSyntax == null || cmdLineSyntax . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_1 ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ;
final StringBuffer buff = new StringBuffer ( getSyntaxPrefix () ) . append ( app ) . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Collection < OptionGroup > processedGroups = new ArrayList < OptionGroup > () ;
while ( ( line = in . readLine () ) != null ) { if ( ! firstLine ) { sb . append ( getNewLine () ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } }
if ( c == ' ' || c == '\n' || c == '\r' ) { break; } } if ( pos > startPos ) { return pos ; } pos = startPos + width ; MST[rv.AOD2Mutator]MSP[N] return pos == text . length () ? - 1 : pos ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ;
if ( pos != - 1 && pos <= width ) MST[rv.UOI1Mutator]MSP[N] { return pos + 1 ; } pos = text . indexOf ( '\t' , startPos ) ; if ( pos != - 1 && pos <= width ) { return pos + 1 ; }
if ( option . hasArg () && ( option . getArgName () == null || option . getArgName () . length () != 0 ) ) { buff . append ( option . getOpt () == null ? longOptSeparator : lr_2 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
printWrapped ( pw , width , getSyntaxPrefix () . length () + argPos , getSyntaxPrefix () + cmdLineSyntax ) ; MST[rv.AOD2Mutator]MSP[N] } public void printOptions ( final PrintWriter pw , final int width , final Options options , final int leftPad , final int descPad ) {
while ( true ) { text = padding + text . substring ( pos ) . trim () ; MST[NonVoidMethodCallMutator]MSP[N] pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; }
if ( getOptionComparator () != null ) { Collections . sort ( optList , getOptionComparator () ) ; } for ( final Option option : optList ) { final StringBuffer optBuf = new StringBuffer () ; MST[ConstructorCallMutator]MSP[N] if ( option . getOpt () == null ) {
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[ReturnValsMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[PrimitiveReturnsMutator]MSP[N] }
} return s . substring ( 0 , pos ) ; } public int compare ( final Option opt1 , final Option opt2 ) { return opt1 . getKey () . compareToIgnoreCase ( opt2 . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_5 ) ; } } return buf . toString () ; }
buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S]
public List getMissingOptions () { return missingOptions ; MST[EmptyObjectReturnValsMutator]MSP[N] } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[NegateConditionalsMutator]MSP[N]
buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
buf . append ( lr_5 ) ; } } return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR6Mutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } return buf . toString () ; }
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR2Mutator]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR3Mutator]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR4Mutator]MSP[S]
buf . append ( lr_5 ) ; } } return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR2Mutator]MSP[N]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR1Mutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR5Mutator]MSP[N]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR4Mutator]MSP[S]
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.ROR3Mutator]MSP[N]
buf . append ( lr_5 ) ; } } return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return buf . toString () ; }
public List getMissingOptions () { return missingOptions ; MST[ReturnValsMutator]MSP[S] } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[S] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[S] {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[rv.CRCR5Mutator]MSP[N]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ; MST[InlineConstantMutator]MSP[S]
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( it . hasNext () ) { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public List getMissingOptions () { return missingOptions ; } private static String createMessage ( final List < ? > missingOptions ) { final StringBuilder buf = new StringBuilder ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] buf . append ( missingOptions . size () == 1 ? lr_2 : lr_3 ) ;
buf . append ( lr_4 ) ; final Iterator < ? > it = missingOptions . iterator () ; while ( it . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( it . next () ) ; if ( it . hasNext () ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; }
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; } @Override public String toString () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void clearValues () { values . clear () ; } @Deprecated public boolean addValue ( final String value ) { throw new UnsupportedOperationException ( lr_10 + lr_11 ) ; } boolean acceptsArg () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[NegateConditionalsMutator]MSP[S] } public String [] getValues () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[InlineConstantMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[NegateConditionalsMutator]MSP[S] {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[ReturnValsMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR3Mutator]MSP[N] { final char sep = getValueSeparator () ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[S] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.ABSMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR3Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR6Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; MST[NonVoidMethodCallMutator]MSP[S] return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[S] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI3Mutator]MSP[S] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[NonVoidMethodCallMutator]MSP[N] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI4Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[InlineConstantMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR2Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[S] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI2Mutator]MSP[N] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; MST[NonVoidMethodCallMutator]MSP[N] option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public String [] getValues () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[S] } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[InlineConstantMutator]MSP[N]
return result ; MST[rv.UOI4Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR2Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR5Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NonVoidMethodCallMutator]MSP[N] {
return result ; MST[ReturnValsMutator]MSP[S] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return result ; MST[rv.UOI1Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
buf . append ( lr_7 ) . append ( type ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
int index = value . indexOf ( sep ) ; MST[ArgumentPropagationMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI1Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
return hasNoValues () ? null : values . get ( index ) ; MST[ReturnValsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI4Mutator]MSP[N]
return hasNoValues () ? null : values . get ( index ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR3Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[rv.ROR5Mutator]MSP[S] } public String [] getValues () {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return values . isEmpty () ; MST[ReturnValsMutator]MSP[N] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR5Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; MST[ConditionalsBoundaryMutator]MSP[S] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[VoidMethodCallMutator]MSP[N]
value = value . substring ( index + 1 ) ; MST[rv.UOI1Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR4Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR3Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[NonVoidMethodCallMutator]MSP[N] { final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR3Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return values . isEmpty () ; } return acceptsArg () ; MST[BooleanTrueReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; MST[experimental.MemberVariableMutator]MSP[N] } public String getArgName () { return argName ; } public boolean hasArgName ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[BooleanTrueReturnValsMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR3Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR4Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR2Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_4 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI3Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
if ( hasArgs () ) MST[rv.ROR3Mutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; MST[experimental.NakedReceiverMutator]MSP[S] return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . get ( index ) ; MST[NegateConditionalsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NegateConditionalsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[InlineConstantMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR3Mutator]MSP[S] {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[NonVoidMethodCallMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[ReturnValsMutator]MSP[N] }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; MST[ConstructorCallMutator]MSP[N] return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; MST[rv.CRCR4Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[InlineConstantMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR5Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NullReturnValsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD1Mutator]MSP[S]
if ( this == o ) { return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; MST[ReturnValsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI1Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR2Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
{ return argName != null && argName . length () > 0 ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR2Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[S] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; MST[VoidMethodCallMutator]MSP[N] } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; MST[rv.CRCR3Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[NegateConditionalsMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR3Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[ReturnValsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; MST[rv.UOI4Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[ConstructorCallMutator]MSP[S] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return false ; } return true ; MST[ReturnValsMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final char sep = getValueSeparator () ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[experimental.MemberVariableMutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; MST[rv.AOD2Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[NonVoidMethodCallMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; MST[ReturnValsMutator]MSP[N] } public boolean hasArgName ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NegateConditionalsMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI4Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
public int getId () { return getKey () . charAt ( 0 ) ; MST[ReturnValsMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR5Mutator]MSP[N]
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[NegateConditionalsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD1Mutator]MSP[S]
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ABSMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[rv.CRCR5Mutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR1Mutator]MSP[N] { final char sep = getValueSeparator () ;
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI4Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR5Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR6Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.ABSMutator]MSP[N]
{ return argName != null && argName . length () > 0 ; MST[rv.ROR2Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR1Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return values . isEmpty () ; } return acceptsArg () ; MST[ReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[rv.ROR5Mutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR2Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[rv.ROR4Mutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[S] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI4Mutator]MSP[N] }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } final Option option = ( Option ) o ;
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[ReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[S] } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; MST[NegateConditionalsMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR4Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return longOpt != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.ABSMutator]MSP[N]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI3Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return hasNoValues () ? null : values . get ( index ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[NegateConditionalsMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; MST[ReturnValsMutator]MSP[N] } public Object getType () { return type ; } @Deprecated
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ABSMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOD2Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR4Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[NegateConditionalsMutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI1Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR2Mutator]MSP[S] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR3Mutator]MSP[S]
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR2Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR4Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR4Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
if ( hasArgs () ) MST[NonVoidMethodCallMutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI4Mutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR5Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[ReturnValsMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR5Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
buf . append ( lr_7 ) . append ( type ) ; MST[experimental.NakedReceiverMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[NonVoidMethodCallMutator]MSP[S] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.ROR5Mutator]MSP[N]
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI1Mutator]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[NegateConditionalsMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI3Mutator]MSP[N]
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[experimental.NakedReceiverMutator]MSP[S] if ( type != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( type != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR3Mutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[ConditionalsBoundaryMutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public int getArgs () { return numberOfArgs ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) MST[rv.ROR1Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
return values . isEmpty () ; } return acceptsArg () ; MST[BooleanFalseReturnValsMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; MST[experimental.MemberVariableMutator]MSP[N] } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; MST[ReturnValsMutator]MSP[N] } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR5Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return result ; MST[PrimitiveReturnsMutator]MSP[S] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI4Mutator]MSP[S] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ReturnValsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[S] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR2Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
buf . append ( lr_7 ) . append ( type ) ; MST[NonVoidMethodCallMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return longOpt != null ; MST[rv.CRCR2Mutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR1Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR6Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[ReturnValsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR1Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return result ; MST[rv.UOI2Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ABSMutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI3Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR1Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; MST[ReturnValsMutator]MSP[N] } @Deprecated
public int getId () { return getKey () . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[InlineConstantMutator]MSP[N]
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[ReturnValsMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[S] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
int index = value . indexOf ( sep ) ; MST[rv.UOI2Mutator]MSP[S] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR2Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR1Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR4Mutator]MSP[N] {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[NegateConditionalsMutator]MSP[N] {
return values . isEmpty () ; } return acceptsArg () ; MST[NonVoidMethodCallMutator]MSP[N] } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; MST[rv.ROR5Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; MST[ReturnValsMutator]MSP[N] } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; MST[experimental.MemberVariableMutator]MSP[N] } public boolean isRequired ()
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[NullReturnValsMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
value = value . substring ( index + 1 ) ; MST[rv.UOI2Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; MST[EmptyObjectReturnValsMutator]MSP[S] } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
if ( this == o ) { return true ; MST[rv.CRCR6Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR5Mutator]MSP[S] {
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[ReturnValsMutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR5Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[experimental.NakedReceiverMutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI2Mutator]MSP[N] }
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; MST[VoidMethodCallMutator]MSP[N] } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[experimental.MemberVariableMutator]MSP[N] }
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.ABSMutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[MathMutator]MSP[N]
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
public int getId () { return getKey () . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR4Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR3Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI4Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[S] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[ReturnValsMutator]MSP[N] } final Option option = ( Option ) o ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR4Mutator]MSP[S] {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[rv.ROR5Mutator]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.ABSMutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR3Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR1Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void clearValues () { values . clear () ; } @Deprecated public boolean addValue ( final String value ) { throw new UnsupportedOperationException ( lr_10 MST[ConstructorCallMutator]MSP[S] + lr_11 ) ; } boolean acceptsArg () {
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; MST[experimental.MemberVariableMutator]MSP[S] } public String getLongOpt () { return longOpt ; }
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[N] } @Override public boolean equals ( final Object o ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[InlineConstantMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR4Mutator]MSP[N] {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI2Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[InlineConstantMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR3Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR1Mutator]MSP[N]
if ( this == o ) { return true ; MST[ReturnValsMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Object getType () { return type ; } @Deprecated
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR6Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; MST[InlineConstantMutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[ReturnValsMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[NonVoidMethodCallMutator]MSP[S]
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR6Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
if ( this == o ) MST[rv.ROR5Mutator]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[BooleanTrueReturnValsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
{ return required ; MST[ReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.CRCR3Mutator]MSP[S] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD2Mutator]MSP[S]
if ( this == o ) { return true ; MST[rv.CRCR5Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[InlineConstantMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[NegateConditionalsMutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder type ( final Class < ? > type ) { this . type = type ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[PrimitiveReturnsMutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.ABSMutator]MSP[N] }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR3Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI1Mutator]MSP[N] }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
throw new RuntimeException ( lr_2 ) ; MST[ConstructorCallMutator]MSP[N] } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; } public String getValue ( final int index ) throws IndexOutOfBoundsException {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI4Mutator]MSP[S] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[S] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( this == o ) { return true ; MST[rv.CRCR2Mutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
value = value . substring ( index + 1 ) ; MST[rv.CRCR5Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; MST[experimental.NakedReceiverMutator]MSP[N] option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[NegateConditionalsMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR4Mutator]MSP[N]
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; MST[EmptyObjectReturnValsMutator]MSP[N] } public boolean hasArgName ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI3Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[ReturnValsMutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR1Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
value = value . substring ( index + 1 ) ; MST[rv.ABSMutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR4Mutator]MSP[N]
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR1Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
buf . append ( lr_7 ) . append ( type ) ; } buf . append ( lr_8 ) ; MST[NonVoidMethodCallMutator]MSP[S] return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; MST[rv.CRCR1Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR5Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[experimental.NakedReceiverMutator]MSP[S] } buf . append ( lr_4 ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR1Mutator]MSP[S]
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[ReturnValsMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( this == o ) { return true ; MST[InlineConstantMutator]MSP[N] } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ; MST[NonVoidMethodCallMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR1Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) MST[NegateConditionalsMutator]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR2Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return values . isEmpty () ; MST[NonVoidMethodCallMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI3Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } final Option option = ( Option ) o ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[NonVoidMethodCallMutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR4Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[ConditionalsBoundaryMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ConditionalsBoundaryMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOD2Mutator]MSP[S]
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR4Mutator]MSP[N] { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[NegateConditionalsMutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
int index = value . indexOf ( sep ) ; MST[rv.ABSMutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return false ; MST[InlineConstantMutator]MSP[S] } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[InlineConstantMutator]MSP[S] {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR3Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR5Mutator]MSP[N] {
if ( this == o ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; } final Option option = ( Option ) o ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[rv.ROR3Mutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI1Mutator]MSP[S] {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[InlineConstantMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR5Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR4Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return values . isEmpty () ; MST[BooleanFalseReturnValsMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR1Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR4Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR4Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; } public boolean hasOptionalArg () { return optionalArg ; MST[BooleanTrueReturnValsMutator]MSP[N] } public boolean hasLongOpt () {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR2Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
throw new RuntimeException ( lr_9 + cnse . getMessage () ) ; } } void clearValues () { values . clear () ; MST[VoidMethodCallMutator]MSP[S] } @Deprecated public boolean addValue ( final String value ) { throw new UnsupportedOperationException ( lr_10 + lr_11 ) ; } boolean acceptsArg () {
{ return argName != null && argName . length () > 0 ; MST[InlineConstantMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI3Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ABSMutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR2Mutator]MSP[S] {
{ return argName != null && argName . length () > 0 ; MST[rv.ROR4Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public int getId () { return getKey () . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[NegateConditionalsMutator]MSP[S] {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[ConditionalsBoundaryMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.UOI2Mutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR5Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] return this ; } public Option build () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; MST[rv.CRCR4Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[N] } buf . append ( lr_4 ) ;
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[InlineConstantMutator]MSP[N] } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR5Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public Builder required () { return required ( true ) ; MST[InlineConstantMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOD1Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ABSMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[ArgumentPropagationMutator]MSP[N] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.UOI2Mutator]MSP[N]
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[InlineConstantMutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.ROR1Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } final Option option = ( Option ) o ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR2Mutator]MSP[S]
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[rv.ROR2Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR4Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.ROR3Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR1Mutator]MSP[N]
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[NullReturnValsMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NegateConditionalsMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR5Mutator]MSP[N] { final char sep = getValueSeparator () ;
return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR6Mutator]MSP[S] {
return values . isEmpty () ; MST[BooleanTrueReturnValsMutator]MSP[S] } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[rv.ROR5Mutator]MSP[N] {
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( type != null ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[ReturnValsMutator]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
{ return argName != null && argName . length () > 0 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.UOI1Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR3Mutator]MSP[N] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR1Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder hasArg () { return hasArg ( true ) ; }
value = value . substring ( index + 1 ) ; MST[rv.UOI3Mutator]MSP[N] index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[NegateConditionalsMutator]MSP[N] { final char sep = getValueSeparator () ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return longOpt != null ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR6Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; }
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR2Mutator]MSP[S]
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR3Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR6Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.CRCR5Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[S] buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) MST[rv.ROR5Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI2Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[NegateConditionalsMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.ABSMutator]MSP[N] return this ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[S]
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[InlineConstantMutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
{ return required ; MST[BooleanTrueReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR4Mutator]MSP[N] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR2Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
{ return argName != null && argName . length () > 0 ; MST[InlineConstantMutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.CRCR1Mutator]MSP[S] {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR3Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[rv.ROR5Mutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.UOI1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
return result ; MST[rv.ABSMutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
public int getId () { return getKey () . charAt ( 0 ) ; MST[PrimitiveReturnsMutator]MSP[N] } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[ConditionalsBoundaryMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return values . isEmpty () ; } return acceptsArg () ; } public static Builder builder () { return builder ( null ) ; } public static Builder builder ( final String opt ) { return new Builder ( opt ) ; MST[ConstructorCallMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[NegateConditionalsMutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
if ( opt == null && longOpt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) MST[rv.ROR2Mutator]MSP[N] { final char sep = getValueSeparator () ;
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; } public List < String > getValuesList () { return values ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String toString () {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; MST[rv.UOI3Mutator]MSP[N] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ROR5Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[EmptyObjectReturnValsMutator]MSP[S] } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR5Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; MST[VoidMethodCallMutator]MSP[N] } private void add ( final String value ) { if ( ! acceptsArg () ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.UOI1Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; MST[ReturnValsMutator]MSP[N] } public String getOpt () { return opt ; } public Object getType () { return type ; } @Deprecated
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return required ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[MathMutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NegateConditionalsMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder type ( final Class < ? > type ) { this . type = type ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI3Mutator]MSP[N] }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR2Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; MST[rv.ABSMutator]MSP[S] } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.AOR2Mutator]MSP[N]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) MST[rv.ROR3Mutator]MSP[N] { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
if ( hasArgs () ) MST[rv.ROR5Mutator]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
void addValueForProcessing ( final String value ) { if ( numberOfArgs == UNINITIALIZED ) MST[rv.CRCR1Mutator]MSP[N] { throw new RuntimeException ( lr_1 ) ; } processValue ( value ) ; } private void processValue ( String value ) { if ( hasValueSeparator () ) { final char sep = getValueSeparator () ;
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; MST[ReturnValsMutator]MSP[N] }
return longOpt != null ; MST[rv.CRCR3Mutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR6Mutator]MSP[N]
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; MST[rv.UOI1Mutator]MSP[S] }
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI1Mutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[rv.CRCR3Mutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; MST[EmptyObjectReturnValsMutator]MSP[N] }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder longOpt ( final String longOpt ) {
if ( hasArgs () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public void setType ( final Object type ) { setType ( ( Class < ? > ) type ) ; } public void setType ( final Class < ? > type ) { this . type = type ; } public String getLongOpt () { return longOpt ; MST[ReturnValsMutator]MSP[N] }
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.ROR4Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[rv.CRCR6Mutator]MSP[N]
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.AOR2Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
return longOpt != null ; MST[rv.CRCR6Mutator]MSP[S] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.UOI3Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.ROR1Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; MST[rv.UOI1Mutator]MSP[S] while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[NegateConditionalsMutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
buf . append ( lr_7 ) . append ( type ) ; MST[experimental.NakedReceiverMutator]MSP[S] } buf . append ( lr_8 ) ; return buf . toString () ; } private boolean hasNoValues () { return values . isEmpty () ; } @Override public boolean equals ( final Object o ) {
return longOpt != null ; } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; MST[ReturnValsMutator]MSP[N] } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; } private void add ( final String value ) { if ( ! acceptsArg () ) MST[NegateConditionalsMutator]MSP[N] {
public int getId () { return getKey () . charAt ( 0 ) ; } String getKey () { return ( opt == null ) ? longOpt : opt ; } public String getOpt () { return opt ; } public Object getType () { return type ; MST[NullReturnValsMutator]MSP[N] } @Deprecated
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; MST[NullReturnValsMutator]MSP[N] } catch ( final CloneNotSupportedException cnse ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return longOpt != null ; MST[InlineConstantMutator]MSP[N] } public boolean hasArg () { return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES ; } public String getDescription () { return description ; } public void setDescription ( final String description ) { this . description = description ; } public boolean isRequired ()
return result ; MST[rv.UOI3Mutator]MSP[N] } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
throw new RuntimeException ( lr_2 ) ; } values . add ( value ) ; } public String getValue () { return hasNoValues () ? null : values . get ( 0 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public String getValue ( final int index ) throws IndexOutOfBoundsException {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.UOI4Mutator]MSP[N] {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( this == o ) { return true ; } if ( o == null || getClass () != o . getClass () ) MST[NonVoidMethodCallMutator]MSP[N] { return false ; } final Option option = ( Option ) o ;
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.UOI4Mutator]MSP[N] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.CRCR3Mutator]MSP[S] { break; } add ( value . substring ( 0 , index ) ) ;
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[S]
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; MST[InlineConstantMutator]MSP[N] } if ( numberOfArgs == UNLIMITED_VALUES ) {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; MST[rv.ROR5Mutator]MSP[N] result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
return false ; } return true ; MST[InlineConstantMutator]MSP[N] } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ;
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR6Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR2Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; MST[rv.UOI3Mutator]MSP[N] }
return hasNoValues () ? null : values . toArray ( new String [ values . size () ] ) ; MST[rv.ROR4Mutator]MSP[N] } public List < String > getValuesList () { return values ; } @Override public String toString () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
final StringBuilder buf = new StringBuilder () . append ( lr_3 ) ; buf . append ( opt ) ; MST[experimental.NakedReceiverMutator]MSP[N] if ( longOpt != null ) { buf . append ( lr_4 ) . append ( longOpt ) ; } buf . append ( lr_4 ) ;
return result ; } @Override public Object clone () { try { final Option option = ( Option ) super . clone () ; option . values = new ArrayList < String > ( values ) ; MST[experimental.MemberVariableMutator]MSP[N] return option ; } catch ( final CloneNotSupportedException cnse ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[rv.CRCR5Mutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.CRCR5Mutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
return hasNoValues () ? null : values . get ( index ) ; MST[NonVoidMethodCallMutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) MST[rv.ROR4Mutator]MSP[N] { break; } add ( value . substring ( 0 , index ) ) ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) MST[rv.ROR1Mutator]MSP[N] {
return false ; } return true ; } @Override public int hashCode () { int result ; result = opt != null ? opt . hashCode () : 0 ; result = 31 * result + ( longOpt != null ? longOpt . hashCode () : 0 ) ; MST[MathMutator]MSP[N]
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return ( hasArg () || hasArgs () || hasOptionalArg () ) && ( numberOfArgs <= 0 || values . size () < numberOfArgs ) ; MST[NonVoidMethodCallMutator]MSP[N] } boolean requiresArg () { if ( optionalArg ) { return false ; } if ( numberOfArgs == UNLIMITED_VALUES ) {
{ return argName != null && argName . length () > 0 ; MST[rv.CRCR6Mutator]MSP[N] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( type != null ) {
if ( hasArgs () ) { buf . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else if ( hasArg () ) { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
return hasNoValues () ? null : values . get ( index ) ; MST[rv.UOI2Mutator]MSP[N] } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; } public String [] getValues () {
return hasNoValues () ? null : values . get ( index ) ; } public String getValue ( final String defaultValue ) { final String value = getValue () ; return ( value != null ) ? value : defaultValue ; MST[ReturnValsMutator]MSP[N] } public String [] getValues () {
{ return argName != null && argName . length () > 0 ; } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; MST[rv.ROR3Mutator]MSP[S] } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
{ return argName != null && argName . length () > 0 ; MST[rv.ROR1Mutator]MSP[S] } public boolean hasArgs () { return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES ; } public void setArgs ( final int num ) { this . numberOfArgs = num ; }
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; MST[ReturnValsMutator]MSP[N] } public boolean hasValueSeparator () { return valuesep > 0 ; } public int getArgs () { return numberOfArgs ; }
if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) MST[rv.ROR5Mutator]MSP[N] { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
if ( hasArgs () ) { buf . append ( lr_5 ) ; } else if ( hasArg () ) MST[rv.ROR5Mutator]MSP[N] { buf . append ( lr_6 ) ; } buf . append ( lr_7 ) . append ( description ) ; if ( type != null ) {
public void setValueSeparator ( final char sep ) { this . valuesep = sep ; } public char getValueSeparator () { return valuesep ; } public boolean hasValueSeparator () { return valuesep > 0 ; MST[rv.CRCR1Mutator]MSP[S] } public int getArgs () { return numberOfArgs ; }
int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ; MST[rv.CRCR1Mutator]MSP[N]
public void setLongOpt ( final String longOpt ) { this . longOpt = longOpt ; } public void setOptionalArg ( final boolean optionalArg ) { this . optionalArg = optionalArg ; MST[rv.UOI3Mutator]MSP[N] } public boolean hasOptionalArg () { return optionalArg ; } public boolean hasLongOpt () {
int index = value . indexOf ( sep ) ; while ( index != - 1 ) MST[rv.ABSMutator]MSP[N] { if ( values . size () == numberOfArgs - 1 ) { break; } add ( value . substring ( 0 , index ) ) ;
{ return required ; MST[BooleanFalseReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public void setArgName ( final String argName ) { this . argName = argName ; } public String getArgName () { return argName ; } public boolean hasArgName ()
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[NullReturnValsMutator]MSP[N] }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ; MST[experimental.MemberVariableMutator]MSP[S]
return this ; MST[NullReturnValsMutator]MSP[N] } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR2Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR6Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR3Mutator]MSP[N] }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[rv.ABSMutator]MSP[S] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder required () { return required ( true ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder argName ( final String argName ) { this . argName = argName ; MST[experimental.MemberVariableMutator]MSP[S] return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[NullReturnValsMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[InlineConstantMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder required () { return required ( true ) ; MST[rv.CRCR2Mutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI4Mutator]MSP[N] return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[experimental.NakedReceiverMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[NegateConditionalsMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR6Mutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR5Mutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder required () { return required ( true ) ; MST[rv.CRCR4Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] return this ; } public Option build () {
return this ; MST[ReturnValsMutator]MSP[N] } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[N] return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[experimental.NakedReceiverMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI3Mutator]MSP[N] return this ; }
public Builder required () { return required ( true ) ; MST[rv.CRCR3Mutator]MSP[N] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[NullReturnValsMutator]MSP[N] }
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; MST[ConstructorCallMutator]MSP[S] } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI1Mutator]MSP[N] return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[InlineConstantMutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR3Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder required () { return required ( true ) ; MST[ReturnValsMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR5Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder desc ( final String description ) { this . description = description ; return this ; } public Builder longOpt ( final String longOpt ) {
if ( opt == null && longOpt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; MST[ReturnValsMutator]MSP[N] } public Builder hasArg () { return hasArg ( true ) ; }
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[ConstructorCallMutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR4Mutator]MSP[N] }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[rv.CRCR5Mutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; MST[NullReturnValsMutator]MSP[S] } public Option build () {
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder longOpt ( final String longOpt ) {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[S] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[experimental.MemberVariableMutator]MSP[S] return this ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; MST[ReturnValsMutator]MSP[S] } public Option build () {
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; MST[rv.UOI3Mutator]MSP[N] return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder required () { return required ( true ) ; MST[experimental.NakedReceiverMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
if ( opt == null && longOpt == null ) { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; MST[ReturnValsMutator]MSP[N] }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR2Mutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; MST[NullReturnValsMutator]MSP[N] }
public Builder required () { return required ( true ) ; MST[NullReturnValsMutator]MSP[S] } public Builder required ( final boolean required ) { this . required = required ; return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; MST[ReturnValsMutator]MSP[N] }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; MST[rv.UOI2Mutator]MSP[N] return this ; }
if ( opt == null && longOpt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
this . longOpt = longOpt ; return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
this . longOpt = longOpt ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public Builder numberOfArgs ( final int numberOfArgs ) { this . numberOfArgs = numberOfArgs ; return this ; } public Builder optionalArg ( final boolean isOptional ) { this . optionalArg = isOptional ; return this ; }
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
public Builder hasArg ( final boolean hasArg ) { numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ABSMutator]MSP[N] return this ; } public Builder hasArgs () { numberOfArgs = Option . UNLIMITED_VALUES ; return this ; } public Option build () {
if ( opt == null && longOpt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_12 ) ; } return new Option ( this ) ; }
public Builder argName ( final String argName ) { this . argName = argName ; return this ; } public Builder desc ( final String description ) { this . description = description ; return this ; MST[NullReturnValsMutator]MSP[N] } public Builder longOpt ( final String longOpt ) {
public Builder required () { return required ( true ) ; } public Builder required ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[N] return this ; } public Builder type ( final Class < ? > type ) { this . type = type ;
return this ; } public Builder valueSeparator () { return valueSeparator ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N] } public Builder valueSeparator ( final char sep ) { valuesep = sep ; return this ; } public Builder hasArg () { return hasArg ( true ) ; }
private static void reset () { description = null ; argName = null ; longopt = null ; type = String . class ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
finally { OptionBuilder . reset () ; } return option ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI1Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI4Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI3Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.UOI2Mutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.ABSMutator]MSP[S] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[ReturnValsMutator]MSP[N] }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; MST[VoidMethodCallMutator]MSP[S] option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[InlineConstantMutator]MSP[S]
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ; MST[VoidMethodCallMutator]MSP[S]
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI4Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[ReturnValsMutator]MSP[S] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI3Mutator]MSP[N] return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[InlineConstantMutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI2Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.ABSMutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; MST[VoidMethodCallMutator]MSP[N] option . setArgName ( argName ) ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ; MST[ConstructorCallMutator]MSP[N]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI3Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
finally { OptionBuilder . reset () ; } return option ; MST[ReturnValsMutator]MSP[N] }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR5Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[rv.ABSMutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NullReturnValsMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
finally { OptionBuilder . reset () ; MST[VoidMethodCallMutator]MSP[N] } return option ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[NullReturnValsMutator]MSP[S] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR6Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; MST[VoidMethodCallMutator]MSP[N] option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[NullReturnValsMutator]MSP[S] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI1Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR2Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI4Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; MST[VoidMethodCallMutator]MSP[N] }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { OptionBuilder . reset () ;
finally { OptionBuilder . reset () ; } return option ; MST[NullReturnValsMutator]MSP[N] }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR6Mutator]MSP[S]
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[S] } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR4Mutator]MSP[N]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR5Mutator]MSP[S]
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR3Mutator]MSP[N]
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[NegateConditionalsMutator]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[ReturnValsMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; MST[VoidMethodCallMutator]MSP[N] option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR2Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR6Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR3Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR6Mutator]MSP[S] return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR5Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.ABSMutator]MSP[S] return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR4Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR2Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[NegateConditionalsMutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ABSMutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
throw new IllegalArgumentException ( lr_1 ) ; MST[ConstructorCallMutator]MSP[N] } return create ( null ) ; } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[InlineConstantMutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI1Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder withType ( final Class < ? > newType ) { OptionBuilder . type = newType ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder withDescription ( final String newDescription ) { OptionBuilder . description = newDescription ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.ROR3Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; MST[rv.UOI4Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR4Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; } public static Option create () throws IllegalArgumentException { if ( longopt == null ) MST[rv.ROR5Mutator]MSP[N] { OptionBuilder . reset () ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
option . setLongOpt ( longopt ) ; MST[VoidMethodCallMutator]MSP[S] option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR5Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] }
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[rv.CRCR3Mutator]MSP[N] return INSTANCE ; }
throw new IllegalArgumentException ( lr_1 ) ; } return create ( null ) ; MST[NonVoidMethodCallMutator]MSP[N] } public static Option create ( final String opt ) throws IllegalArgumentException { Option option = null ; try { option = new Option ( opt , description ) ;
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR1Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.ABSMutator]MSP[S] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; }
public static Option create ( final char opt ) throws IllegalArgumentException { return create ( String . valueOf ( opt ) ) ; MST[rv.UOI3Mutator]MSP[N] } public static Option create () throws IllegalArgumentException { if ( longopt == null ) { OptionBuilder . reset () ;
public static OptionBuilder hasOptionalArgs ( final int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; return INSTANCE ; } @Deprecated public static OptionBuilder withType ( final Object newType ) { return withType ( ( Class < ? > ) newType ) ; MST[NonVoidMethodCallMutator]MSP[N] }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] }
OptionBuilder . required = newRequired ; return INSTANCE ; } public static OptionBuilder hasArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; return INSTANCE ; } public static OptionBuilder hasArgs ( final int num ) { OptionBuilder . numberOfArgs = num ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; }
option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; MST[VoidMethodCallMutator]MSP[S] option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.CRCR5Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; MST[rv.CRCR4Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; MST[rv.UOI2Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; MST[rv.CRCR3Mutator]MSP[S] return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR6Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; MST[rv.UOI1Mutator]MSP[N] return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; MST[rv.CRCR4Mutator]MSP[S] OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ; MST[rv.CRCR2Mutator]MSP[S]
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[InlineConstantMutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; MST[rv.CRCR3Mutator]MSP[N] OptionBuilder . optionalArg = true ; return INSTANCE ; }
return INSTANCE ; } public static OptionBuilder withValueSeparator ( final char sep ) { OptionBuilder . valuesep = sep ; return INSTANCE ; } public static OptionBuilder withValueSeparator () { OptionBuilder . valuesep = '=' ; return INSTANCE ; MST[NullReturnValsMutator]MSP[N] } public static OptionBuilder isRequired ( final boolean newRequired ) {
public static OptionBuilder hasOptionalArg () { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; return INSTANCE ; } public static OptionBuilder hasOptionalArgs () { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; MST[InlineConstantMutator]MSP[S] return INSTANCE ; }
OptionBuilder . numberOfArgs = hasArg ? 1 : Option . UNINITIALIZED ; return INSTANCE ; MST[NullReturnValsMutator]MSP[S] } public static OptionBuilder withArgName ( final String name ) { OptionBuilder . argName = name ; return INSTANCE ; } public static OptionBuilder isRequired () { OptionBuilder . required = true ;
public static OptionBuilder withLongOpt ( final String newLongopt ) { OptionBuilder . longopt = newLongopt ; return INSTANCE ; MST[ReturnValsMutator]MSP[N] } public static OptionBuilder hasArg () { OptionBuilder . numberOfArgs = 1 ; return INSTANCE ; } public static OptionBuilder hasArg ( final boolean hasArg ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; }
return optionMap . values () ; MST[ReturnValsMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N] final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; MST[NonVoidMethodCallMutator]MSP[N] } public Collection < Option > getOptions () {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI2Mutator]MSP[N] } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI4Mutator]MSP[S] } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
{ return required ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR5Mutator]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Collection < Option > getOptions () {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( iter . hasNext () ) {
selected = option . getKey () ; MST[experimental.MemberVariableMutator]MSP[N] } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] while ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buff . toString () ; }
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N] } else { buff . append ( lr_3 ) ;
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NonVoidMethodCallMutator]MSP[S] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; MST[ReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N]
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[ReturnValsMutator]MSP[N] }
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NegateConditionalsMutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI1Mutator]MSP[N] } public boolean isRequired ()
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR2Mutator]MSP[N] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.ABSMutator]MSP[N] } public boolean isRequired ()
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; MST[ReturnValsMutator]MSP[S] } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[rv.ROR5Mutator]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[rv.ROR5Mutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
buff . append ( lr_5 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } buff . append ( lr_6 ) ; return buff . toString () ; }
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
selected = option . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
buff . append ( lr_5 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } buff . append ( lr_6 ) ; return buff . toString () ; }
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } if ( iter . hasNext () ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR5Mutator]MSP[N] {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[experimental.MemberVariableMutator]MSP[S] } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR3Mutator]MSP[N] {
return optionMap . values () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NonVoidMethodCallMutator]MSP[S] {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; MST[ConstructorCallMutator]MSP[S] } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[NonVoidMethodCallMutator]MSP[N] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR1Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) {
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buff . toString () ; }
final Option option = iter . next () ; if ( option . getOpt () != null ) MST[NegateConditionalsMutator]MSP[N] { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) MST[NegateConditionalsMutator]MSP[N] { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[ArgumentPropagationMutator]MSP[N] return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
buff . append ( lr_5 ) ; } } buff . append ( lr_6 ) ; return buff . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] }
{ return required ; MST[BooleanTrueReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
{ return required ; MST[BooleanFalseReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) {
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void setRequired ( final boolean required ) { this . required = required ; } public boolean isRequired ()
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[rv.ROR4Mutator]MSP[S] {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; MST[experimental.MemberVariableMutator]MSP[S] return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < String > getNames () { return optionMap . keySet () ; } public Collection < Option > getOptions () {
return optionMap . values () ; MST[NonVoidMethodCallMutator]MSP[N] } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) {
final Option option = iter . next () ; MST[NonVoidMethodCallMutator]MSP[N] if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; } else { buff . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N]
selected = option . getKey () ; } else { throw new AlreadySelectedException ( this , option ) ; } } public String getSelected () { return selected ; } public void setRequired ( final boolean required ) { this . required = required ; MST[rv.UOI3Mutator]MSP[S] } public boolean isRequired ()
return optionMap . values () ; } public void setSelected ( final Option option ) throws AlreadySelectedException { if ( option == null ) { selected = null ; return; } if ( selected == null || selected . equals ( option . getKey () ) ) MST[NegateConditionalsMutator]MSP[N] {
final Option option = iter . next () ; if ( option . getOpt () != null ) { buff . append ( lr_2 ) ; buff . append ( option . getOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N] } else { buff . append ( lr_3 ) ;
buff . append ( option . getLongOpt () ) ; } if ( option . getDescription () != null ) { buff . append ( lr_4 ) ; buff . append ( option . getDescription () ) ; } if ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
public OptionGroup addOption ( final Option option ) { optionMap . put ( option . getKey () , option ) ; return this ; } public Collection < String > getNames () { return optionMap . keySet () ; MST[ReturnValsMutator]MSP[N] } public Collection < Option > getOptions () {
{ return required ; } @Override public String toString () { final StringBuilder buff = new StringBuilder () ; final Iterator < Option > iter = getOptions () . iterator () ; buff . append ( lr_1 ) ; while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[VoidMethodCallMutator]MSP[S] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR4Mutator]MSP[S] {
{ addOption ( opt , null , false , description ) ; MST[InlineConstantMutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[S] option . setRequired ( true ) ; addOption ( option ) ;
return this ; MST[NullReturnValsMutator]MSP[S] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public List getRequiredOptions () {
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR1Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; MST[NonVoidMethodCallMutator]MSP[S] } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[EmptyObjectReturnValsMutator]MSP[S] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[N] }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public List getRequiredOptions () {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N]
{ if ( requiredOpts . contains ( key ) ) MST[NegateConditionalsMutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR5Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ArgumentPropagationMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.ABSMutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR3Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[ReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR1Mutator]MSP[N] addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[S]
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.ABSMutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[N] }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[N] return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR5Mutator]MSP[N] addOption ( option ) ;
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
if ( longOpts . keySet () . contains ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR1Mutator]MSP[S] { return shortOpts . get ( opt ) ; }
public Options addOptionGroup ( final OptionGroup group ) MST[ConstructorCallMutator]MSP[N] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opt . isRequired () )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[ReturnValsMutator]MSP[S] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NegateConditionalsMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI3Mutator]MSP[N] return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return shortOpts . get ( opt ) ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < String > matchingOpts = new ArrayList < String > () ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N]
optionGroups . put ( option . getKey () , group ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR2Mutator]MSP[S] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR3Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR6Mutator]MSP[S] addOption ( option ) ;
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ArgumentPropagationMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[ReturnValsMutator]MSP[N] }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[S] final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return longOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR3Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR5Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR4Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR2Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[S]
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ReturnValsMutator]MSP[N] } public List getRequiredOptions () {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR6Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[InlineConstantMutator]MSP[S] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[ConstructorCallMutator]MSP[S] option . setRequired ( true ) ; addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI4Mutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NegateConditionalsMutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ReturnValsMutator]MSP[N] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NullReturnValsMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ if ( requiredOpts . contains ( key ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[NegateConditionalsMutator]MSP[N] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[ReturnValsMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[N] }
return longOpts . get ( opt ) ; MST[NullReturnValsMutator]MSP[S] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR5Mutator]MSP[N] }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI1Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; MST[experimental.NakedReceiverMutator]MSP[N] return buf . toString () ; }
buf . append ( lr_1 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR1Mutator]MSP[S] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[ReturnValsMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[N] }
optionGroups . put ( option . getKey () , group ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addOptionGroup ( final OptionGroup group ) MST[experimental.MemberVariableMutator]MSP[N] { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
{ addOption ( opt , null , false , description ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
{ addOption ( opt , null , false , description ) ; return this ; MST[NullReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR1Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[S] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.ABSMutator]MSP[N] return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR5Mutator]MSP[N] {
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ; MST[ConstructorCallMutator]MSP[N]
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI3Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR2Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) MST[NonVoidMethodCallMutator]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[NegateConditionalsMutator]MSP[N] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR2Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) MST[NonVoidMethodCallMutator]MSP[N] { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; return this ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[ArgumentPropagationMutator]MSP[N] return this ; }
return longOpts . get ( opt ) ; } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ; MST[ConstructorCallMutator]MSP[N]
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; MST[EmptyObjectReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR2Mutator]MSP[N] }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR4Mutator]MSP[N] }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] }
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[N] option . setRequired ( true ) ; addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR3Mutator]MSP[N] addOption ( option ) ;
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR4Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR6Mutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR2Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR1Mutator]MSP[S] {
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[InlineConstantMutator]MSP[N] addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR5Mutator]MSP[S] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR3Mutator]MSP[N] }
return this ; MST[ReturnValsMutator]MSP[S] } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ConstructorCallMutator]MSP[N] } public Options addOption ( final String opt , final String description )
buf . append ( lr_1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_2 ) ; buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[NonVoidMethodCallMutator]MSP[N] } public Options addOption ( final String opt , final String description )
return Collections . unmodifiableList ( requiredOpts ) ; MST[ReturnValsMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( opt . isRequired () )
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR1Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[S]
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[ReturnValsMutator]MSP[N] } public Options addOption ( final String opt , final String description )
if ( longOpts . keySet () . contains ( opt ) ) MST[rv.ROR4Mutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) MST[NonVoidMethodCallMutator]MSP[N] { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) {
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR3Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] }
return longOpts . get ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] } public List < String > getMatchingOptions ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; final List < String > matchingOpts = new ArrayList < String > () ;
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[S] return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI1Mutator]MSP[N] return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NegateConditionalsMutator]MSP[N] {
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; MST[NonVoidMethodCallMutator]MSP[S] } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return shortOpts . get ( opt ) ; }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[NonVoidMethodCallMutator]MSP[S] {
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR2Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return shortOpts . containsKey ( opt ) ; MST[BooleanFalseReturnValsMutator]MSP[S] } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
{ addOption ( opt , null , false , description ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( lr_3 ) ; return buf . toString () ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR1Mutator]MSP[N] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
{ if ( requiredOpts . contains ( key ) ) MST[rv.ROR4Mutator]MSP[S] { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[ArgumentPropagationMutator]MSP[N] if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR5Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[N] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[rv.UOI2Mutator]MSP[N] return this ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; MST[ReturnValsMutator]MSP[N] } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[NonVoidMethodCallMutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI4Mutator]MSP[N] return this ; }
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; buf . append ( longOpts ) ; MST[NonVoidMethodCallMutator]MSP[N] buf . append ( lr_3 ) ; return buf . toString () ; }
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; MST[ReturnValsMutator]MSP[N] } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[rv.UOI2Mutator]MSP[N] return this ; }
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; MST[ConstructorCallMutator]MSP[N] } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[ReturnValsMutator]MSP[S] }
return shortOpts . containsKey ( opt ) ; } public OptionGroup getOptionGroup ( final Option opt ) { return optionGroups . get ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { final StringBuilder buf = new StringBuilder () ;
return Collections . unmodifiableList ( requiredOpts ) ; MST[ArgumentPropagationMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR4Mutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; return this ; MST[NullReturnValsMutator]MSP[S] }
{ if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR3Mutator]MSP[N] addOption ( option ) ;
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[rv.CRCR6Mutator]MSP[N] addOption ( option ) ;
buf . append ( lr_1 ) ; buf . append ( shortOpts . toString () ) ; buf . append ( lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] buf . append ( longOpts ) ; buf . append ( lr_3 ) ; return buf . toString () ; }
public boolean hasLongOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return longOpts . containsKey ( opt ) ; } public boolean hasShortOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; MST[NonVoidMethodCallMutator]MSP[S]
optionGroups . put ( option . getKey () , group ) ; } return this ; } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; addOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N]
public Collection < Option > getOptions () { return Collections . unmodifiableCollection ( helpOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } List < Option > helpOptions () { return new ArrayList < Option > ( shortOpts . values () ) ; } public List getRequiredOptions () {
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] return this ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.ROR1Mutator]MSP[N] }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; MST[VoidMethodCallMutator]MSP[N] addOption ( option ) ;
return Collections . unmodifiableList ( requiredOpts ) ; } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) MST[rv.ROR3Mutator]MSP[N] { return shortOpts . get ( opt ) ; }
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( opt . isRequired () )
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N]
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] }
return Collections . unmodifiableList ( requiredOpts ) ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return shortOpts . get ( opt ) ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[rv.CRCR3Mutator]MSP[N] }
public Options addOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; MST[ConstructorCallMutator]MSP[N] return this ; }
optionGroups . put ( option . getKey () , group ) ; } return this ; MST[ReturnValsMutator]MSP[S] } Collection < OptionGroup > getOptionGroups () { return new HashSet < OptionGroup > ( optionGroups . values () ) ; } public Options addOption ( final String opt , final String description )
public Options addRequiredOption ( final String opt , final String longOpt , final boolean hasArg , final String description ) { final Option option = new Option ( opt , longOpt , hasArg , description ) ; option . setRequired ( true ) ; MST[rv.CRCR4Mutator]MSP[N] addOption ( option ) ;
return this ; } public Options addOption ( final Option opt ) { final String key = opt . getKey () ; if ( opt . hasLongOpt () ) MST[rv.ROR5Mutator]MSP[N] { longOpts . put ( opt . getLongOpt () , opt ) ; } if ( opt . isRequired () )
{ addOption ( opt , null , false , description ) ; MST[rv.CRCR5Mutator]MSP[S] return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; return this ; }
public Options addOptionGroup ( final OptionGroup group ) { if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { requiredOpts . add ( group ) ; } for ( final Option option : group . getOptions () ) { option . setRequired ( false ) ; addOption ( option ) ;
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) { if ( longOpt . startsWith ( opt ) ) MST[rv.ROR2Mutator]MSP[N] {
{ addOption ( opt , null , false , description ) ; return this ; } public Options addOption ( final String opt , final boolean hasArg , final String description ) { addOption ( opt , null , hasArg , description ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; }
matchingOpts . add ( longOpt ) ; } } return matchingOpts ; } public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; MST[InlineConstantMutator]MSP[N] }
if ( longOpts . keySet () . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( final String longOpt : longOpts . keySet () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( longOpt . startsWith ( opt ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ABSMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR4Mutator]MSP[S] {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
return Character . isJavaIdentifierPart ( c ) ; MST[rv.ABSMutator]MSP[S] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR3Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR4Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR1Mutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR5Mutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ROR2Mutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NegateConditionalsMutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[NonVoidMethodCallMutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[NegateConditionalsMutator]MSP[N] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI4Mutator]MSP[N] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] if ( ! isValidOpt ( ch ) ) {
return Character . isJavaIdentifierPart ( c ) ; MST[BooleanTrueReturnValsMutator]MSP[N] }
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[ConstructorCallMutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.ABSMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ABSMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR3Mutator]MSP[S] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[S] if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR4Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR4Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR3Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.ABSMutator]MSP[N] {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[ConstructorCallMutator]MSP[N]
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI1Mutator]MSP[N] }
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.ABSMutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI4Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[NegateConditionalsMutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR5Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[ReturnValsMutator]MSP[N] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[ConstructorCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI1Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI1Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.ABSMutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR1Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.ABSMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[InlineConstantMutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI1Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
return Character . isJavaIdentifierPart ( c ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI4Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR5Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR4Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR1Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI3Mutator]MSP[S] {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI2Mutator]MSP[N] {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[NonVoidMethodCallMutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR6Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI4Mutator]MSP[N] {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[rv.UOI1Mutator]MSP[N] {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[NonVoidMethodCallMutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI3Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI2Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI4Mutator]MSP[N]
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[rv.UOI1Mutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[NegateConditionalsMutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.ABSMutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NegateConditionalsMutator]MSP[N] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI1Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI3Mutator]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI2Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[rv.UOI4Mutator]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ABSMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI4Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[ReturnValsMutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[BooleanTrueReturnValsMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI1Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI3Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI4Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[experimental.NakedReceiverMutator]MSP[N]
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4 MST[NonVoidMethodCallMutator]MSP[N]
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI2Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR2Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR5Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR4Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR2Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR3Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[NonVoidMethodCallMutator]MSP[S] }
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR1Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.ROR1Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI1Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR2Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR5Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NonVoidMethodCallMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.CRCR6Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI3Mutator]MSP[N] }
return Character . isJavaIdentifierPart ( c ) ; MST[rv.UOI2Mutator]MSP[N] }
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI2Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR4Mutator]MSP[N] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.UOI4Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) MST[rv.ROR5Mutator]MSP[N] { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR5Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[NegateConditionalsMutator]MSP[N] } private static boolean isValidChar ( final char c ) {
static void validateOption ( final String opt ) throws IllegalArgumentException { if ( opt == null ) { return; } if ( opt . length () == 1 ) { final char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI3Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { throw new IllegalArgumentException ( lr_3 + opt + lr_4
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI3Mutator]MSP[S] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; } } else { for ( final char ch : opt . toCharArray () ) MST[rv.UOI2Mutator]MSP[N] { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[rv.CRCR3Mutator]MSP[S] } private static boolean isValidChar ( final char c ) {
+ lr_5 + ch + lr_2 ) ; } } } } private static boolean isValidOpt ( final char c ) { return isValidChar ( c ) || c == '?' || c == '@' ; MST[InlineConstantMutator]MSP[S] } private static boolean isValidChar ( final char c ) {
throw new IllegalArgumentException ( lr_1 + ch + lr_2 ) ; MST[rv.UOI3Mutator]MSP[N] } } else { for ( final char ch : opt . toCharArray () ) { if ( ! isValidChar ( ch ) ) { throw new IllegalArgumentException ( lr_3 + opt + lr_4
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) { opt . clearValues () ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) { final String str = iter . next () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
getRequiredOptions () . remove ( group ) ; } group . setSelected ( opt ) ; } }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR2Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] cmd . addArg ( t ) ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI4Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR3Mutator]MSP[N] { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NonVoidMethodCallMutator]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.ABSMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N] if ( arguments == null ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N] if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { final String str = iter . next () ;
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR3Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[N] }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N]
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR3Mutator]MSP[S] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI1Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI2Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; MST[VoidMethodCallMutator]MSP[S] } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NegateConditionalsMutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; MST[ReturnValsMutator]MSP[N] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI3Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR4Mutator]MSP[N] {
{ final String t = iterator . next () ; MST[NonVoidMethodCallMutator]MSP[N] if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR1Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; MST[ConstructorCallMutator]MSP[S] } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR4Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
protected void setOptions ( final Options options ) { this . options = options ; MST[experimental.MemberVariableMutator]MSP[N] this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { final String str = iter . next () ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR3Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[S] { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
getRequiredOptions () . remove ( group ) ; } group . setSelected ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } }
final String value = properties . getProperty ( option ) ; MST[ArgumentPropagationMutator]MSP[N] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[S] { eatTheRest = true ; } else {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } group . setSelected ( opt ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[S] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR4Mutator]MSP[N] {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[ReturnValsMutator]MSP[N] } protected List getRequiredOptions () { return requiredOptions ; }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NegateConditionalsMutator]MSP[N] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[NullReturnValsMutator]MSP[N] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR1Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; MST[VoidMethodCallMutator]MSP[N] } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[ArgumentPropagationMutator]MSP[S] } catch ( final RuntimeException exp ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR1Mutator]MSP[S] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; MST[VoidMethodCallMutator]MSP[N] return cmd ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] cmd . addArg ( t ) ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR5Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
arguments = new String [ 0 ] ; MST[InlineConstantMutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR1Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[NegateConditionalsMutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; MST[ReturnValsMutator]MSP[N] }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[ConstructorCallMutator]MSP[N] } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N]
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[rv.ROR5Mutator]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NegateConditionalsMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ABSMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; MST[VoidMethodCallMutator]MSP[N] cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( group ) ; MST[NonVoidMethodCallMutator]MSP[S] } group . setSelected ( opt ) ; } }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR4Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI3Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI1Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[S] } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR2Mutator]MSP[N] {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR1Mutator]MSP[N] {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) MST[NonVoidMethodCallMutator]MSP[N] { opt . clearValues () ; }
processOption ( t , iterator ) ; MST[VoidMethodCallMutator]MSP[N] } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR2Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI4Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[S] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ABSMutator]MSP[N] { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI4Mutator]MSP[N] { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR5Mutator]MSP[N] {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; MST[ConstructorCallMutator]MSP[S] }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[NonVoidMethodCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
arguments = new String [ 0 ] ; MST[rv.CRCR3Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[S] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[S] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[ReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
return parse ( options , arguments , properties , false ) ; MST[NullReturnValsMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR3Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR4Mutator]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[S] } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[NegateConditionalsMutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR5Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iterator . hasNext () )
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR2Mutator]MSP[N] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N] if ( arguments == null ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NonVoidMethodCallMutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; MST[NonVoidMethodCallMutator]MSP[S] break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR4Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR2Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; MST[VoidMethodCallMutator]MSP[N] checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[S] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { continue; } cmd . addOption ( opt ) ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[S] cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI2Mutator]MSP[N] {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
return parse ( options , arguments , properties , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) MST[NonVoidMethodCallMutator]MSP[N] { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) {
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR1Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR3Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR5Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; MST[EmptyObjectReturnValsMutator]MSP[N] }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( group . isRequired () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; MST[experimental.MemberVariableMutator]MSP[N] } protected Options getOptions () { return options ; } protected List getRequiredOptions () { return requiredOptions ; }
arguments = new String [ 0 ] ; MST[rv.CRCR5Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; MST[rv.CRCR1Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; MST[VoidMethodCallMutator]MSP[N] } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[rv.ROR5Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[S] { eatTheRest = true ; } else {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[NonVoidMethodCallMutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[NegateConditionalsMutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR4Mutator]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N]
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NonVoidMethodCallMutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ABSMutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[NonVoidMethodCallMutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR5Mutator]MSP[S] {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[experimental.MemberVariableMutator]MSP[N] boolean eatTheRest = false ; if ( arguments == null ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NonVoidMethodCallMutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI1Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[NegateConditionalsMutator]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR3Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[S] cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI2Mutator]MSP[N] { while ( iterator . hasNext () ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR2Mutator]MSP[N] {
public CommandLine parse ( final Options options , String [] arguments , final Properties properties , final boolean stopAtNonOption ) throws ParseException { for ( final Option opt : options . helpOptions () ) { opt . clearValues () ; MST[VoidMethodCallMutator]MSP[N] }
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR6Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ; MST[NonVoidMethodCallMutator]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) { cmd . addArg ( str ) ; MST[VoidMethodCallMutator]MSP[N] } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[NullReturnValsMutator]MSP[N] }
updateRequiredOptions ( opt ) ; MST[VoidMethodCallMutator]MSP[N] if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[S] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR1Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final String str = iter . next () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[NonVoidMethodCallMutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[InlineConstantMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; MST[VoidMethodCallMutator]MSP[S] }
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR4Mutator]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR2Mutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI4Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { final String str = iter . next () ;
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] {
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[ReturnValsMutator]MSP[N] }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[NegateConditionalsMutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR1Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR3Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[rv.ROR3Mutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[rv.ROR5Mutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[NegateConditionalsMutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingOptionException ( getRequiredOptions () ) ; } }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NonVoidMethodCallMutator]MSP[S] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions () ) ; } protected Options getOptions () { return options ; MST[NullReturnValsMutator]MSP[N] } protected List getRequiredOptions () { return requiredOptions ; }
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[InlineConstantMutator]MSP[N] if ( arguments == null ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[NonVoidMethodCallMutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[rv.ROR3Mutator]MSP[N] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR1Mutator]MSP[S] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR3Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR5Mutator]MSP[N]
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR3Mutator]MSP[N]
return parse ( options , arguments , properties , false ) ; } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) MST[rv.ROR2Mutator]MSP[N] {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; MST[VoidMethodCallMutator]MSP[N] } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) MST[NegateConditionalsMutator]MSP[S] || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) { iter . previous () ; MST[NonVoidMethodCallMutator]MSP[N] break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR5Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; } else {
protected void processProperties ( final Properties properties ) throws ParseException { if ( properties == null ) MST[NegateConditionalsMutator]MSP[N] { return; } for ( final Enumeration < ? > e = properties . propertyNames () ; e . hasMoreElements () ; ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR5Mutator]MSP[N] {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[rv.ROR1Mutator]MSP[N] {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[rv.ROR5Mutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR4Mutator]MSP[N] {
public CommandLine parse ( final Options options , final String [] arguments ) throws ParseException { return parse ( options , arguments , null , false ) ; MST[rv.CRCR3Mutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final Properties properties ) throws ParseException {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; MST[ConstructorCallMutator]MSP[N] boolean eatTheRest = false ; if ( arguments == null ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[ArgumentPropagationMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[rv.ROR4Mutator]MSP[S] {
return parse ( options , arguments , properties , false ) ; MST[InlineConstantMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[NonVoidMethodCallMutator]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[rv.UOI3Mutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[S] } else if ( lr_2 . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.UOI2Mutator]MSP[N] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; if ( arguments == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR4Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR6Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.CRCR1Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NonVoidMethodCallMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String str = iter . next () ;
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
return parse ( options , arguments , properties , false ) ; MST[NonVoidMethodCallMutator]MSP[N] } public CommandLine parse ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { return parse ( options , arguments , null , stopAtNonOption ) ; }
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { while ( iterator . hasNext () ) {
public void processArgs ( final Option opt , final ListIterator < String > iter ) throws ParseException { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { final String str = iter . next () ;
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) MST[NegateConditionalsMutator]MSP[N] { if ( opt . getValues () == null || opt . getValues () . length == 0 ) { try { opt . addValueForProcessing ( value ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; MST[VoidMethodCallMutator]MSP[N] } else {
final String option = e . nextElement () . toString () ; final Option opt = options . getOption ( option ) ; if ( opt == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.ROR5Mutator]MSP[N] {
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) MST[rv.ROR5Mutator]MSP[N] || lr_6 . equalsIgnoreCase ( value ) ) ) { continue; } cmd . addOption ( opt ) ;
arguments = new String [ 0 ] ; MST[rv.CRCR6Mutator]MSP[N] } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
final String option = e . nextElement () . toString () ; MST[NonVoidMethodCallMutator]MSP[N] final Option opt = options . getOption ( option ) ; if ( opt == null ) { throw new UnrecognizedOptionException ( lr_3 , option ) ; }
if ( getOptions () . hasOption ( str ) && str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { iter . previous () ; break; } try { opt . addValueForProcessing ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( final RuntimeException exp ) {
updateRequiredOptions ( opt ) ; } } } protected void checkRequiredOptions () throws MissingOptionException { if ( ! getRequiredOptions () . isEmpty () ) { throw new MissingOptionException ( getRequiredOptions () ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; MST[NonVoidMethodCallMutator]MSP[N] final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () )
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[NegateConditionalsMutator]MSP[N]
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; cmd . addArg ( t ) ; } else {
for ( final OptionGroup group : options . getOptionGroups () ) { group . setSelected ( null ) ; } setOptions ( options ) ; cmd = new CommandLine () ; boolean eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N] if ( arguments == null ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final String value = properties . getProperty ( option ) ; if ( opt . hasArg () ) { if ( opt . getValues () == null || opt . getValues () . length == 0 ) MST[rv.ROR5Mutator]MSP[N] { try { opt . addValueForProcessing ( value ) ; }
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) MST[NegateConditionalsMutator]MSP[S] {
final String str = iterator . next () ; if ( ! lr_1 . equals ( str ) ) MST[NegateConditionalsMutator]MSP[N] { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions () ; return cmd ; }
cmd . addArg ( t ) ; } } else if ( t . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { if ( stopAtNonOption && ! getOptions () . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[NegateConditionalsMutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
{ final String t = iterator . next () ; if ( lr_1 . equals ( t ) ) { eatTheRest = true ; } else if ( lr_2 . equals ( t ) ) MST[rv.ROR1Mutator]MSP[N] { if ( stopAtNonOption ) { eatTheRest = true ; } else {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) MST[rv.ROR4Mutator]MSP[S] { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) MST[rv.UOI1Mutator]MSP[N] { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[rv.UOI3Mutator]MSP[N] {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; MST[rv.ROR5Mutator]MSP[N] if ( ! cmd . hasOption ( option ) && ! selected ) {
processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[S] } } if ( eatTheRest ) { while ( iterator . hasNext () ) {
final OptionGroup group = options . getOptionGroup ( opt ) ; final boolean selected = group != null && group . getSelected () != null ; if ( ! cmd . hasOption ( option ) && ! selected ) MST[NonVoidMethodCallMutator]MSP[N] {
{ final boolean hasOption = getOptions () . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( lr_7 + arg , arg ) ; MST[experimental.NakedReceiverMutator]MSP[N] } final Option opt = ( Option ) getOptions () . getOption ( arg ) . clone () ;
iter . previous () ; break; } } if ( opt . getValues () == null && ! opt . hasOptionalArg () ) MST[rv.ROR2Mutator]MSP[N] { throw new MissingArgumentException ( opt ) ; } } protected void processOption ( final String arg , final ListIterator < String > iter ) throws ParseException
getRequiredOptions () . remove ( opt . getKey () ) ; } if ( getOptions () . getOptionGroup ( opt ) != null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final OptionGroup group = getOptions () . getOptionGroup ( opt ) ; if ( group . isRequired () ) {
updateRequiredOptions ( opt ) ; if ( opt . hasArg () ) MST[rv.ROR5Mutator]MSP[N] { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; } private void updateRequiredOptions ( final Option opt ) throws ParseException { if ( opt . isRequired () ) {
arguments = new String [ 0 ] ; } final List < String > tokenList = Arrays . asList ( flatten ( getOptions () , arguments , stopAtNonOption ) ) ; final ListIterator < String > iterator = tokenList . listIterator () ; while ( iterator . hasNext () ) MST[rv.ROR4Mutator]MSP[N]
catch ( final RuntimeException exp ) { } } } else if ( ! ( lr_4 . equalsIgnoreCase ( value ) || lr_5 . equalsIgnoreCase ( value ) || lr_6 . equalsIgnoreCase ( value ) ) ) MST[rv.ROR2Mutator]MSP[S] { continue; } cmd . addOption ( opt ) ;
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[MathMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR1Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR6Mutator]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR5Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[ConstructorCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[NegateConditionalsMutator]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR4Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR5Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[S]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } gobble ( iter ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOD2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] break;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[ConstructorCallMutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[MathMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( pos != - 1 ) MST[InlineConstantMutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR4Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NegateConditionalsMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
if ( pos != - 1 ) MST[rv.CRCR1Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; MST[ConstructorCallMutator]MSP[S] } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR2Mutator]MSP[N] break;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR2Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[NonVoidMethodCallMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[N] break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] { eatTheRest = true ; }
private void init () { eatTheRest = false ; MST[experimental.MemberVariableMutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ;
if ( pos != - 1 ) MST[rv.UOI2Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( options . hasOption ( ch ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ; MST[experimental.MemberVariableMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) MST[rv.UOI1Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[InlineConstantMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } gobble ( iter ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR1Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD2Mutator]MSP[N] break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.CRCR6Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[experimental.NakedReceiverMutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } } }
} } else if ( stopAtNonOption ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ABSMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI3Mutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[S]
else if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ReturnValsMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR2Mutator]MSP[N] { while ( iter . hasNext () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR4Mutator]MSP[N] { while ( iter . hasNext () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } gobble ( iter ) ; }
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[NegateConditionalsMutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOD2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI1Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR4Mutator]MSP[N] break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( pos != - 1 ) MST[rv.UOI4Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI3Mutator]MSP[N] break;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR4Mutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR3Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[NonVoidMethodCallMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR1Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) MST[rv.ROR5Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
} } else if ( stopAtNonOption ) MST[NegateConditionalsMutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; MST[NonVoidMethodCallMutator]MSP[S] } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR3Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR3Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR4Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; MST[experimental.MemberVariableMutator]MSP[N] if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ;
if ( pos != - 1 ) MST[rv.ABSMutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[experimental.NakedReceiverMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR4Mutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR5Mutator]MSP[N]
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR4Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR3Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.ABSMutator]MSP[N] if ( options . hasOption ( ch ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR4Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI3Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[rv.UOI2Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { eatTheRest = true ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } gobble ( iter ) ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[ArgumentPropagationMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N]
private void init () { eatTheRest = false ; tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; MST[VoidMethodCallMutator]MSP[N] this . options = options ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI1Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) MST[rv.CRCR5Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { while ( iter . hasNext () ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR6Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[experimental.MemberVariableMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[InlineConstantMutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) MST[rv.UOI3Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NegateConditionalsMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR3Mutator]MSP[N] {
if ( options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] { eatTheRest = true ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI4Mutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR5Mutator]MSP[N] {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR3Mutator]MSP[N] { while ( iter . hasNext () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.ABSMutator]MSP[N] break;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[ArgumentPropagationMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NegateConditionalsMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR4Mutator]MSP[S]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[InlineConstantMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR3Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR6Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[N] break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[S]
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[NonVoidMethodCallMutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR5Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR6Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR2Mutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR2Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
else if ( matchingOpts . size () > 1 ) MST[rv.ROR3Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR5Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[N] break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[NonVoidMethodCallMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( pos != - 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR5Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.ROR1Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI4Mutator]MSP[N] break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[NonVoidMethodCallMutator]MSP[N] { eatTheRest = true ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
} } else if ( stopAtNonOption ) MST[rv.ROR4Mutator]MSP[S] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
} } else if ( stopAtNonOption ) MST[rv.UOI3Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[NonVoidMethodCallMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOD1Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[experimental.NakedReceiverMutator]MSP[N]
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR5Mutator]MSP[N] { while ( iter . hasNext () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[rv.ROR1Mutator]MSP[N] { while ( iter . hasNext () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( pos != - 1 ) MST[rv.CRCR4Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; MST[NullReturnValsMutator]MSP[N] } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI4Mutator]MSP[N] { eatTheRest = true ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[S]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOD1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[S] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR4Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR3Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR3Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[InlineConstantMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR1Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ;
else if ( matchingOpts . size () > 1 ) MST[InlineConstantMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[NegateConditionalsMutator]MSP[N] { while ( iter . hasNext () ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR2Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR3Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI4Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[InlineConstantMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI2Mutator]MSP[N] { eatTheRest = true ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
if ( options . hasOption ( token ) ) MST[NonVoidMethodCallMutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR3Mutator]MSP[N]
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR2Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[ConditionalsBoundaryMutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[InlineConstantMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR4Mutator]MSP[S] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NonVoidMethodCallMutator]MSP[N] {
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR6Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR2Mutator]MSP[N] {
} } else if ( stopAtNonOption ) MST[rv.ABSMutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR4Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) MST[rv.ROR3Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI2Mutator]MSP[N] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR2Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR2Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; MST[experimental.MemberVariableMutator]MSP[S] } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR6Mutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR6Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI1Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR2Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
private void init () { eatTheRest = false ; MST[rv.CRCR3Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[ConditionalsBoundaryMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
private void init () { eatTheRest = false ; MST[InlineConstantMutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } gobble ( iter ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[experimental.MemberVariableMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[NegateConditionalsMutator]MSP[N] { eatTheRest = true ; }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[VoidMethodCallMutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[S] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI1Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) MST[ConditionalsBoundaryMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR5Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
else if ( matchingOpts . size () > 1 ) MST[NonVoidMethodCallMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR1Mutator]MSP[S]
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[experimental.NakedReceiverMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR2Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[VoidMethodCallMutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NegateConditionalsMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
private void init () { eatTheRest = false ; MST[rv.CRCR6Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[InlineConstantMutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR4Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) MST[rv.ROR4Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ;
} } else if ( stopAtNonOption ) MST[rv.ROR1Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR2Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[MathMutator]MSP[N] break;
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) MST[rv.UOI4Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; MST[ConstructorCallMutator]MSP[N] } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[NonVoidMethodCallMutator]MSP[S]
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR1Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[InlineConstantMutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR2Mutator]MSP[N]
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR5Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR4Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR3Mutator]MSP[N] break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR5Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR1Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ABSMutator]MSP[N] { eatTheRest = true ;
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ; MST[rv.CRCR2Mutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.ROR2Mutator]MSP[N] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ; MST[NonVoidMethodCallMutator]MSP[N]
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
final List < String > matchingOpts = options . getMatchingOptions ( token ) ; if ( matchingOpts . size () > 1 ) MST[rv.CRCR6Mutator]MSP[S] { throw new AmbiguousOptionException ( token , matchingOpts ) ; } final Option opt = options . getOption ( matchingOpts . get ( 0 ) ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.UOI3Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; MST[ConstructorCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ;
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR1Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR1Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR5Mutator]MSP[N]
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.ABSMutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.UOI3Mutator]MSP[S] { eatTheRest = true ; }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) ) MST[rv.ROR1Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[InlineConstantMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[rv.ROR2Mutator]MSP[N] {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[NonVoidMethodCallMutator]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; MST[VoidMethodCallMutator]MSP[N] }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR1Mutator]MSP[S] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
for ( int i = 1 ; i < token . length () ; i ++ ) MST[InlineConstantMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR4Mutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ABSMutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.AOR3Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR5Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI2Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N]
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.CRCR3Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.CRCR6Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.ROR3Mutator]MSP[N] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[rv.UOI3Mutator]MSP[N] { eatTheRest = true ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR1Mutator]MSP[N] break;
private void init () { eatTheRest = false ; tokens . clear () ; MST[VoidMethodCallMutator]MSP[N] } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
else if ( matchingOpts . size () > 1 ) { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; MST[rv.CRCR5Mutator]MSP[N] tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ROR1Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI1Mutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR5Mutator]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break;
if ( options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { while ( iter . hasNext () ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.UOI3Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
} } else if ( stopAtNonOption ) MST[rv.ROR2Mutator]MSP[N] { processNonOptionToken ( token . substring ( i ) , true ) ; break; } else { tokens . add ( token ) ; break; } } }
final Iterator < String > iter = Arrays . asList ( arguments ) . iterator () ; MST[NonVoidMethodCallMutator]MSP[N] while ( iter . hasNext () ) { final String token = iter . next () ; if ( lr_1 . equals ( token ) || lr_2 . equals ( token ) )
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR5Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
if ( token . length () == 2 || options . hasOption ( token ) ) MST[rv.CRCR6Mutator]MSP[S] { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.ROR1Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) { eatTheRest = true ; MST[experimental.MemberVariableMutator]MSP[N]
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.ABSMutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR5Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR2Mutator]MSP[N] }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.UOI1Mutator]MSP[N] break;
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR5Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
if ( pos != - 1 ) MST[rv.CRCR2Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
if ( token . length () == 2 || options . hasOption ( token ) ) { processOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } else if ( ! options . getMatchingOptions ( token ) . isEmpty () ) {
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[NonVoidMethodCallMutator]MSP[S] break; } else { tokens . add ( token ) ; break; } } }
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.ABSMutator]MSP[N] }
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR3Mutator]MSP[N] { eatTheRest = true ; }
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[NegateConditionalsMutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { eatTheRest = true ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[N] break;
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.UOI2Mutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[NegateConditionalsMutator]MSP[N] {
if ( options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { currentOption = options . getOption ( token ) ; } tokens . add ( token ) ; } protected void burstToken ( final String token , final boolean stopAtNonOption ) {
if ( pos != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR6Mutator]MSP[N] break;
tokens . add ( lr_1 + ch ) ; MST[experimental.NakedReceiverMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
else if ( matchingOpts . size () > 1 ) MST[rv.CRCR4Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[NonVoidMethodCallMutator]MSP[N] { tokens . add ( token . substring ( i + 1 ) ) ; break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) MST[rv.ROR4Mutator]MSP[N] {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) { eatTheRest = true ; MST[rv.CRCR3Mutator]MSP[N] }
else if ( matchingOpts . size () > 1 ) MST[rv.ROR1Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
else if ( matchingOpts . size () > 1 ) MST[rv.ROR5Mutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.CRCR3Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOD1Mutator]MSP[N] break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.ROR4Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; MST[rv.UOI4Mutator]MSP[N] } else { burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.CRCR2Mutator]MSP[N] break;
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; MST[NonVoidMethodCallMutator]MSP[N] currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; break;
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; MST[rv.UOI2Mutator]MSP[N] }
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR1Mutator]MSP[N] {
if ( pos != - 1 ) MST[rv.UOI1Mutator]MSP[S] { tokens . add ( token . substring ( pos + 1 ) ) ; } } } else if ( token . startsWith ( lr_1 ) ) {
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[rv.AOR3Mutator]MSP[N] break;
for ( int i = 1 ; i < token . length () ; i ++ ) MST[rv.UOI4Mutator]MSP[N] { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) {
else if ( matchingOpts . size () > 1 ) MST[NegateConditionalsMutator]MSP[N] { throw new AmbiguousOptionException ( opt , matchingOpts ) ; } else { currentOption = options . getOption ( matchingOpts . get ( 0 ) ) ; tokens . add ( lr_2 + currentOption . getLongOpt () ) ;
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; if ( options . hasOption ( ch ) ) MST[rv.ROR5Mutator]MSP[N] {
return tokens . toArray ( new String [ tokens . size () ] ) ; } private void gobble ( final Iterator < String > iter ) { if ( eatTheRest ) { while ( iter . hasNext () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
for ( int i = 1 ; i < token . length () ; i ++ ) { final String ch = String . valueOf ( token . charAt ( i ) ) ; MST[rv.UOI1Mutator]MSP[N] if ( options . hasOption ( ch ) ) {
tokens . add ( lr_2 ) ; } tokens . add ( value ) ; } private void processOptionToken ( final String token , final boolean stopAtNonOption ) { if ( stopAtNonOption && ! options . hasOption ( token ) ) MST[rv.ROR2Mutator]MSP[N] { eatTheRest = true ; }
} } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; MST[rv.ABSMutator]MSP[N] break; } else { tokens . add ( token ) ; break; } } }
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.AOR4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
final String opt = pos == - 1 ? token : token . substring ( 0 , pos ) ; MST[rv.UOI3Mutator]MSP[N] final List < String > matchingOpts = options . getMatchingOptions ( opt ) ; if ( matchingOpts . isEmpty () ) { processNonOptionToken ( token , stopAtNonOption ) ; }
{ tokens . add ( token ) ; } else if ( token . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { final int pos = token . indexOf ( '=' ) ;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) MST[rv.CRCR4Mutator]MSP[S] { tokens . add ( token . substring ( i + 1 ) ) ; break;
tokens . add ( lr_1 + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg () && token . length () != i + 1 ) { tokens . add ( token . substring ( i + 1 ) ) ; MST[InlineConstantMutator]MSP[N] break;
if ( pos != - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; MST[rv.CRCR4Mutator]MSP[S] } } } else if ( token . startsWith ( lr_1 ) ) {
processOptionToken ( lr_1 + opt . getLongOpt () , stopAtNonOption ) ; } else { burstToken ( token , stopAtNonOption ) ; MST[rv.UOI3Mutator]MSP[N] } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; }
private void init () { eatTheRest = false ; MST[rv.CRCR5Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
private void init () { eatTheRest = false ; MST[rv.CRCR1Mutator]MSP[N] tokens . clear () ; } @Override protected String [] flatten ( final Options options , final String [] arguments , final boolean stopAtNonOption ) throws ParseException { init () ; this . options = options ;
tokens . add ( iter . next () ) ; } } } private void processNonOptionToken ( final String value , final boolean stopAtNonOption ) { if ( stopAtNonOption && ( currentOption == null || ! currentOption . hasArg () ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { eatTheRest = true ;
{ tokens . add ( token ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( token . startsWith ( lr_2 ) ) { final int pos = token . indexOf ( '=' ) ;
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; } @SuppressWarnings ( lr_1 )
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
throw new UnsupportedOperationException ( lr_5 ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
else { throw new ParseException ( lr_2 + clazz ) ; } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } catch ( final ClassNotFoundException cnfe ) {
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; MST[ReturnValsMutator]MSP[N] }
else { throw new ParseException ( lr_2 + clazz ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } return Long . valueOf ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createDate ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createDate ( str ) ; }
return ( T ) openFile ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; MST[NullReturnValsMutator]MSP[N] }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[S] { return ( T ) createURL ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; MST[NullReturnValsMutator]MSP[N] } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[N] } public static URL createURL ( final String str ) throws ParseException { try {
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; MST[ReturnValsMutator]MSP[N] } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR2Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR4Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[ConstructorCallMutator]MSP[S] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File [] createFiles ( final String str ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; MST[NonVoidMethodCallMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] {
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; MST[NullReturnValsMutator]MSP[N] }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; MST[NonVoidMethodCallMutator]MSP[S] }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
return new URL ( str ) ; MST[ConstructorCallMutator]MSP[N] } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR5Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR6Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; MST[ReturnValsMutator]MSP[S] }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR1Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR5Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR3Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR2Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[InlineConstantMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] { return ( T ) createDate ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return ( T ) openFile ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] {
return new URL ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[ArgumentPropagationMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[S] { return ( T ) createURL ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static File [] createFiles ( final String str ) {
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createDate ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; MST[ReturnValsMutator]MSP[N] }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; MST[NullReturnValsMutator]MSP[N] } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; MST[NullReturnValsMutator]MSP[S] } return Long . valueOf ( str ) ; }
catch ( final NumberFormatException e ) { throw new ParseException ( e . getMessage () ) ; MST[ConstructorCallMutator]MSP[S] } } public static Class < ? > createClass ( final String classname ) throws ParseException { try { return Class . forName ( classname ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR1Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
throw new UnsupportedOperationException ( lr_5 ) ; MST[ConstructorCallMutator]MSP[N] }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[ConstructorCallMutator]MSP[S] } }
return ( T ) createObject ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; MST[NullReturnValsMutator]MSP[S] } @SuppressWarnings ( lr_1 )
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; MST[NullReturnValsMutator]MSP[S] }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[NonVoidMethodCallMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; MST[ReturnValsMutator]MSP[N] } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
else { throw new ParseException ( lr_2 + clazz ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; MST[NonVoidMethodCallMutator]MSP[S] } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; MST[ReturnValsMutator]MSP[N] }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) { return Double . valueOf ( str ) ; MST[ReturnValsMutator]MSP[S] } return Long . valueOf ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; MST[NullReturnValsMutator]MSP[S] } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } }
return new URL ( str ) ; MST[NullReturnValsMutator]MSP[S] } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[NonVoidMethodCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR2Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; MST[ReturnValsMutator]MSP[S] } @SuppressWarnings ( lr_1 )
return ( T ) createObject ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File [] createFiles ( final String str ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[NegateConditionalsMutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; MST[ConstructorCallMutator]MSP[N] } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createURL ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR3Mutator]MSP[N] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[ConstructorCallMutator]MSP[S] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; MST[ConstructorCallMutator]MSP[N] }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
public static Object createValue ( final String str , final Object obj ) throws ParseException { return createValue ( str , ( Class < ? > ) obj ) ; MST[NonVoidMethodCallMutator]MSP[S] } @SuppressWarnings ( lr_1 )
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; MST[NullReturnValsMutator]MSP[N] } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR6Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; MST[experimental.NakedReceiverMutator]MSP[N] } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR5Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR4Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[ConstructorCallMutator]MSP[S] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; MST[ReturnValsMutator]MSP[N] } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; } }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.ROR4Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[InlineConstantMutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; } } public static File createFile ( final String str ) { return new File ( str ) ; MST[NullReturnValsMutator]MSP[N] }
return ( T ) createObject ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
catch ( final ClassNotFoundException e ) { throw new ParseException ( lr_3 + classname ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static Date createDate ( final String str ) { throw new UnsupportedOperationException ( lr_5 ) ; } public static URL createURL ( final String str ) throws ParseException { try {
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[NonVoidMethodCallMutator]MSP[S] } }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] }
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[NonVoidMethodCallMutator]MSP[N] } } public static File createFile ( final String str ) { return new File ( str ) ; }
throw new ParseException ( lr_3 + classname ) ; } try { return cl . newInstance () ; } catch ( final Exception e ) { throw new ParseException ( e . getClass () . getName () + lr_4 + classname ) ; MST[ConstructorCallMutator]MSP[S] } }
return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) MST[NegateConditionalsMutator]MSP[N] { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; }
else { throw new ParseException ( lr_2 + clazz ) ; MST[experimental.NakedReceiverMutator]MSP[N] } } public static Object createObject ( final String classname ) throws ParseException { Class < ? > cl ; try { cl = Class . forName ( classname ) ; } catch ( final ClassNotFoundException cnfe ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; MST[NullReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; MST[ReturnValsMutator]MSP[S] } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; } } public static File [] createFiles ( final String str ) {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[rv.CRCR1Mutator]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; MST[NonVoidMethodCallMutator]MSP[N] } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) {
return ( T ) openFile ( str ) ; MST[ReturnValsMutator]MSP[S] } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; }
return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return ( T ) createURL ( str ) ; }
public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( lr_7 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File [] createFiles ( final String str ) {
return new URL ( str ) ; } catch ( final MalformedURLException e ) { throw new ParseException ( lr_6 + str ) ; MST[ConstructorCallMutator]MSP[S] } } public static File createFile ( final String str ) { return new File ( str ) ; }
public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) {
else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) MST[rv.ROR5Mutator]MSP[N] {
public static Number createNumber ( final String str ) throws ParseException { try { if ( str . indexOf ( '.' ) != - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return Double . valueOf ( str ) ; } return Long . valueOf ( str ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) {
str = str . substring ( 1 , length - 1 ) ; } return str ; }
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR4Mutator]MSP[S] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR5Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR2Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR1Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR3Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR4Mutator]MSP[N] } return str ; }
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR1Mutator]MSP[S] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[MathMutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR3Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
else if ( str . startsWith ( lr_2 ) ) MST[rv.ROR2Mutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[MathMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ABSMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[InlineConstantMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[ReturnValsMutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ABSMutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI1Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI3Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[experimental.NakedReceiverMutator]MSP[S] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[NegateConditionalsMutator]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR5Mutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI3Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR1Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR3Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.ABSMutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; } return str ; MST[ReturnValsMutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI3Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[InlineConstantMutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[ArgumentPropagationMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI2Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[S] {
str = str . substring ( 1 , length - 1 ) ; } return str ; MST[EmptyObjectReturnValsMutator]MSP[N] }
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI2Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[S] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; MST[ReturnValsMutator]MSP[S] } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR4Mutator]MSP[S] { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[ReturnValsMutator]MSP[S] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOR2Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[NegateConditionalsMutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; MST[EmptyObjectReturnValsMutator]MSP[S] } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[N] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR6Mutator]MSP[S] }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; MST[EmptyObjectReturnValsMutator]MSP[S] } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR3Mutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR4Mutator]MSP[N] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR2Mutator]MSP[S] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; MST[ReturnValsMutator]MSP[N] } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR1Mutator]MSP[S] }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[rv.CRCR5Mutator]MSP[N] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NegateConditionalsMutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[experimental.NakedReceiverMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[NonVoidMethodCallMutator]MSP[S] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[InlineConstantMutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[experimental.NakedReceiverMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOD2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR5Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return str . substring ( 2 , str . length () ) ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR1Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOD2Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR3Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR2Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[ConditionalsBoundaryMutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI4Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) MST[NegateConditionalsMutator]MSP[N] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[NonVoidMethodCallMutator]MSP[S] { return str . substring ( 2 , str . length () ) ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI1Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[NonVoidMethodCallMutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } return str ; }
str = str . substring ( 1 , length - 1 ) ; MST[rv.CRCR6Mutator]MSP[N] } return str ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[InlineConstantMutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR6Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR5Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR2Mutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR3Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.CRCR4Mutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[NonVoidMethodCallMutator]MSP[N] {
static String stripLeadingHyphens ( final String str ) { if ( str == null ) MST[rv.ROR5Mutator]MSP[N] { return null ; } if ( str . startsWith ( lr_1 ) ) { return str . substring ( 2 , str . length () ) ; }
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR1Mutator]MSP[S] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOD1Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR6Mutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ; MST[NonVoidMethodCallMutator]MSP[N]
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[experimental.NakedReceiverMutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.UOI4Mutator]MSP[N] {
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.ROR5Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.UOI4Mutator]MSP[N] } return str ; }
static String stripLeadingHyphens ( final String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( lr_1 ) ) MST[rv.ROR2Mutator]MSP[N] { return str . substring ( 2 , str . length () ) ; }
else if ( str . startsWith ( lr_2 ) ) { return str . substring ( 1 , str . length () ) ; MST[rv.CRCR2Mutator]MSP[S] } return str ; } static String stripLeadingAndTrailingQuotes ( String str ) { final int length = str . length () ;
if ( length > 1 && str . startsWith ( lr_3 ) && str . endsWith ( lr_3 ) && str . substring ( 1 , length - 1 ) . indexOf ( '"' ) == - 1 ) MST[rv.AOR4Mutator]MSP[N] {
str = str . substring ( 1 , length - 1 ) ; MST[rv.AOD1Mutator]MSP[N] } return str ; }
private void checkCapacity ( int minNewSize ) { Validate . isTrue ( minNewSize >= size ) ; int curSize = keys . length ; if ( curSize >= minNewSize ) return; int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity ; if ( minNewSize > newSize )
newSize = minNewSize ; keys = copyOf ( keys , newSize ) ; vals = copyOf ( vals , newSize ) ; } private static String [] copyOf ( String [] orig , int size ) { final String [] copy = new String [ size ] ;
System . arraycopy ( orig , 0 , copy , 0 , Math . min ( orig . length , size ) ) ; return copy ; } int indexOfKey ( String key ) { Validate . notNull ( key ) ;
for ( int i = 0 ; i < size ; i ++ ) { if ( key . equals ( keys [ i ] ) ) return i ; } return NotFound ; } private int indexOfKeyIgnoreCase ( String key ) { Validate . notNull ( key ) ;
for ( int i = 0 ; i < size ; i ++ ) { if ( key . equalsIgnoreCase ( keys [ i ] ) ) return i ; } return NotFound ; } static String checkNotNull ( String val ) {
return val == null ? EmptyString : val ; } public String get ( String key ) { int i = indexOfKey ( key ) ; return i == NotFound ? EmptyString : checkNotNull ( vals [ i ] ) ; } public String getIgnoreCase ( String key ) {
int i = indexOfKeyIgnoreCase ( key ) ; return i == NotFound ? EmptyString : checkNotNull ( vals [ i ] ) ; } public Attributes add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ;
vals [ size ] = value ; size ++ ; return this ; } public Attributes put ( String key , String value ) { Validate . notNull ( key ) ; int i = indexOfKey ( key ) ; if ( i != NotFound )
vals [ i ] = value ; else add ( key , value ) ; return this ; } void putIgnoreCase ( String key , String value ) { int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) {
vals [ i ] = value ; if ( ! keys [ i ] . equals ( key ) ) keys [ i ] = key ; } else add ( key , value ) ; } public Attributes put ( String key , boolean value ) {
if ( value ) putIgnoreCase ( key , null ) ; else remove ( key ) ; return this ; } public Attributes put ( Attribute attribute ) { Validate . notNull ( attribute ) ; put ( attribute . getKey () , attribute . getValue () ) ;
attribute . parent = this ; return this ; } private void remove ( int index ) { Validate . isFalse ( index >= size ) ; int shifted = size - index - 1 ; if ( shifted > 0 ) {
System . arraycopy ( keys , index + 1 , keys , index , shifted ) ; System . arraycopy ( vals , index + 1 , vals , index , shifted ) ; } size -- ; keys [ size ] = null ;
vals [ size ] = null ; } public void remove ( String key ) { int i = indexOfKey ( key ) ; if ( i != NotFound ) remove ( i ) ; } public void removeIgnoreCase ( String key ) {
int i = indexOfKeyIgnoreCase ( key ) ; if ( i != NotFound ) remove ( i ) ; } public boolean hasKey ( String key ) { return indexOfKey ( key ) != NotFound ; } public boolean hasKeyIgnoreCase ( String key ) {
return indexOfKeyIgnoreCase ( key ) != NotFound ; } public boolean hasDeclaredValueForKey ( String key ) { int i = indexOfKey ( key ) ; return i != NotFound && vals [ i ] != null ; } public boolean hasDeclaredValueForKeyIgnoreCase ( String key ) {
int i = indexOfKeyIgnoreCase ( key ) ; return i != NotFound && vals [ i ] != null ; } public int size () { int s = 0 ; for ( int i = 0 ; i < size ; i ++ ) {
if ( ! isInternalKey ( keys [ i ] ) ) s ++ ; } return s ; } public boolean isEmpty () { return size == 0 ; } public void addAll ( Attributes incoming ) { if ( incoming . size () == 0 ) return;
checkCapacity ( size + incoming . size ) ; for ( Attribute attr : incoming ) { put ( attr ) ; } } @Override public boolean hasNext () { while ( i < size ) { if ( isInternalKey ( keys [ i ] ) ) i ++ ;
else break; } return i < size ; } @Override public Attribute next () { final Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; i ++ ; return attr ; } @Override public void remove () {
Attributes . this . remove ( -- i ) ; } public List < Attribute > asList () { ArrayList < Attribute > list = new ArrayList <> ( size ) ; for ( int i = 0 ; i < size ; i ++ ) {
if ( isInternalKey ( keys [ i ] ) ) continue; Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; list . add ( attr ) ; } return Collections . unmodifiableList ( list ) ; }
public Map < String , String > dataset () { return new Dataset ( this ) ; } public String html () { StringBuilder sb = StringUtil . borrowBuilder () ; try { html ( sb , ( new Document ( lr_1 ) ) . outputSettings () ) ;
} catch ( IOException e ) { throw new SerializationException ( e ) ; } return StringUtil . releaseBuilder ( sb ) ; } final void html ( final Appendable accum , final Document . OutputSettings out ) throws IOException { final int sz = size ;
for ( int i = 0 ; i < sz ; i ++ ) { if ( isInternalKey ( keys [ i ] ) ) continue; final String key = keys [ i ] ; final String val = vals [ i ] ;
accum . append ( ' ' ) . append ( key ) ; if ( ! Attribute . shouldCollapseAttribute ( key , val , out ) ) { accum . append ( lr_2 ) ;
Entities . escape ( accum , val == null ? EmptyString : val , out , true , false , false ) ; accum . append ( '"' ) ; } } } @Override public String toString () { return html () ; } @Override
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass () ) return false ; Attributes that = ( Attributes ) o ;
if ( size != that . size ) return false ; if ( ! Arrays . equals ( keys , that . keys ) ) return false ; return Arrays . equals ( vals , that . vals ) ; } @Override public int hashCode () {
int result = size ; result = 31 * result + Arrays . hashCode ( keys ) ; result = 31 * result + Arrays . hashCode ( vals ) ; return result ; } @Override public Attributes clone () { Attributes clone ; try {
clone = ( Attributes ) super . clone () ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . size = size ; keys = copyOf ( keys , size ) ; vals = copyOf ( vals , size ) ;
return clone ; } public void normalize () { for ( int i = 0 ; i < size ; i ++ ) { keys [ i ] = lowerCase ( keys [ i ] ) ; } } public int deduplicate ( ParseSettings settings ) {
if ( isEmpty () ) return 0 ; boolean preserve = settings . preserveAttributeCase () ; int dupes = 0 ; OUTER: for ( int i = 0 ; i < keys . length ; i ++ ) {
for ( int j = i + 1 ; j < keys . length ; j ++ ) { if ( keys [ j ] == null ) continue OUTER;
if ( ( preserve && keys [ i ] . equals ( keys [ j ] ) ) || ( ! preserve && keys [ i ] . equalsIgnoreCase ( keys [ j ] ) ) ) { dupes ++ ; remove ( j ) ; j -- ; }
} } return dupes ; } @Override public Set < Entry < String , String > > entrySet () { return new EntrySet () ; } @Override public String put ( String key , String value ) { String dataKey = dataKey ( key ) ;
String oldValue = attributes . hasKey ( dataKey ) ? attributes . get ( dataKey ) : null ; attributes . put ( dataKey , value ) ; return oldValue ; } @Override public Iterator < Map . Entry < String , String > > iterator () {
return new DatasetIterator () ; } @Override public int size () { int count = 0 ; Iterator iter = new DatasetIterator () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
while ( attrIter . hasNext () ) { attr = attrIter . next () ; if ( attr . isDataAttribute () ) return true ; } return false ; } public Entry < String , String > next () {
return new Attribute ( attr . getKey () . substring ( dataPrefix . length () ) , attr . getValue () ) ; } public void remove () { attributes . remove ( attr . getKey () ) ; } private static String dataKey ( String key ) {
return dataPrefix + key ; } static String internalKey ( String key ) { return InternalPrefix + key ; } private boolean isInternalKey ( String key ) { return key != null && key . length () > 1 && key . charAt ( 0 ) == InternalPrefix ; }
return new DatasetIterator () ; MST[ConstructorCallMutator]MSP[N] } @Override public int size () { int count = 0 ; Iterator iter = new DatasetIterator () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
return new DatasetIterator () ; } @Override public int size () { int count = 0 ; Iterator iter = new DatasetIterator () ; while ( iter . hasNext () ) count ++ ; MST[IncrementsMutator]MSP[S] return count ; } public boolean hasNext () {
return new DatasetIterator () ; MST[NullReturnValsMutator]MSP[N] } @Override public int size () { int count = 0 ; Iterator iter = new DatasetIterator () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
return new DatasetIterator () ; MST[ReturnValsMutator]MSP[N] } @Override public int size () { int count = 0 ; Iterator iter = new DatasetIterator () ; while ( iter . hasNext () ) count ++ ; return count ; } public boolean hasNext () {
return new DatasetIterator () ; } @Override public int size () { int count = 0 ; Iterator iter = new DatasetIterator () ; while ( iter . hasNext () ) count ++ ; MST[experimental.RemoveIncrementsMutator]MSP[S] return count ; } public boolean hasNext () {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ; while ( pos < remaining ) { if ( Arrays . binarySearch ( chars , val [ pos ] ) >= 0 ) break; pos ++ ; }
bufPos = pos ; return bufPos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeData () { int pos = bufPos ; final int start = pos ; final int remaining = bufLength ;
final char [] val = charBuf ; OUTER: while ( pos < remaining ) { switch ( val [ pos ] ) { case '&' : case '<' : case TokeniserState . nullChar : break OUTER; default: pos ++ ; } } bufPos = pos ;
return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeRawData () { int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
OUTER: while ( pos < remaining ) { switch ( val [ pos ] ) { case '<' : case TokeniserState . nullChar : break OUTER; default: pos ++ ; } } bufPos = pos ;
return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeTagName () { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ;
final char [] val = charBuf ; OUTER: while ( pos < remaining ) { switch ( val [ pos ] ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : case '/' : case '>' : case '<' :
case TokeniserState . nullChar : break OUTER; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToEnd () { bufferUp () ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= '0' && c <= '9' ) || ( c >= 'A' && c <= 'F' ) || ( c >= 'a' && c <= 'f' ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( seek == c ) return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ; } boolean matchesDigit () {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) {
bufPos += seq . length () ; return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return rangeEquals ( charBuf , start , count , cached ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[N] }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; MST[InlineConstantMutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seek == c ) MST[rv.UOI3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[NegateConditionalsMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR5Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[rv.ROR1Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR6Mutator]MSP[S] return lr_3 ;
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR3Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR3Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[NonVoidMethodCallMutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[InlineConstantMutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[InlineConstantMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI2Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] if ( count < 1 ) return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[InlineConstantMutator]MSP[N] bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI3Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR4Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[ReturnValsMutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[N] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[MathMutator]MSP[N] } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR1Mutator]MSP[N] int read = 0 ;
return val ; MST[ReturnValsMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { MST[rv.UOI3Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI2Mutator]MSP[N]
return val ; MST[rv.UOI4Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufPos = endPos ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR2Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR1Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR4Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] }
if ( seek == c ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI2Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[N] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
bufPos += seq . length () ; MST[NonVoidMethodCallMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR1Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI4Mutator]MSP[N] }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI1Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[NegateConditionalsMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[N] } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) MST[rv.ROR1Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI2Mutator]MSP[S] int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[N] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[NegateConditionalsMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; MST[PrimitiveReturnsMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR3Mutator]MSP[N] } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NonVoidMethodCallMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[EmptyObjectReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR3Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; MST[rv.CRCR6Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR4Mutator]MSP[S]
String cached = stringCache [ index ] ; MST[rv.ABSMutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[S] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[ReturnValsMutator]MSP[N] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[N] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.ABSMutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[N] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI2Mutator]MSP[S] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR6Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[S] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR3Mutator]MSP[S] return lr_3 ;
bufPos += seq . length () ; MST[rv.UOI3Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[InlineConstantMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR4Mutator]MSP[S] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI1Mutator]MSP[N] final char [] val = charBuf ;
int hash = 0 ; MST[rv.CRCR6Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI1Mutator]MSP[S] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[N] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[InlineConstantMutator]MSP[N] }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] stringCache [ index ] = cached ; } else {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.ABSMutator]MSP[S] final int remaining = bufLength ; final char [] val = charBuf ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR6Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR4Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ReturnValsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR5Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR1Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[InlineConstantMutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[InlineConstantMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR5Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR1Mutator]MSP[N]
if ( upScan != upTarget ) MST[rv.ROR4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
bufPos = endPos ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[S] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( seek == c ) MST[NegateConditionalsMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[NegateConditionalsMutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[ArgumentPropagationMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI2Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seek == c ) return true ; MST[ReturnValsMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[InlineConstantMutator]MSP[N] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR3Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR3Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI2Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR4Mutator]MSP[N] return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR5Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR6Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[InlineConstantMutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[N] return i - bufPos ; } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[NegateConditionalsMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.ABSMutator]MSP[N] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[N]
int hash = 0 ; MST[rv.CRCR5Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR3Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR5Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[experimental.RemoveIncrementsMutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI2Mutator]MSP[S] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[S]
if ( upScan != upTarget ) MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI1Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[InlineConstantMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[N] bufPos ++ ;
return rangeEquals ( charBuf , start , count , cached ) ; MST[NonVoidMethodCallMutator]MSP[S] }
if ( c >= '0' && c <= '9' ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NonVoidMethodCallMutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[S]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[InlineConstantMutator]MSP[S] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[InlineConstantMutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI4Mutator]MSP[S] final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[S] } } return cached ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufPos = endPos ; MST[rv.UOI2Mutator]MSP[N] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR5Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.UOI4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR4Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos += seq . length () ; return true ; MST[InlineConstantMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[N] } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR1Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI4Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[experimental.RemoveIncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S] for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR5Mutator]MSP[N] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[N] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR5Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[S] } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR4Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[N] }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI1Mutator]MSP[N] break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR4Mutator]MSP[N]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR1Mutator]MSP[N]
return val ; MST[rv.UOI3Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ABSMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR1Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR1Mutator]MSP[S]
if ( seek == c ) MST[rv.UOI3Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR4Mutator]MSP[N] }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOD2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR3Mutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[InlineConstantMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[S] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } private boolean isEmptyNoBufferUp () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[N]
if ( seek == c ) return true ; MST[rv.CRCR2Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR6Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI4Mutator]MSP[N] return lr_3 ;
while ( read <= minReadAheadLen ) { MST[rv.ROR1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI3Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { MST[ConditionalsBoundaryMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR1Mutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR2Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD1Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR5Mutator]MSP[S] return lr_3 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR2Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.ABSMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR3Mutator]MSP[N] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR3Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI3Mutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI1Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR4Mutator]MSP[N] }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N] } else {
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR4Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI1Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.ABSMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] break; read += thisRead ; }
private void bufferUp () { MST[rv.CRCR3Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[InlineConstantMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[BooleanTrueReturnValsMutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR3Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ;
if ( seek == c ) return true ; } return false ; MST[rv.CRCR1Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR3Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI3Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while ( read <= minReadAheadLen ) { MST[NegateConditionalsMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] }
bufSplitPoint = 0 ; MST[rv.CRCR6Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[MathMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI1Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR5Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[S] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.ABSMutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { MST[rv.UOI3Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI3Mutator]MSP[N]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI4Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD1Mutator]MSP[N] } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR1Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR2Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR4Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private void bufferUp () { if ( readFully ) MST[NegateConditionalsMutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR3Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[N] break OUTER; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOD2Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[N] } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR5Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR1Mutator]MSP[N] while ( count -- != 0 ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR2Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[NegateConditionalsMutator]MSP[N] break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[N] return consumed ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR5Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[NonVoidMethodCallMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR5Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[S] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI2Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[InlineConstantMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR2Mutator]MSP[N] }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI4Mutator]MSP[N]
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI2Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR5Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] stringCache [ index ] = cached ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ;
String cached = stringCache [ index ] ; MST[rv.UOI2Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR3Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[MathMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
private void bufferUp () { if ( readFully ) MST[rv.ROR5Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.ABSMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN2Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[MathMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR6Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seek == c ) MST[rv.ROR4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI1Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR4Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.ABSMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR4Mutator]MSP[N] } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR1Mutator]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NegateConditionalsMutator]MSP[S]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.ABSMutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI4Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOR2Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOD2Mutator]MSP[N] } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NonVoidMethodCallMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR2Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ABSMutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[S] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.ABSMutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR6Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[N]
String cached = stringCache [ index ] ; MST[rv.UOI3Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[S] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[N] bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[N] break OUTER; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR1Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[N] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOR2Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( startChar != charBuf [ offset ] )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI2Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR5Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR2Mutator]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI4Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[NegateConditionalsMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[N] return consumed ;
return consumeToEnd () ; MST[NonVoidMethodCallMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR4Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[InlineConstantMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanFalseReturnValsMutator]MSP[S] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR1Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[N]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] bufPos ++ ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] break OUTER; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR6Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[N]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[IncrementsMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; MST[VoidMethodCallMutator]MSP[N] if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ; MST[ReturnValsMutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { MST[rv.ROR5Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR3Mutator]MSP[N]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR6Mutator]MSP[N] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR4Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR3Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( upScan != upTarget ) MST[rv.ABSMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR5Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[experimental.MemberVariableMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR5Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[IncrementsMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI2Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR5Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[S] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NonVoidMethodCallMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
bufPos += seq . length () ; return true ; MST[rv.CRCR4Mutator]MSP[N] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR6Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[NonVoidMethodCallMutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR5Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[NegateConditionalsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ;
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[MathMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ABSMutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI1Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR4Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.ABSMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NegateConditionalsMutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.UOI1Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return false ; MST[ReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[InlineConstantMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI2Mutator]MSP[N] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[InlineConstantMutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[N] }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI3Mutator]MSP[N] final char [] val = charBuf ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[MathMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR5Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[ReturnValsMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[EmptyObjectReturnValsMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR5Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR3Mutator]MSP[N] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI3Mutator]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[ReturnValsMutator]MSP[S] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR5Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR4Mutator]MSP[N] break OUTER; }
if ( seek == c ) MST[rv.ROR3Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI4Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[ReturnValsMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( seek == c ) MST[rv.UOI2Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR3Mutator]MSP[N] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { MST[rv.ROR5Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR1Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR2Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR1Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[NegateConditionalsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR4Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[N] } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI1Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR4Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return val ; MST[rv.UOI2Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; return consumed ; MST[ReturnValsMutator]MSP[S] } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI1Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR2Mutator]MSP[N] } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[MathMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[N] bufPos ++ ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[S] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[N] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[N] return consumed ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI2Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[NegateConditionalsMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
private void bufferUp () { MST[rv.CRCR2Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.AOD2Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR5Mutator]MSP[S] return lr_3 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI1Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR1Mutator]MSP[N] return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR3Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.ABSMutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[InlineConstantMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR3Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[NegateConditionalsMutator]MSP[N] return lr_3 ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI3Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI3Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI4Mutator]MSP[N] } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR3Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI4Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[experimental.MemberVariableMutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
bufPos += seq . length () ; MST[experimental.MemberVariableMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR5Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; MST[EmptyObjectReturnValsMutator]MSP[N] } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ABSMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
bufPos = endPos ; MST[rv.UOI3Mutator]MSP[S] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[S]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.ABSMutator]MSP[S] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; MST[InlineConstantMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[S] else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[BooleanTrueReturnValsMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
int hash = 0 ; int offset = start ; MST[rv.UOI3Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[InlineConstantMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[InlineConstantMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[N] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[ReturnValsMutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[EmptyObjectReturnValsMutator]MSP[N] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ABSMutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI1Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR3Mutator]MSP[N]
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR4Mutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NegateConditionalsMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD1Mutator]MSP[N] } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[InlineConstantMutator]MSP[N] while ( count -- != 0 ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[ReturnValsMutator]MSP[N] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { MST[NegateConditionalsMutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) MST[rv.UOI4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI3Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ConditionalsBoundaryMutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD1Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR2Mutator]MSP[N]
if ( seek == c ) MST[rv.ROR5Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N] char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[NonVoidMethodCallMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR1Mutator]MSP[N] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR6Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR1Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI3Mutator]MSP[N] } } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[N] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI3Mutator]MSP[N] } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI4Mutator]MSP[S] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOD1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[InlineConstantMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[InlineConstantMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR2Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ABSMutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI3Mutator]MSP[N]
bufPos += seq . length () ; return true ; MST[ReturnValsMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[S] else break; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR3Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI2Mutator]MSP[N] }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI2Mutator]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR5Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI4Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[InlineConstantMutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N]
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR5Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI4Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR2Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[MathMutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.ABSMutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR4Mutator]MSP[S] return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[ReturnValsMutator]MSP[N] }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) MST[rv.ROR3Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.ROR2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI2Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[ReturnValsMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufPos += seq . length () ; return true ; MST[rv.CRCR5Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI4Mutator]MSP[S]
return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[N] while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[S] } return - 1 ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ABSMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI3Mutator]MSP[N] }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[S]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return val ; MST[rv.ABSMutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[rv.ROR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[IncrementsMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ; else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[MathMutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NegateConditionalsMutator]MSP[N] bufPos ++ ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[experimental.RemoveIncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[S] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.ABSMutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI2Mutator]MSP[S]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[N] if ( count < 1 ) return lr_3 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ROR2Mutator]MSP[N] return lr_3 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[InlineConstantMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[experimental.MemberVariableMutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[IncrementsMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ; MST[rv.CRCR6Mutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR5Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR3Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR5Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR4Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR3Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[N] } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR2Mutator]MSP[N] } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI1Mutator]MSP[N] } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.UOI3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR4Mutator]MSP[N] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[PrimitiveReturnsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufPos += seq . length () ; MST[rv.UOI2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI3Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR1Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.UOI2Mutator]MSP[N] final char [] val = charBuf ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
bufPos += seq . length () ; MST[rv.AOD2Mutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[ArgumentPropagationMutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[S] } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR4Mutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR5Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR1Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR2Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR1Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR3Mutator]MSP[N] break OUTER; }
pos ++ ; MST[IncrementsMutator]MSP[N] } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) MST[rv.ROR3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR2Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOR3Mutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.ABSMutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[S] return consumed ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR2Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD1Mutator]MSP[N]
if ( seek == c ) MST[rv.UOI1Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR2Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI4Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[N] bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR3Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[experimental.RemoveIncrementsMutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[N]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR3Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int start = bufPos ; while ( bufPos < bufLength ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.ABSMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR6Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos += seq . length () ; MST[rv.UOI4Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI4Mutator]MSP[N] } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR3Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[S] if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[N] if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
private void bufferUp () { MST[rv.CRCR1Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[NegateConditionalsMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[NegateConditionalsMutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR1Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI3Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR5Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI1Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR5Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[experimental.MemberVariableMutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.ABSMutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD1Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[InlineConstantMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI2Mutator]MSP[S] for ( char seek : seq ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR3Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
int hash = 0 ; int offset = start ; MST[rv.ABSMutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ROR5Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR6Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[PrimitiveReturnsMutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { MST[rv.ROR3Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR2Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return rangeEquals ( charBuf , start , count , cached ) ; MST[BooleanTrueReturnValsMutator]MSP[S] }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[N] return consumed ; } else {
return false ; MST[BooleanTrueReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.ABSMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR6Mutator]MSP[N] while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; MST[rv.UOI2Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.UOI2Mutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[MathMutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI2Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[N] return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; MST[rv.ABSMutator]MSP[N] final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } else {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[ConditionalsBoundaryMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR5Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI4Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[rv.ROR3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR3Mutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; MST[NonVoidMethodCallMutator]MSP[S] if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD2Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR4Mutator]MSP[N] } } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[IncrementsMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( upScan != upTarget ) return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[MathMutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR5Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI1Mutator]MSP[N] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ROR1Mutator]MSP[N] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
String cached = stringCache [ index ] ; if ( cached == null ) { MST[NegateConditionalsMutator]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
String cached = stringCache [ index ] ; if ( cached == null ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.AOR1Mutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[MathMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { MST[rv.CRCR4Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[NegateConditionalsMutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[N] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI3Mutator]MSP[N] break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI3Mutator]MSP[N] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; MST[rv.ABSMutator]MSP[N] final char [] val = charBuf ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR4Mutator]MSP[N] bufPos ++ ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR3Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR6Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR2Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.ABSMutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR5Mutator]MSP[S] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI4Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR2Mutator]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR3Mutator]MSP[N] while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR6Mutator]MSP[N]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) MST[rv.UOI4Mutator]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[S] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI3Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ABSMutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOD2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD2Mutator]MSP[N] return consumed ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) MST[rv.UOI4Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[N] stringCache [ index ] = cached ; } else {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[ConditionalsBoundaryMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI1Mutator]MSP[S]
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
case TokeniserState . nullChar : break OUTER; } pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToEnd () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI4Mutator]MSP[S] }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR5Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N]
return false ; MST[rv.CRCR3Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR3Mutator]MSP[S] int i = start ; int j = 0 ; while ( count -- != 0 ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR1Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI1Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
bufPos += seq . length () ; MST[rv.AOR3Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR5Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR1Mutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR6Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.ABSMutator]MSP[N] bufPos += offset ; return consumed ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI4Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ABSMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR5Mutator]MSP[S]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR5Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[VoidMethodCallMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S] char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR5Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI2Mutator]MSP[S] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI1Mutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI4Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR1Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR4Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
if ( seek == c ) return true ; MST[InlineConstantMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[ReturnValsMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[ReturnValsMutator]MSP[N] }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR4Mutator]MSP[N]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR2Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[N] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; MST[rv.UOI3Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[NegateConditionalsMutator]MSP[N] }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[NegateConditionalsMutator]MSP[N] return i - bufPos ; } return - 1 ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[IncrementsMutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
String cached = stringCache [ index ] ; MST[rv.UOI1Mutator]MSP[N] if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} else if ( bufLength - bufPos < seq . length () ) { MST[ConditionalsBoundaryMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR5Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[N] return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR2Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.ABSMutator]MSP[N] }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI1Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI2Mutator]MSP[S] return consumed ; } else {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[S] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR5Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR1Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.ABSMutator]MSP[N] return consumed ; } else {
return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI4Mutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR1Mutator]MSP[N] char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI3Mutator]MSP[N] }
bufPos += seq . length () ; return true ; MST[rv.CRCR2Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[ConditionalsBoundaryMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI3Mutator]MSP[S] } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.UOI1Mutator]MSP[S]
bufSplitPoint = 0 ; MST[rv.CRCR5Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR5Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR3Mutator]MSP[N] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD1Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( seek == c ) MST[rv.UOI1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI1Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[IncrementsMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[MathMutator]MSP[N] return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR2Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.UOI1Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI3Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[ReturnValsMutator]MSP[N] if ( count < 1 ) return lr_3 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI4Mutator]MSP[S]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.CRCR6Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ABSMutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI2Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI3Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[ConditionalsBoundaryMutator]MSP[N] if ( startChar != charBuf [ offset ] )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOD2Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufPos = endPos ; MST[rv.ABSMutator]MSP[S] return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ABSMutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; MST[experimental.MemberVariableMutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI2Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR4Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ABSMutator]MSP[S] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD2Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI4Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR6Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI2Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[NegateConditionalsMutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { MST[rv.CRCR3Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI1Mutator]MSP[N] } } return - 1 ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[S]
if ( upScan != upTarget ) return false ; MST[rv.CRCR3Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI2Mutator]MSP[N] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.UOI1Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[ReturnValsMutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR4Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR4Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( upScan != upTarget ) MST[rv.ROR5Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[ReturnValsMutator]MSP[N] } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR2Mutator]MSP[S] return lr_3 ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; } return false ; MST[InlineConstantMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.ABSMutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[ConditionalsBoundaryMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NegateConditionalsMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NegateConditionalsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOD2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[S] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.UOI4Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ABSMutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NonVoidMethodCallMutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI3Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR2Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[NegateConditionalsMutator]MSP[N]
} else if ( bufLength - bufPos < seq . length () ) { MST[NonVoidMethodCallMutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI3Mutator]MSP[S] while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI1Mutator]MSP[N] break OUTER; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[N] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[ReturnValsMutator]MSP[N] } else {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
if ( c >= '0' && c <= '9' ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[MathMutator]MSP[N]
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR6Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR5Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { MST[rv.CRCR6Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[ConditionalsBoundaryMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR4Mutator]MSP[N] int read = 0 ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( upScan != upTarget ) MST[NegateConditionalsMutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.CRCR6Mutator]MSP[N]
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; int pos = bufPos ; final int start = pos ; MST[rv.UOI4Mutator]MSP[N] final int remaining = bufLength ; final char [] val = charBuf ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR3Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOD2Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI2Mutator]MSP[N] else break; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[rv.CRCR3Mutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.AOR1Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; MST[rv.CRCR1Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI3Mutator]MSP[S] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[N] return consumed ; } else {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.UOI1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.CRCR6Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return false ; MST[rv.CRCR5Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] return lr_3 ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI1Mutator]MSP[N] while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
bufPos += seq . length () ; MST[rv.AOR1Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI3Mutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR3Mutator]MSP[N] }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[BooleanTrueReturnValsMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[rv.CRCR3Mutator]MSP[N] int read = 0 ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR1Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.CRCR1Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI1Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR4Mutator]MSP[S] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI1Mutator]MSP[S] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[InlineConstantMutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.ABSMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI1Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) MST[rv.ABSMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; MST[EmptyObjectReturnValsMutator]MSP[N]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI3Mutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[ReturnValsMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ROR3Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.CRCR2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[N]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.CRCR6Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[NonVoidMethodCallMutator]MSP[N] bufPos ++ ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] stringCache [ index ] = cached ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; MST[rv.UOI1Mutator]MSP[N] if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[ConditionalsBoundaryMutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOD2Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI3Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[BooleanFalseReturnValsMutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( startChar != charBuf [ offset ] )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; MST[rv.CRCR3Mutator]MSP[N] if ( thisRead <= 0 ) break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] if ( matches ( seq ) ) {
return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[MathMutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while ( read <= minReadAheadLen ) { MST[rv.ABSMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; MST[rv.CRCR3Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ )
return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR1Mutator]MSP[N] break OUTER; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI2Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOD1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ROR1Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.ABSMutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.UOI2Mutator]MSP[S] } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[N] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR5Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[MathMutator]MSP[S] else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR1Mutator]MSP[N]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ROR2Mutator]MSP[N] break OUTER; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI2Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR3Mutator]MSP[S] } private boolean isEmptyNoBufferUp () {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.CRCR6Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[ConditionalsBoundaryMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR1Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( upScan != upTarget ) return false ; } return true ; MST[ReturnValsMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.UOI1Mutator]MSP[N]
if ( seek == c ) return true ; MST[rv.CRCR6Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI4Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI2Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[N] bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI4Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR1Mutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
bufPos += seq . length () ; return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; MST[rv.CRCR6Mutator]MSP[N] }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR4Mutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[N] bufPos ++ ; else break; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOR1Mutator]MSP[N] } return - 1 ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR5Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ROR5Mutator]MSP[N]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR4Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.ABSMutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI1Mutator]MSP[S] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[ConditionalsBoundaryMutator]MSP[N] }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.AOR1Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[rv.ROR4Mutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
private void bufferUp () { if ( readFully ) MST[rv.ROR2Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ABSMutator]MSP[N] if ( startChar != charBuf [ offset ] )
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR2Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.UOI3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR4Mutator]MSP[S] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI4Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI3Mutator]MSP[N] return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOR4Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR5Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI3Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI1Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI4Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR1Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[ConditionalsBoundaryMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI2Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI3Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR4Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR4Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S] for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR1Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; MST[InlineConstantMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; MST[rv.CRCR5Mutator]MSP[N] } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOD2Mutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ROR3Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[InlineConstantMutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOD2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI4Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[InlineConstantMutator]MSP[S]
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR5Mutator]MSP[N] bufPos ++ ;
if ( seek == c ) return true ; MST[rv.CRCR5Mutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI1Mutator]MSP[S] } } return cached ; }
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; MST[EmptyObjectReturnValsMutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI1Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[MathMutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] } private boolean isEmptyNoBufferUp () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[ReturnValsMutator]MSP[N] } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.AOD2Mutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ABSMutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[S] else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return i - bufPos ; } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI1Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.ABSMutator]MSP[S] } } return cached ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOD1Mutator]MSP[N] return consumed ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.AOR3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[S] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR6Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.CRCR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[NonVoidMethodCallMutator]MSP[N] char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S] char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; MST[ReturnValsMutator]MSP[N] } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI1Mutator]MSP[N] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR6Mutator]MSP[N] }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR5Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI2Mutator]MSP[S] int i = start ; int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.UOI4Mutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[IncrementsMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { MST[rv.CRCR2Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR5Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI4Mutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[MathMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR2Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; MST[rv.CRCR5Mutator]MSP[N] while ( count -- != 0 ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.ABSMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; MST[rv.CRCR3Mutator]MSP[S] else break; }
bufPos = endPos ; return consumed ; } } public String consumeToAny ( final char ... chars ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[S] int pos = bufPos ; final int start = pos ; final int remaining = bufLength ; final char [] val = charBuf ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR1Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.ROR4Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[IncrementsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR1Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[InlineConstantMutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.AOR4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[S] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI4Mutator]MSP[N] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR1Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR4Mutator]MSP[N] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR1Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[NegateConditionalsMutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.CRCR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( upScan != upTarget ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
while ( read <= minReadAheadLen ) { MST[rv.UOI1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI3Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[NegateConditionalsMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.UOI4Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI4Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI4Mutator]MSP[S] while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI1Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.ROR4Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.UOI4Mutator]MSP[N] break; read += thisRead ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[ReturnValsMutator]MSP[N] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[ConditionalsBoundaryMutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[MathMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[N] char c = charBuf [ bufPos ] ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[experimental.MemberVariableMutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[InlineConstantMutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI1Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.UOI2Mutator]MSP[N] } } return - 1 ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ABSMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
bufPos += seq . length () ; MST[rv.AOD1Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI2Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI1Mutator]MSP[N] return lr_3 ;
if ( c >= '0' && c <= '9' ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.ABSMutator]MSP[N] } return - 1 ; }
bufPos += seq . length () ; MST[rv.ABSMutator]MSP[N] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.AOR2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.CRCR6Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI4Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[BooleanTrueReturnValsMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.CRCR5Mutator]MSP[N] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.UOI2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.AOR3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return false ; MST[rv.CRCR1Mutator]MSP[S] for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
pos ++ ; } bufPos = pos ; MST[experimental.MemberVariableMutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI4Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[MathMutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[BooleanTrueReturnValsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.ABSMutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[S] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI4Mutator]MSP[S]
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[rv.UOI2Mutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI4Mutator]MSP[N] } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[InlineConstantMutator]MSP[S] return lr_3 ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
pos ++ ; } bufPos = pos ; MST[rv.UOI1Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.AOR3Mutator]MSP[N]
while ( read <= minReadAheadLen ) { MST[rv.CRCR1Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[MathMutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR6Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.AOR1Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return bufPos >= bufLength ; MST[rv.ROR1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; MST[InlineConstantMutator]MSP[N] int read = 0 ;
if ( upScan != upTarget ) return false ; } return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI1Mutator]MSP[N] return consumed ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR1Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[ConditionalsBoundaryMutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.UOI3Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.UOI2Mutator]MSP[N] return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ROR1Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) MST[rv.ROR5Mutator]MSP[N] break; read += thisRead ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ; MST[rv.UOI3Mutator]MSP[S]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.UOI2Mutator]MSP[S]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI1Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[InlineConstantMutator]MSP[N] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
private void bufferUp () { MST[rv.CRCR5Mutator]MSP[N] if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.UOI4Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOR2Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
} else if ( bufLength - bufPos < seq . length () ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ROR4Mutator]MSP[S] if ( val [ pos ] == chars [ i ] ) break OUTER; }
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR2Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR4Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.ABSMutator]MSP[N] }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR1Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[rv.CRCR1Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] if ( startChar != charBuf [ offset ] )
unmark () ; MST[VoidMethodCallMutator]MSP[N] } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[rv.AOR4Mutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] bufPos ++ ; else break; }
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.UOI2Mutator]MSP[N]
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ;
if ( upScan != upTarget ) return false ; MST[ReturnValsMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.UOI4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR4Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.UOI1Mutator]MSP[N]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; MST[rv.UOI4Mutator]MSP[S] return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI3Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR4Mutator]MSP[N]
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; MST[rv.UOI3Mutator]MSP[S] for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ABSMutator]MSP[S]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.UOI1Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ROR2Mutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
return consumeToEnd () ; MST[ReturnValsMutator]MSP[N] } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.UOI3Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR5Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[NegateConditionalsMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.ABSMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while ( read <= minReadAheadLen ) { MST[rv.CRCR4Mutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR1Mutator]MSP[S] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
return bufPos >= bufLength ; MST[rv.ROR4Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.UOI2Mutator]MSP[S]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.CRCR5Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_IF]MSP[S] bufPos ++ ; else break; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.ROR2Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.CRCR5Mutator]MSP[N]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOD2Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
if ( c >= '0' && c <= '9' ) bufPos ++ ; MST[rv.UOI3Mutator]MSP[N] else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOD1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.CRCR6Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.UOI3Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR6Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
reader . reset () ; if ( read > 0 ) { MST[rv.ROR2Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
bufSplitPoint = 0 ; bufferUp () ; MST[VoidMethodCallMutator]MSP[S] bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.ROR5Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[rv.UOI3Mutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[NegateConditionalsMutator]MSP[S] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI4Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[S]
if ( seek == c ) return true ; } return false ; MST[BooleanTrueReturnValsMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.ROR2Mutator]MSP[S] } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI3Mutator]MSP[N] break OUTER; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR5Mutator]MSP[N] bufPos ++ ; else break; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; MST[InlineConstantMutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI3Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[RemoveConditionalMutator_ORDER_IF]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S]
pos ++ ; } bufPos = pos ; MST[rv.UOI4Mutator]MSP[N] return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NonVoidMethodCallMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[NegateConditionalsMutator]MSP[S] char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.UOI3Mutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOD1Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; MST[rv.ABSMutator]MSP[S]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.UOI2Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.UOI2Mutator]MSP[N] break OUTER; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOR2Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; MST[rv.CRCR3Mutator]MSP[N] for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] )
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.ABSMutator]MSP[N] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.UOI3Mutator]MSP[N] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
} boolean matches ( String seq ) { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[NegateConditionalsMutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI4Mutator]MSP[N] stringCache [ index ] = cached ; } else {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.AOR3Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ABSMutator]MSP[S]
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[InlineConstantMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.ABSMutator]MSP[N] return lr_3 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.ROR2Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[InlineConstantMutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[NegateConditionalsMutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[MathMutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI1Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[experimental.MemberVariableMutator]MSP[S]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ROR1Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI4Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) MST[rv.ABSMutator]MSP[N] break OUTER; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOD2Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR2Mutator]MSP[N] return consumed ; } else {
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.ROR5Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
return bufPos >= bufLength ; MST[rv.CRCR6Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI2Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[ReturnValsMutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.UOI4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ; else break; }
int hash = 0 ; MST[rv.CRCR3Mutator]MSP[S] int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[NonVoidMethodCallMutator]MSP[N] bufPos += offset ; return consumed ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[ReturnValsMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.ABSMutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { if ( startChar != charBuf [ offset ] ) MST[rv.ABSMutator]MSP[N]
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.ROR2Mutator]MSP[N]
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOD1Mutator]MSP[S]
int nextIndexOf ( CharSequence seq ) { bufferUp () ; char startChar = seq . charAt ( 0 ) ; for ( int offset = bufPos ; offset < bufLength ; offset ++ ) { MST[rv.UOI1Mutator]MSP[N] if ( startChar != charBuf [ offset ] )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ; MST[experimental.MemberVariableMutator]MSP[N]
if ( seek == c ) MST[rv.UOI2Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) MST[NegateConditionalsMutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[rv.ROR1Mutator]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
bufSplitPoint = 0 ; MST[rv.CRCR3Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} else if ( bufLength - bufPos < seq . length () ) { MST[rv.UOI2Mutator]MSP[S] return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI2Mutator]MSP[S]
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { MST[rv.ROR4Mutator]MSP[S] for ( i = 0 ; i < charLen ; i ++ ) { if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.UOI3Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( seek == c ) return true ; } return false ; MST[ReturnValsMutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI1Mutator]MSP[N]
bufSplitPoint = 0 ; MST[rv.CRCR1Mutator]MSP[N] bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[S] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; MST[EmptyObjectReturnValsMutator]MSP[S] } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR3Mutator]MSP[S]
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[NonVoidMethodCallMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR3Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
if ( upScan != upTarget ) MST[rv.UOI3Mutator]MSP[S] return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI2Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR2Mutator]MSP[S] char c = charBuf [ bufPos ] ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ABSMutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[ReturnValsMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ABSMutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR4Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.ABSMutator]MSP[S]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; MST[rv.UOI4Mutator]MSP[N] if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.CRCR4Mutator]MSP[S] } private boolean isEmptyNoBufferUp () {
int hash = 0 ; int offset = start ; MST[rv.UOI4Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[MathMutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] bufPos ++ ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.AOR4Mutator]MSP[N] return consumed ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; MST[rv.CRCR2Mutator]MSP[N] } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; MST[rv.UOI3Mutator]MSP[N] if ( count < 1 ) return lr_3 ;
while ( read <= minReadAheadLen ) { MST[InlineConstantMutator]MSP[N] int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( seek == c ) return true ; } return false ; MST[rv.CRCR6Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR5Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; MST[experimental.MemberVariableMutator]MSP[N] bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI4Mutator]MSP[N] }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI3Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( upScan != upTarget ) return false ; MST[InlineConstantMutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; MST[rv.UOI1Mutator]MSP[S] } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI3Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.UOI4Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI2Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
if ( upScan != upTarget ) return false ; MST[rv.CRCR5Mutator]MSP[S] } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
bufPos += seq . length () ; MST[rv.AOR4Mutator]MSP[S] return true ; } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.UOI1Mutator]MSP[N] } final int index = hash & stringCache . length - 1 ;
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR6Mutator]MSP[S] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return bufPos >= bufLength ; MST[InlineConstantMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen ) MST[rv.UOI2Mutator]MSP[N]
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; } return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N] } boolean rangeEquals ( final int start , final int count , final String cached ) {
if ( rangeEquals ( charBuf , start , count , cached ) ) { MST[rv.ROR5Mutator]MSP[N] return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } } return cached ; }
return rangeEquals ( charBuf , start , count , cached ) ; MST[rv.UOI3Mutator]MSP[S] }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[MathMutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( seek == c ) return true ; MST[BooleanFalseReturnValsMutator]MSP[S] } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; MST[rv.UOI3Mutator]MSP[S] } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ABSMutator]MSP[S]
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.UOI1Mutator]MSP[S]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR3Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; MST[rv.AOR2Mutator]MSP[N] int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.CRCR1Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR3Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return val ; MST[rv.UOI1Mutator]MSP[N] } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[rv.UOI3Mutator]MSP[N] return i - bufPos ; } return - 1 ; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; MST[rv.AOR3Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[MathMutator]MSP[N] }
private void bufferUp () { if ( readFully ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI3Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.ABSMutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR2Mutator]MSP[S] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
int hash = 0 ; int offset = start ; MST[rv.UOI1Mutator]MSP[N] for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; MST[rv.UOI2Mutator]MSP[N] readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.ROR1Mutator]MSP[N]
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; MST[NonVoidMethodCallMutator]MSP[S] char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[InlineConstantMutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.UOI4Mutator]MSP[N]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR1Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[NonVoidMethodCallMutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; MST[rv.ABSMutator]MSP[N] bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.ABSMutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; MST[rv.UOI4Mutator]MSP[N] int j = 0 ; while ( count -- != 0 ) {
reader . reset () ; if ( read > 0 ) { MST[rv.UOI1Mutator]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { MST[rv.ROR5Mutator]MSP[S] char c = charBuf [ bufPos ] ;
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[rv.ROR4Mutator]MSP[N] return offset - bufPos ; } } return - 1 ; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) MST[rv.CRCR1Mutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[rv.ABSMutator]MSP[N] } } return - 1 ; }
return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; MST[rv.UOI2Mutator]MSP[S] } } return cached ; }
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.ROR1Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[ConditionalsBoundaryMutator]MSP[N]
return bufPos >= bufLength ; MST[rv.UOI3Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[InlineConstantMutator]MSP[N] bufPos ++ ; else break; }
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.UOI1Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR2Mutator]MSP[N] bufPos ++ ; else break; }
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[rv.CRCR4Mutator]MSP[S] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI3Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR5Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) MST[NegateConditionalsMutator]MSP[N] return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ABSMutator]MSP[N] } private boolean isEmptyNoBufferUp () {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[rv.ROR3Mutator]MSP[N]
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.UOI2Mutator]MSP[N] }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[rv.CRCR1Mutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.UOI4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
final int charLen = chars . length ; int i ; OUTER: while ( pos < remaining ) { for ( i = 0 ; i < charLen ; i ++ ) { MST[rv.UOI3Mutator]MSP[N] if ( val [ pos ] == chars [ i ] ) break OUTER; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[ConditionalsBoundaryMutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; MST[rv.AOR2Mutator]MSP[N] }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; MST[InlineConstantMutator]MSP[N] bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[PrimitiveReturnsMutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR3Mutator]MSP[N]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] return offset - bufPos ; } } return - 1 ; }
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI3Mutator]MSP[N]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[rv.UOI1Mutator]MSP[N]
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; MST[rv.ROR2Mutator]MSP[N] } private boolean isEmptyNoBufferUp () {
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.ABSMutator]MSP[S] while ( bufPos < bufLength ) {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.CRCR1Mutator]MSP[S] bufPos ++ ; else break; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR5Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.AOD1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; MST[VoidMethodCallMutator]MSP[N] char c = charBuf [ bufPos ] ; for ( char seek : seq ) {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.ROR4Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; MST[rv.AOD1Mutator]MSP[N] if ( offset < bufLength && last <= bufLength ) {
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[rv.UOI1Mutator]MSP[S] stringCache [ index ] = cached ; } else {
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) MST[rv.ROR4Mutator]MSP[N] return new String ( charBuf , start , count ) ; if ( count < 1 ) return lr_3 ;
private void bufferUp () { if ( readFully ) return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; MST[rv.UOI1Mutator]MSP[N] reader . mark ( maxBufferLen ) ; int read = 0 ;
reader . reset () ; if ( read > 0 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[N] Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
} boolean containsIgnoreCase ( String seq ) { String loScan = seq . toLowerCase ( Locale . ENGLISH ) ; MST[experimental.NakedReceiverMutator]MSP[N] String hiScan = seq . toUpperCase ( Locale . ENGLISH ) ;
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.ABSMutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { MST[rv.CRCR3Mutator]MSP[N] hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI4Mutator]MSP[S]
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; MST[rv.UOI1Mutator]MSP[N] bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.ROR4Mutator]MSP[N] char c = charBuf [ bufPos ] ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; MST[rv.UOI3Mutator]MSP[N] if ( thisRead == - 1 ) readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ; MST[rv.UOI4Mutator]MSP[S]
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[NegateConditionalsMutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; }
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
if ( seek == c ) MST[rv.ROR1Mutator]MSP[N] return true ; } return false ; } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.ROR1Mutator]MSP[S] bufPos ++ ; else break; }
if ( upScan != upTarget ) return false ; } return true ; } boolean matchesAny ( char ... seq ) { if ( isEmpty () ) return false ; bufferUp () ; char c = charBuf [ bufPos ] ; for ( char seek : seq ) { MST[rv.ABSMutator]MSP[S]
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.ROR4Mutator]MSP[S] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; MST[VoidMethodCallMutator]MSP[N] int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI4Mutator]MSP[N] bufPos += offset ; return consumed ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[S] bufPos ++ ; else break; }
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; MST[rv.CRCR2Mutator]MSP[N] } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[rv.AOD2Mutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } MST[rv.CRCR4Mutator]MSP[N] if ( i == last ) return offset - bufPos ; } } return - 1 ; }
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[ConditionalsBoundaryMutator]MSP[S] return lr_3 ;
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.ABSMutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( rangeEquals ( charBuf , start , count , cached ) ) { return cached ; } else { cached = new String ( charBuf , start , count ) ; MST[rv.UOI2Mutator]MSP[S] stringCache [ index ] = cached ; } } return cached ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { MST[rv.UOI3Mutator]MSP[S] char c = charBuf [ bufPos ] ;
return consumeToEnd () ; } } String consumeTo ( String seq ) { int offset = nextIndexOf ( seq ) ; if ( offset != - 1 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ;
private void bufferUp () { if ( readFully ) MST[rv.ROR4Mutator]MSP[N] return; final int pos = bufPos ; if ( pos < bufSplitPoint ) return; try { final long skipped = reader . skip ( pos ) ; reader . mark ( maxBufferLen ) ; int read = 0 ;
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR6Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
while ( read <= minReadAheadLen ) { int thisRead = reader . read ( charBuf , read , charBuf . length - read ) ; if ( thisRead == - 1 ) MST[rv.CRCR2Mutator]MSP[N] readFully = true ; if ( thisRead <= 0 ) break; read += thisRead ; }
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { MST[rv.ROR4Mutator]MSP[N] String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; return consumed ; } else {
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { MST[rv.UOI3Mutator]MSP[N] int i = start ; int j = 0 ; while ( count -- != 0 ) {
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
if ( isEmpty () ) return false ; char c = charBuf [ bufPos ] ; return ( c >= '0' && c <= '9' ) ; } boolean matchConsume ( String seq ) { bufferUp () ; if ( matches ( seq ) ) { MST[NonVoidMethodCallMutator]MSP[S]
static boolean rangeEquals ( final char [] charBuf , final int start , int count , final String cached ) { if ( count == cached . length () ) { int i = start ; int j = 0 ; while ( count -- != 0 ) { MST[NegateConditionalsMutator]MSP[N]
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; MST[ReturnValsMutator]MSP[S] return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } boolean matches ( char c ) { return ! isEmpty () && charBuf [ bufPos ] == c ; MST[rv.CRCR3Mutator]MSP[N]
private static String cacheString ( final char [] charBuf , final String [] stringCache , final int start , final int count ) { if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) MST[rv.CRCR3Mutator]MSP[S] return lr_3 ;
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) MST[NegateConditionalsMutator]MSP[N] return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos )
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) MST[rv.ROR5Mutator]MSP[S]
return val ; } void unconsume () { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; MST[rv.CRCR6Mutator]MSP[N] } void mark () { if ( bufLength - bufPos < minReadAheadLen )
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI4Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; MST[rv.UOI1Mutator]MSP[N] bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; }
if ( c >= '0' && c <= '9' ) MST[rv.ROR3Mutator]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( seek == c ) return true ; } return false ; MST[rv.CRCR3Mutator]MSP[S] } boolean matchesAnySorted ( char [] seq ) { bufferUp () ; return ! isEmpty () && Arrays . binarySearch ( seq , charBuf [ bufPos ] ) >= 0 ; } boolean matchesLetter () {
bufPos += seq . length () ; return true ; MST[rv.CRCR6Mutator]MSP[S] } else { return false ; } } boolean matchConsumeIgnoreCase ( String seq ) { if ( matchesIgnoreCase ( seq ) ) { bufPos += seq . length () ; return true ; } else { return false ; }
return val ; } void unconsume () { if ( bufPos < 1 ) MST[rv.UOI2Mutator]MSP[S] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
if ( c >= '0' && c <= '9' ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
return val ; } void unconsume () { if ( bufPos < 1 ) MST[InlineConstantMutator]MSP[N] throw new UncheckedIOException ( new IOException ( lr_1 ) ) ; bufPos -- ; } public void advance () { bufPos ++ ; } void mark () { if ( bufLength - bufPos < minReadAheadLen )
return bufPos >= bufLength ; MST[rv.CRCR5Mutator]MSP[N] } public char current () { bufferUp () ; return isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; } char consume () { bufferUp () ; char val = isEmptyNoBufferUp () ? EOF : charBuf [ bufPos ] ; bufPos ++ ;
String data = cacheString ( charBuf , stringCache , bufPos , bufLength - bufPos ) ; bufPos = bufLength ; return data ; } String consumeLetterSequence () { bufferUp () ; int start = bufPos ; MST[rv.UOI2Mutator]MSP[S] while ( bufPos < bufLength ) {
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI3Mutator]MSP[S]
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] bufPos ++ ; else break; }
if ( seq . charAt ( offset ) != charBuf [ bufPos + offset ] ) return false ; return true ; } boolean matchesIgnoreCase ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.AOR1Mutator]MSP[S]
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) return i - bufPos ; MST[rv.AOD2Mutator]MSP[N] } return - 1 ; }
} boolean matches ( String seq ) { bufferUp () ; int scanLength = seq . length () ; if ( scanLength > bufLength - bufPos ) MST[rv.UOI4Mutator]MSP[N] return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ )
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { if ( c == charBuf [ i ] ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return i - bufPos ; } return - 1 ; }
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR5Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
reader . reset () ; if ( read > 0 ) { Validate . isTrue ( skipped == pos ) ; bufLength = read ; readerPos += pos ; bufPos = 0 ; bufMark = - 1 ; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength ; MST[rv.UOI1Mutator]MSP[N] }
char c = charBuf [ bufPos ] ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI3Mutator]MSP[N] bufPos ++ ; else break; }
} else if ( bufLength - bufPos < seq . length () ) { return consumeToEnd () ; } else { int endPos = bufLength - seq . length () + 1 ; String consumed = cacheString ( charBuf , stringCache , bufPos , endPos - bufPos ) ; MST[rv.AOR2Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } MST[rv.ROR4Mutator]MSP[N] int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) {
bufSplitPoint = 0 ; bufferUp () ; bufMark = bufPos ; } void unmark () { bufMark = - 1 ; } void rewindToMark () { if ( bufMark == - 1 ) throw new UncheckedIOException ( new IOException ( lr_2 ) ) ; bufPos = bufMark ; MST[rv.ABSMutator]MSP[N]
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI4Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.ABSMutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
unmark () ; } int nextIndexOf ( char c ) { bufferUp () ; for ( int i = bufPos ; i < bufLength ; i ++ ) { MST[rv.ROR1Mutator]MSP[N] if ( c == charBuf [ i ] ) return i - bufPos ; } return - 1 ; }
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public int pos () { return readerPos + bufPos ; MST[rv.UOI4Mutator]MSP[N] } public boolean isEmpty () { bufferUp () ; return bufPos >= bufLength ; } private boolean isEmptyNoBufferUp () {
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR4Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ) MST[rv.UOI1Mutator]MSP[N] bufPos ++ ; else break; } while ( ! isEmptyNoBufferUp () ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; MST[MathMutator]MSP[N] } } return - 1 ; }
if ( c >= '0' && c <= '9' ) bufPos ++ ; else break; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR1Mutator]MSP[S] } String consumeHexSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; } final int index = hash & stringCache . length - 1 ; MST[rv.OBBN3Mutator]MSP[S]
while( ++ offset < bufLength && startChar != charBuf [ offset ] ) { } int i = offset + 1 ; int last = i + seq . length () - 1 ; if ( offset < bufLength && last <= bufLength ) { MST[NegateConditionalsMutator]MSP[N]
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; MST[rv.UOI1Mutator]MSP[N] bufPos += offset ; return consumed ; } else {
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ; } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.CRCR6Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
return cacheString ( charBuf , stringCache , start , bufPos - start ) ; MST[rv.AOR3Mutator]MSP[S] } String consumeLetterThenDigitSequence () { bufferUp () ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ;
for ( int j = 1 ; i < last && seq . charAt ( j ) == charBuf [ i ] ; i ++ , j ++ ) { } if ( i == last ) return offset - bufPos ; } } return - 1 ; MST[rv.CRCR1Mutator]MSP[N] }
String cached = stringCache [ index ] ; if ( cached == null ) { cached = new String ( charBuf , start , count ) ; MST[ConstructorCallMutator]MSP[N] stringCache [ index ] = cached ; } else {
public String consumeTo ( char c ) { int offset = nextIndexOf ( c ) ; if ( offset != - 1 ) { String consumed = cacheString ( charBuf , stringCache , bufPos , offset ) ; bufPos += offset ; MST[rv.UOI4Mutator]MSP[N] return consumed ; } else {
return false ; for ( int offset = 0 ; offset < scanLength ; offset ++ ) { MST[rv.CRCR3Mutator]MSP[S] char upScan = Character . toUpperCase ( seq . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( charBuf [ bufPos + offset ] ) ;
String cached = stringCache [ index ] ; if ( cached == null ) { MST[rv.ROR5Mutator]MSP[N] cached = new String ( charBuf , start , count ) ; stringCache [ index ] = cached ; } else {
return ( nextIndexOf ( loScan ) > - 1 ) || ( nextIndexOf ( hiScan ) > - 1 ) ; MST[rv.ROR2Mutator]MSP[S] } @Override public String toString () { return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
if ( charBuf [ i ++ ] != cached . charAt ( j ++ ) ) return false ; MST[rv.CRCR3Mutator]MSP[N] } return true ; } return false ; } boolean rangeEquals ( final int start , final int count , final String cached ) {
int hash = 0 ; int offset = start ; for ( int i = 0 ; i < count ; i ++ ) { hash = 31 * hash + charBuf [ offset ++ ] ; MST[rv.AOR3Mutator]MSP[S] } final int index = hash & stringCache . length - 1 ;
pos ++ ; } bufPos = pos ; return pos > start ? cacheString ( charBuf , stringCache , start , pos - start ) : lr_3 ; MST[rv.UOI2Mutator]MSP[N] } String consumeToAnySorted ( final char ... chars ) { bufferUp () ; int pos = bufPos ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
if ( selector != null ) { Elements elements = doc . select ( selector ) ; for ( Element element : elements ) { String plainText = formatter . getPlainText ( element ) ; System . out . println ( plainText ) ; } } else {
String plainText = formatter . getPlainText ( doc ) ; System . out . println ( plainText ) ; } } public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor () ; NodeTraversor . traverse ( formatter , element ) ;
return formatter . toString () ; } public void head ( Node node , int depth ) { String name = node . nodeName () ; if ( node instanceof TextNode ) append ( ( ( TextNode ) node ) . text () ) ;
else if ( name . equals ( lr_2 ) ) append ( lr_3 ) ; else if ( name . equals ( lr_4 ) ) append ( lr_5 ) ;
else if ( StringUtil . in ( name , lr_6 , lr_7 , lr_8 , lr_9 , lr_10 , lr_11 , lr_12 ) ) append ( lr_13 ) ; } public void tail ( Node node , int depth ) { String name = node . nodeName () ;
if ( StringUtil . in ( name , lr_14 , lr_15 , lr_4 , lr_6 , lr_7 , lr_8 , lr_9 , lr_10 , lr_11 ) ) append ( lr_13 ) ; else if ( name . equals ( lr_16 ) )
append ( String . format ( lr_17 , node . absUrl ( lr_18 ) ) ) ; } private void append ( String text ) { if ( text . startsWith ( lr_13 ) ) width = 0 ; if ( text . equals ( lr_19 ) &&
( accum . length () == 0 || StringUtil . in ( accum . substring ( accum . length () - 1 ) , lr_19 , lr_13 ) ) ) return; if ( text . length () + width > maxWidth ) {
String [] words = text . split ( lr_20 ) ; for ( int i = 0 ; i < words . length ; i ++ ) { String word = words [ i ] ; boolean last = i == words . length - 1 ;
if ( ! last ) word = word + lr_19 ; if ( word . length () + width > maxWidth ) { accum . append ( lr_13 ) . append ( word ) ; width = word . length () ; } else {
accum . append ( word ) ; width += word . length () ; } } } else { accum . append ( text ) ; width += text . length () ; } } @Override public String toString () { return accum . toString () ; }
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR1Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR6Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR5Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
return formatter . toString () ; MST[EmptyObjectReturnValsMutator]MSP[N] } public void head ( Node node , int depth ) { String name = node . nodeName () ; if ( node instanceof TextNode ) append ( ( ( TextNode ) node ) . text () ) ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR1Mutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR6Mutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR3Mutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[rv.CRCR5Mutator]MSP[S]
return formatter . toString () ; MST[ReturnValsMutator]MSP[N] } public void head ( Node node , int depth ) { String name = node . nodeName () ; if ( node instanceof TextNode ) append ( ( ( TextNode ) node ) . text () ) ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[NegateConditionalsMutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR2Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[VoidMethodCallMutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR3Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR4Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
String plainText = formatter . getPlainText ( doc ) ; System . out . println ( plainText ) ; } } public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor () ; NodeTraversor . traverse ( formatter , element ) ; MST[VoidMethodCallMutator]MSP[N]
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR1Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; final String url = args [ 0 ] ; MST[InlineConstantMutator]MSP[S]
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR5Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR1Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR5Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[InlineConstantMutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
return formatter . toString () ; MST[NonVoidMethodCallMutator]MSP[N] } public void head ( Node node , int depth ) { String name = node . nodeName () ; if ( node instanceof TextNode ) append ( ( ( TextNode ) node ) . text () ) ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[N] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; MST[NonVoidMethodCallMutator]MSP[S] HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[InlineConstantMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR3Mutator]MSP[N] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR1Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR5Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR6Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR4Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR3Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR5Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR2Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR3Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR1Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR4Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR5Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.ROR2Mutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[rv.CRCR1Mutator]MSP[S] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR2Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR2Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.ROR4Mutator]MSP[S] final String url = args [ 0 ] ;
final String selector = args . length == 2 ? args [ 1 ] : null ; MST[InlineConstantMutator]MSP[N] Document doc = Jsoup . connect ( url ) . userAgent ( userAgent ) . timeout ( timeout ) . get () ; HtmlToPlainText formatter = new HtmlToPlainText () ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[NegateConditionalsMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[NegateConditionalsMutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR4Mutator]MSP[N] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR2Mutator]MSP[S] final String url = args [ 0 ] ;
String plainText = formatter . getPlainText ( doc ) ; System . out . println ( plainText ) ; } } public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor () ; MST[ConstructorCallMutator]MSP[S] NodeTraversor . traverse ( formatter , element ) ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR4Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[rv.CRCR6Mutator]MSP[S] final String url = args [ 0 ] ;
public static void main ( String ... args ) throws IOException { Validate . isTrue ( args . length == 1 || args . length == 2 , lr_1 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] final String url = args [ 0 ] ;
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () ) { Token . Doctype d = t . asDoctype () ; DocumentType doctype = new DocumentType ( tb . settings . normalizeTag ( d . getName () ) , d . getPublicIdentifier () , d . getSystemIdentifier () ) ;
doctype . setPubSysKey ( d . getPubSysKey () ) ; tb . getDocument () . appendChild ( doctype ) ; if ( d . isForceQuirks () ) tb . getDocument () . quirksMode ( Document . QuirksMode . quirks ) ; tb . transition ( BeforeHtml ) ;
} else { tb . transition ( BeforeHtml ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype () ) { tb . error ( this ) ;
return false ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ; } else if ( isWhitespace ( t ) ) { return true ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { tb . insert ( t . asStartTag () ) ; tb . transition ( BeforeHead ) ;
} else if ( t . isEndTag () && ( StringUtil . in ( t . asEndTag () . normalName () , lr_2 , lr_3 , lr_1 , lr_4 ) ) ) { return anythingElse ( t , tb ) ;
} else if ( t . isEndTag () ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) {
tb . insertStartTag ( lr_1 ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return true ;
} else if ( t . isComment () ) { tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { return InBody . process ( t , tb ) ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_2 ) ) { Element head = tb . insert ( t . asStartTag () ) ; tb . setHeadElement ( head ) ; tb . transition ( InHead ) ;
} else if ( t . isEndTag () && ( StringUtil . in ( t . asEndTag () . normalName () , lr_2 , lr_3 , lr_1 , lr_4 ) ) ) { tb . processStartTag ( lr_2 ) ; return tb . process ( t ) ;
} else if ( t . isEndTag () ) { tb . error ( this ) ; return false ; } else { tb . processStartTag ( lr_2 ) ; return tb . process ( t ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
tb . insert ( t . asComment () ) ; break; case Doctype : tb . error ( this ) ; return false ; case StartTag : Token . StartTag start = t . asStartTag () ; String name = start . normalName () ;
if ( name . equals ( lr_1 ) ) { return InBody . process ( t , tb ) ; } else if ( StringUtil . in ( name , lr_5 , lr_6 , lr_7 , lr_8 , lr_9 ) ) {
Element el = tb . insertEmpty ( start ) ; if ( name . equals ( lr_5 ) && el . hasAttr ( lr_10 ) ) tb . maybeSetBaseUri ( el ) ; } else if ( name . equals ( lr_11 ) ) {
Element meta = tb . insertEmpty ( start ) ; } else if ( name . equals ( lr_12 ) ) { handleRcData ( start , tb ) ; } else if ( StringUtil . in ( name , lr_13 , lr_14 ) ) {
handleRawtext ( start , tb ) ; } else if ( name . equals ( lr_15 ) ) { tb . insert ( start ) ; tb . transition ( InHeadNoscript ) ; } else if ( name . equals ( lr_16 ) ) {
tb . tokeniser . transition ( TokeniserState . ScriptData ) ; tb . markInsertionMode () ; tb . transition ( Text ) ; tb . insert ( start ) ; } else if ( name . equals ( lr_2 ) ) { tb . error ( this ) ;
return false ; } else { return anythingElse ( t , tb ) ; } break; case EndTag : Token . EndTag end = t . asEndTag () ; name = end . normalName () ; if ( name . equals ( lr_2 ) ) {
tb . pop () ; tb . transition ( AfterHead ) ; } else if ( StringUtil . in ( name , lr_3 , lr_1 , lr_4 ) ) { return anythingElse ( t , tb ) ; } else { tb . error ( this ) ;
return false ; } break; default: return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , TreeBuilder tb ) { tb . processEndTag ( lr_2 ) ; return tb . process ( t ) ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
return tb . process ( t , InBody ) ; } else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_15 ) ) { tb . pop () ; tb . transition ( InHead ) ;
} else if ( isWhitespace ( t ) || t . isComment () || ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_6 , lr_7 , lr_9 , lr_11 , lr_13 , lr_14 ) ) ) {
return tb . process ( t , InHead ) ; } else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_4 ) ) { return anythingElse ( t , tb ) ;
} else if ( ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_2 , lr_15 ) ) || t . isEndTag () ) { tb . error ( this ) ; return false ; } else {
return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; tb . insert ( new Token . Character () . data ( t . toString () ) ) ;
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ;
String name = startTag . normalName () ; if ( name . equals ( lr_1 ) ) { return tb . process ( t , InBody ) ; } else if ( name . equals ( lr_3 ) ) { tb . insert ( startTag ) ;
tb . framesetOk ( false ) ; tb . transition ( InBody ) ; } else if ( name . equals ( lr_17 ) ) { tb . insert ( startTag ) ; tb . transition ( InFrameset ) ;
} else if ( StringUtil . in ( name , lr_5 , lr_6 , lr_7 , lr_9 , lr_11 , lr_13 , lr_16 , lr_14 , lr_12 ) ) { tb . error ( this ) ; Element head = tb . getHeadElement () ;
tb . push ( head ) ; tb . process ( t , InHead ) ; tb . removeFromStack ( head ) ; } else if ( name . equals ( lr_2 ) ) { tb . error ( this ) ; return false ; } else {
anythingElse ( t , tb ) ; } } else if ( t . isEndTag () ) { if ( StringUtil . in ( t . asEndTag () . normalName () , lr_3 , lr_1 ) ) { anythingElse ( t , tb ) ; } else {
tb . error ( this ) ; return false ; } } else { anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . processStartTag ( lr_3 ) ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else if ( tb . framesetOk () && isWhitespace ( c ) ) { tb . reconstructFormattingElements () ; tb . insert ( c ) ;
} else { tb . reconstructFormattingElements () ; tb . insert ( c ) ; tb . framesetOk ( false ) ; } break; } case Comment : { tb . insert ( t . asComment () ) ; break; } case Doctype : {
tb . error ( this ) ; return false ; } case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_18 ) ) {
if ( tb . getActiveFormattingElement ( lr_18 ) != null ) { tb . error ( this ) ; tb . processEndTag ( lr_18 ) ; Element remainingA = tb . getFromStack ( lr_18 ) ; if ( remainingA != null ) { tb . removeFromActiveFormattingElements ( remainingA ) ;
tb . removeFromStack ( remainingA ) ; } } tb . reconstructFormattingElements () ; Element a = tb . insert ( startTag ) ; tb . pushActiveFormattingElements ( a ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartEmptyFormatters ) ) {
tb . reconstructFormattingElements () ; tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartPClosers ) ) { if ( tb . inButtonScope ( lr_19 ) ) {
tb . processEndTag ( lr_19 ) ; } tb . insert ( startTag ) ; } else if ( name . equals ( lr_20 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ;
} else if ( name . equals ( lr_21 ) ) { tb . framesetOk ( false ) ; ArrayList < Element > stack = tb . getStack () ; for ( int i = stack . size () - 1 ; i > 0 ; i -- ) {
Element el = stack . get ( i ) ; if ( el . normalName () . equals ( lr_21 ) ) { tb . processEndTag ( lr_21 ) ; break; }
if ( tb . isSpecial ( el ) && ! StringUtil . inSorted ( el . normalName () , Constants . InBodyStartLiBreakers ) ) break; } if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; }
tb . insert ( startTag ) ; } else if ( name . equals ( lr_1 ) ) { tb . error ( this ) ; Element html = tb . getStack () . get ( 0 ) ; for ( Attribute attribute : startTag . getAttributes () ) {
if ( ! html . hasAttr ( attribute . getKey () ) ) html . attributes () . put ( attribute ) ; } } else if ( StringUtil . inSorted ( name , Constants . InBodyStartToHead ) ) { return tb . process ( t , InHead ) ;
} else if ( name . equals ( lr_3 ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack () ;
if ( stack . size () == 1 || ( stack . size () > 2 && ! stack . get ( 1 ) . normalName () . equals ( lr_3 ) ) ) { return false ; } else { tb . framesetOk ( false ) ;
Element body = stack . get ( 1 ) ; for ( Attribute attribute : startTag . getAttributes () ) { if ( ! body . hasAttr ( attribute . getKey () ) ) body . attributes () . put ( attribute ) ; } }
} else if ( name . equals ( lr_17 ) ) { tb . error ( this ) ; ArrayList < Element > stack = tb . getStack () ;
if ( stack . size () == 1 || ( stack . size () > 2 && ! stack . get ( 1 ) . normalName () . equals ( lr_3 ) ) ) { return false ; } else if ( ! tb . framesetOk () ) {
return false ; } else { Element second = stack . get ( 1 ) ; if ( second . parent () != null ) second . remove () ; while ( stack . size () > 1 )
stack . remove ( stack . size () - 1 ) ; tb . insert ( startTag ) ; tb . transition ( InFrameset ) ; } } else if ( StringUtil . inSorted ( name , Constants . Headings ) ) {
if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } if ( StringUtil . inSorted ( tb . currentElement () . normalName () , Constants . Headings ) ) { tb . error ( this ) ; tb . pop () ;
} tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartPreListing ) ) { if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . insert ( startTag ) ;
tb . reader . matchConsume ( lr_22 ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( lr_23 ) ) { if ( tb . getFormElement () != null ) { tb . error ( this ) ; return false ; }
if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . insertForm ( startTag , true ) ; } else if ( StringUtil . inSorted ( name , Constants . DdDt ) ) { tb . framesetOk ( false ) ;
ArrayList < Element > stack = tb . getStack () ; for ( int i = stack . size () - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ;
if ( StringUtil . inSorted ( el . normalName () , Constants . DdDt ) ) { tb . processEndTag ( el . normalName () ) ; break; }
if ( tb . isSpecial ( el ) && ! StringUtil . inSorted ( el . normalName () , Constants . InBodyStartLiBreakers ) ) break; } if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; }
tb . insert ( startTag ) ; } else if ( name . equals ( lr_24 ) ) { if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . insert ( startTag ) ;
tb . tokeniser . transition ( TokeniserState . PLAINTEXT ) ; } else if ( name . equals ( lr_25 ) ) { if ( tb . inButtonScope ( lr_25 ) ) { tb . error ( this ) ; tb . processEndTag ( lr_25 ) ;
tb . process ( startTag ) ; } else { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; tb . framesetOk ( false ) ; } } else if ( StringUtil . inSorted ( name , Constants . Formatters ) ) {
tb . reconstructFormattingElements () ; Element el = tb . insert ( startTag ) ; tb . pushActiveFormattingElements ( el ) ; } else if ( name . equals ( lr_26 ) ) { tb . reconstructFormattingElements () ; if ( tb . inScope ( lr_26 ) ) {
tb . error ( this ) ; tb . processEndTag ( lr_26 ) ; tb . reconstructFormattingElements () ; } Element el = tb . insert ( startTag ) ; tb . pushActiveFormattingElements ( el ) ;
} else if ( StringUtil . inSorted ( name , Constants . InBodyStartApplets ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; tb . insertMarkerToFormattingElements () ; tb . framesetOk ( false ) ;
} else if ( name . equals ( lr_27 ) ) { if ( tb . getDocument () . quirksMode () != Document . QuirksMode . quirks && tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; }
tb . insert ( startTag ) ; tb . framesetOk ( false ) ; tb . transition ( InTable ) ; } else if ( name . equals ( lr_28 ) ) { tb . reconstructFormattingElements () ; Element el = tb . insertEmpty ( startTag ) ;
if ( ! el . attr ( lr_29 ) . equalsIgnoreCase ( lr_30 ) ) tb . framesetOk ( false ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartMedia ) ) { tb . insertEmpty ( startTag ) ;
} else if ( name . equals ( lr_31 ) ) { if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ;
} else if ( name . equals ( lr_32 ) ) { if ( tb . getFromStack ( lr_33 ) == null ) return tb . process ( startTag . name ( lr_34 ) ) ; else tb . insert ( startTag ) ;
} else if ( name . equals ( lr_35 ) ) { tb . error ( this ) ; if ( tb . getFormElement () != null ) return false ; tb . processStartTag ( lr_23 ) ; if ( startTag . attributes . hasKey ( lr_36 ) ) {
Element form = tb . getFormElement () ; form . attr ( lr_36 , startTag . attributes . get ( lr_36 ) ) ; } tb . processStartTag ( lr_31 ) ; tb . processStartTag ( lr_37 ) ;
String prompt = startTag . attributes . hasKey ( lr_38 ) ? startTag . attributes . get ( lr_38 ) : lr_39 ; tb . process ( new Token . Character () . data ( prompt ) ) ; Attributes inputAttribs = new Attributes () ;
for ( Attribute attr : startTag . attributes ) { if ( ! StringUtil . inSorted ( attr . getKey () , Constants . InBodyStartInputAttribs ) ) inputAttribs . put ( attr ) ; } inputAttribs . put ( lr_40 , lr_35 ) ;
tb . processStartTag ( lr_28 , inputAttribs ) ; tb . processEndTag ( lr_37 ) ; tb . processStartTag ( lr_31 ) ; tb . processEndTag ( lr_23 ) ; } else if ( name . equals ( lr_41 ) ) { tb . insert ( startTag ) ;
if ( ! startTag . isSelfClosing () ) { tb . tokeniser . transition ( TokeniserState . Rcdata ) ; tb . markInsertionMode () ; tb . framesetOk ( false ) ; tb . transition ( Text ) ; }
} else if ( name . equals ( lr_42 ) ) { if ( tb . inButtonScope ( lr_19 ) ) { tb . processEndTag ( lr_19 ) ; } tb . reconstructFormattingElements () ; tb . framesetOk ( false ) ; handleRawtext ( startTag , tb ) ;
} else if ( name . equals ( lr_43 ) ) { tb . framesetOk ( false ) ; handleRawtext ( startTag , tb ) ; } else if ( name . equals ( lr_44 ) ) { handleRawtext ( startTag , tb ) ;
} else if ( name . equals ( lr_45 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; tb . framesetOk ( false ) ; HtmlTreeBuilderState state = tb . state () ;
if ( state . equals ( InTable ) || state . equals ( InCaption ) || state . equals ( InTableBody ) || state . equals ( InRow ) || state . equals ( InCell ) ) tb . transition ( InSelectInTable ) ; else
tb . transition ( InSelect ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartOptions ) ) { if ( tb . currentElement () . normalName () . equals ( lr_46 ) ) tb . processEndTag ( lr_46 ) ; tb . reconstructFormattingElements () ;
tb . insert ( startTag ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartRuby ) ) { if ( tb . inScope ( lr_47 ) ) { tb . generateImpliedEndTags () ;
if ( ! tb . currentElement () . normalName () . equals ( lr_47 ) ) { tb . error ( this ) ; tb . popStackToBefore ( lr_47 ) ; } tb . insert ( startTag ) ; }
} else if ( name . equals ( lr_48 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; } else if ( name . equals ( lr_33 ) ) { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ;
} else if ( StringUtil . inSorted ( name , Constants . InBodyStartDrop ) ) { tb . error ( this ) ; return false ; } else { tb . reconstructFormattingElements () ; tb . insert ( startTag ) ; } break; case EndTag :
Token . EndTag endTag = t . asEndTag () ; name = endTag . normalName () ; if ( StringUtil . inSorted ( name , Constants . InBodyEndAdoptionFormatters ) ) { for ( int i = 0 ; i < 8 ; i ++ ) {
Element formatEl = tb . getActiveFormattingElement ( name ) ; if ( formatEl == null ) return anyOtherEndTag ( t , tb ) ; else if ( ! tb . onStack ( formatEl ) ) { tb . error ( this ) ; tb . removeFromActiveFormattingElements ( formatEl ) ;
return true ; } else if ( ! tb . inScope ( formatEl . normalName () ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement () != formatEl ) tb . error ( this ) ;
Element furthestBlock = null ; Element commonAncestor = null ; boolean seenFormattingElement = false ; ArrayList < Element > stack = tb . getStack () ; final int stackSize = stack . size () ;
for ( int si = 0 ; si < stackSize && si < 64 ; si ++ ) { Element el = stack . get ( si ) ; if ( el == formatEl ) { commonAncestor = stack . get ( si - 1 ) ;
seenFormattingElement = true ; } else if ( seenFormattingElement && tb . isSpecial ( el ) ) { furthestBlock = el ; break; } } if ( furthestBlock == null ) { tb . popStackToClose ( formatEl . normalName () ) ; tb . removeFromActiveFormattingElements ( formatEl ) ;
return true ; } Element node = furthestBlock ; Element lastNode = furthestBlock ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( tb . onStack ( node ) ) node = tb . aboveOnStack ( node ) ;
if ( ! tb . isInActiveFormattingElements ( node ) ) { tb . removeFromStack ( node ) ; continue; } else if ( node == formatEl ) break;
Element replacement = new Element ( Tag . valueOf ( node . nodeName () , ParseSettings . preserveCase ) , tb . getBaseUri () ) ; tb . replaceActiveFormattingElement ( node , replacement ) ; tb . replaceOnStack ( node , replacement ) ; node = replacement ;
if ( lastNode == furthestBlock ) { } if ( lastNode . parent () != null ) lastNode . remove () ; node . appendChild ( lastNode ) ; lastNode = node ; }
if ( StringUtil . inSorted ( commonAncestor . normalName () , Constants . InBodyEndTableFosters ) ) { if ( lastNode . parent () != null ) lastNode . remove () ; tb . insertInFosterParent ( lastNode ) ; } else { if ( lastNode . parent () != null )
lastNode . remove () ; commonAncestor . appendChild ( lastNode ) ; } Element adopter = new Element ( formatEl . tag () , tb . getBaseUri () ) ; adopter . attributes () . addAll ( formatEl . attributes () ) ;
Node [] childNodes = furthestBlock . childNodes () . toArray ( new Node [ 0 ] ) ; for ( Node childNode : childNodes ) { adopter . appendChild ( childNode ) ; } furthestBlock . appendChild ( adopter ) ; tb . removeFromActiveFormattingElements ( formatEl ) ;
tb . removeFromStack ( formatEl ) ; tb . insertOnStackAfter ( furthestBlock , adopter ) ; } } else if ( StringUtil . inSorted ( name , Constants . InBodyEndClosers ) ) { if ( ! tb . inScope ( name ) ) {
tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags () ; if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; }
} else if ( name . equals ( lr_20 ) ) { return anyOtherEndTag ( t , tb ) ; } else if ( name . equals ( lr_21 ) ) { if ( ! tb . inListItemScope ( name ) ) { tb . error ( this ) ;
return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; }
} else if ( name . equals ( lr_3 ) ) { if ( ! tb . inScope ( lr_3 ) ) { tb . error ( this ) ; return false ; } else { tb . transition ( AfterBody ) ; }
} else if ( name . equals ( lr_1 ) ) { boolean notIgnored = tb . processEndTag ( lr_3 ) ; if ( notIgnored ) return tb . process ( endTag ) ; } else if ( name . equals ( lr_23 ) ) {
Element currentForm = tb . getFormElement () ; tb . setFormElement ( null ) ; if ( currentForm == null || ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags () ;
if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . removeFromStack ( currentForm ) ; } } else if ( name . equals ( lr_19 ) ) {
if ( ! tb . inButtonScope ( name ) ) { tb . error ( this ) ; tb . processStartTag ( name ) ; return tb . process ( endTag ) ; } else { tb . generateImpliedEndTags ( name ) ;
if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( StringUtil . inSorted ( name , Constants . DdDt ) ) {
if ( ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement () . normalName () . equals ( name ) )
tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( StringUtil . inSorted ( name , Constants . Headings ) ) { if ( ! tb . inScope ( Constants . Headings ) ) {
tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ;
tb . popStackToClose ( Constants . Headings ) ; } } else if ( name . equals ( lr_49 ) ) { return anyOtherEndTag ( t , tb ) ; } else if ( StringUtil . inSorted ( name , Constants . InBodyStartApplets ) ) {
if ( ! tb . inScope ( lr_40 ) ) { if ( ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } tb . generateImpliedEndTags () ;
if ( ! tb . currentElement () . normalName () . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker () ; } } else if ( name . equals ( lr_4 ) ) {
tb . error ( this ) ; tb . processStartTag ( lr_4 ) ; return false ; } else { return anyOtherEndTag ( t , tb ) ; } break; case EOF : break; } return true ; } boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) {
String name = t . asEndTag () . normalName ; ArrayList < Element > stack = tb . getStack () ; for ( int pos = stack . size () - 1 ; pos >= 0 ; pos -- ) {
Element node = stack . get ( pos ) ; if ( node . normalName () . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement () . normalName () ) )
tb . error ( this ) ; tb . popStackToClose ( name ) ; break; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isEOF () ) { tb . error ( this ) ; tb . pop () ;
tb . transition ( tb . originalState () ) ; return tb . process ( t ) ; } else if ( t . isEndTag () ) { tb . pop () ; tb . transition ( tb . originalState () ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isCharacter () ) { tb . newPendingTableCharacters () ; tb . markInsertionMode () ; tb . transition ( InTableText ) ; return tb . process ( t ) ;
} else if ( t . isComment () ) { tb . insert ( t . asComment () ) ; return true ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_50 ) ) { tb . clearStackToTableContext () ; tb . insertMarkerToFormattingElements () ;
tb . insert ( startTag ) ; tb . transition ( InCaption ) ; } else if ( name . equals ( lr_51 ) ) { tb . clearStackToTableContext () ; tb . insert ( startTag ) ; tb . transition ( InColumnGroup ) ;
} else if ( name . equals ( lr_52 ) ) { tb . processStartTag ( lr_51 ) ; return tb . process ( t ) ; } else if ( StringUtil . in ( name , lr_53 , lr_54 , lr_55 ) ) { tb . clearStackToTableContext () ;
tb . insert ( startTag ) ; tb . transition ( InTableBody ) ; } else if ( StringUtil . in ( name , lr_56 , lr_57 , lr_58 ) ) { tb . processStartTag ( lr_53 ) ; return tb . process ( t ) ;
} else if ( name . equals ( lr_27 ) ) { tb . error ( this ) ; boolean processed = tb . processEndTag ( lr_27 ) ; if ( processed ) return tb . process ( t ) ;
} else if ( StringUtil . in ( name , lr_14 , lr_16 ) ) { return tb . process ( t , InHead ) ; } else if ( name . equals ( lr_28 ) ) {
if ( ! startTag . attributes . get ( lr_29 ) . equalsIgnoreCase ( lr_30 ) ) { return anythingElse ( t , tb ) ; } else { tb . insertEmpty ( startTag ) ; } } else if ( name . equals ( lr_23 ) ) {
tb . error ( this ) ; if ( tb . getFormElement () != null ) return false ; else { tb . insertForm ( startTag , false ) ; } } else { return anythingElse ( t , tb ) ; } return true ;
} else if ( t . isEndTag () ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ; if ( name . equals ( lr_27 ) ) { if ( ! tb . inTableScope ( name ) ) {
tb . error ( this ) ; return false ; } else { tb . popStackToClose ( lr_27 ) ; } tb . resetInsertionMode () ; } else if ( StringUtil . in ( name ,
lr_3 , lr_50 , lr_52 , lr_51 , lr_1 , lr_53 , lr_56 , lr_54 , lr_57 , lr_55 , lr_58 ) ) { tb . error ( this ) ; return false ; } else { return anythingElse ( t , tb ) ; } return true ;
} else if ( t . isEOF () ) { if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) tb . error ( this ) ; return true ; } return anythingElse ( t , tb ) ; }
boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; boolean processed ; if ( StringUtil . in ( tb . currentElement () . normalName () , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 ) ) {
tb . setFosterInserts ( true ) ; processed = tb . process ( t , InBody ) ; tb . setFosterInserts ( false ) ; } else { processed = tb . process ( t , InBody ) ; } return processed ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
return false ; } else { tb . getPendingTableCharacters () . add ( c . getData () ) ; } break; default: if ( tb . getPendingTableCharacters () . size () > 0 ) { for ( String character : tb . getPendingTableCharacters () ) {
if ( ! isWhitespace ( character ) ) { tb . error ( this ) ; if ( StringUtil . in ( tb . currentElement () . normalName () , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 ) ) { tb . setFosterInserts ( true ) ;
tb . process ( new Token . Character () . data ( character ) , InBody ) ; tb . setFosterInserts ( false ) ; } else { tb . process ( new Token . Character () . data ( character ) , InBody ) ; } } else
tb . insert ( new Token . Character () . data ( character ) ) ; } tb . newPendingTableCharacters () ; } tb . transition ( tb . originalState () ) ; return tb . process ( t ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ;
if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags () ; if ( ! tb . currentElement () . normalName () . equals ( lr_50 ) )
tb . error ( this ) ; tb . popStackToClose ( lr_50 ) ; tb . clearFormattingElementsToLastMarker () ; tb . transition ( InTable ) ; } } else if ( ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () ,
lr_50 , lr_52 , lr_51 , lr_53 , lr_56 , lr_54 , lr_57 , lr_55 , lr_58 ) || t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_27 ) ) ) { tb . error ( this ) ;
boolean processed = tb . processEndTag ( lr_50 ) ; if ( processed ) return tb . process ( t ) ; } else if ( t . isEndTag () && StringUtil . in ( t . asEndTag () . normalName () ,
lr_3 , lr_52 , lr_51 , lr_1 , lr_53 , lr_56 , lr_54 , lr_57 , lr_55 , lr_58 ) ) { tb . error ( this ) ; return false ; } else { return tb . process ( t , InBody ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
tb . insert ( t . asComment () ) ; break; case Doctype : tb . error ( this ) ; break; case StartTag : Token . StartTag startTag = t . asStartTag () ; switch ( startTag . normalName () ) { case lr_1 :
return tb . process ( t , InBody ) ; case lr_52 : tb . insertEmpty ( startTag ) ; break; default: return anythingElse ( t , tb ) ; } break; case EndTag : Token . EndTag endTag = t . asEndTag () ;
if ( endTag . normalName . equals ( lr_51 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) { tb . error ( this ) ; return false ; } else { tb . pop () ;
tb . transition ( InTable ) ; } } else return anythingElse ( t , tb ) ; break; case EOF : if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) return true ; else return anythingElse ( t , tb ) ; default:
return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_51 ) ; if ( processed ) return tb . process ( t ) ; return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
tb . insert ( startTag ) ; } else if ( name . equals ( lr_58 ) ) { tb . clearStackToTableBodyContext () ; tb . insert ( startTag ) ; tb . transition ( InRow ) ;
} else if ( StringUtil . in ( name , lr_57 , lr_56 ) ) { tb . error ( this ) ; tb . processStartTag ( lr_58 ) ; return tb . process ( startTag ) ;
} else if ( StringUtil . in ( name , lr_50 , lr_52 , lr_51 , lr_53 , lr_54 , lr_55 ) ) { return exitTableBody ( t , tb ) ; } else return anythingElse ( t , tb ) ; break; case EndTag :
Token . EndTag endTag = t . asEndTag () ; name = endTag . normalName () ; if ( StringUtil . in ( name , lr_53 , lr_54 , lr_55 ) ) { if ( ! tb . inTableScope ( name ) ) {
tb . error ( this ) ; return false ; } else { tb . clearStackToTableBodyContext () ; tb . pop () ; tb . transition ( InTable ) ; } } else if ( name . equals ( lr_27 ) ) {
return exitTableBody ( t , tb ) ; } else if ( StringUtil . in ( name , lr_3 , lr_50 , lr_52 , lr_51 , lr_1 , lr_56 , lr_57 , lr_58 ) ) { tb . error ( this ) ; return false ; } else
return anythingElse ( t , tb ) ; break; default: return anythingElse ( t , tb ) ; } return true ; } private boolean exitTableBody ( Token t , HtmlTreeBuilder tb ) {
if ( ! ( tb . inTableScope ( lr_53 ) || tb . inTableScope ( lr_55 ) || tb . inScope ( lr_54 ) ) ) { tb . error ( this ) ; return false ; } tb . clearStackToTableBodyContext () ;
tb . processEndTag ( tb . currentElement () . normalName () ) ; return tb . process ( t ) ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { return tb . process ( t , InTable ) ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , lr_57 , lr_56 ) ) { tb . clearStackToTableRowContext () ; tb . insert ( startTag ) ; tb . transition ( InCell ) ; tb . insertMarkerToFormattingElements () ;
} else if ( StringUtil . in ( name , lr_50 , lr_52 , lr_51 , lr_53 , lr_54 , lr_55 , lr_58 ) ) { return handleMissingTr ( t , tb ) ; } else { return anythingElse ( t , tb ) ; }
} else if ( t . isEndTag () ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ; if ( name . equals ( lr_58 ) ) { if ( ! tb . inTableScope ( name ) ) {
tb . error ( this ) ; return false ; } tb . clearStackToTableRowContext () ; tb . pop () ; tb . transition ( InTableBody ) ; } else if ( name . equals ( lr_27 ) ) { return handleMissingTr ( t , tb ) ;
} else if ( StringUtil . in ( name , lr_53 , lr_54 , lr_55 ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } tb . processEndTag ( lr_58 ) ;
return tb . process ( t ) ; } else if ( StringUtil . in ( name , lr_3 , lr_50 , lr_52 , lr_51 , lr_1 , lr_56 , lr_57 ) ) { tb . error ( this ) ; return false ; } else {
return anythingElse ( t , tb ) ; } } else { return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { return tb . process ( t , InTable ) ; }
private boolean handleMissingTr ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) {
if ( t . isEndTag () ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ; if ( StringUtil . inSorted ( name , Constants . InCellNames ) ) {
if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; tb . transition ( InRow ) ; return false ; } tb . generateImpliedEndTags () ; if ( ! tb . currentElement () . normalName () . equals ( name ) )
tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker () ; tb . transition ( InRow ) ; } else if ( StringUtil . inSorted ( name , Constants . InCellBody ) ) { tb . error ( this ) ;
return false ; } else if ( StringUtil . inSorted ( name , Constants . InCellTable ) ) { if ( ! tb . inTableScope ( name ) ) { tb . error ( this ) ; return false ; } closeCell ( tb ) ;
return tb . process ( t ) ; } else { return anythingElse ( t , tb ) ; } } else if ( t . isStartTag () && StringUtil . inSorted ( t . asStartTag () . normalName () , Constants . InCellCol ) ) {
if ( ! ( tb . inTableScope ( lr_56 ) || tb . inTableScope ( lr_57 ) ) ) { tb . error ( this ) ; return false ; } closeCell ( tb ) ; return tb . process ( t ) ; } else {
return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { return tb . process ( t , InBody ) ; } private void closeCell ( HtmlTreeBuilder tb ) {
if ( tb . inTableScope ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { switch ( t . type ) { case Character :
Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else { tb . insert ( c ) ; } break; case Comment :
tb . insert ( t . asComment () ) ; break; case Doctype : tb . error ( this ) ; return false ; case StartTag : Token . StartTag start = t . asStartTag () ; String name = start . normalName () ;
if ( name . equals ( lr_1 ) ) return tb . process ( start , InBody ) ; else if ( name . equals ( lr_46 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_46 ) )
tb . processEndTag ( lr_46 ) ; tb . insert ( start ) ; } else if ( name . equals ( lr_60 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_46 ) ) tb . processEndTag ( lr_46 ) ;
if ( tb . currentElement () . normalName () . equals ( lr_60 ) ) tb . processEndTag ( lr_60 ) ; tb . insert ( start ) ; } else if ( name . equals ( lr_45 ) ) { tb . error ( this ) ;
return tb . processEndTag ( lr_45 ) ; } else if ( StringUtil . in ( name , lr_28 , lr_61 , lr_41 ) ) { tb . error ( this ) ; if ( ! tb . inSelectScope ( lr_45 ) ) return false ;
tb . processEndTag ( lr_45 ) ; return tb . process ( start ) ; } else if ( name . equals ( lr_16 ) ) { return tb . process ( t , InHead ) ; } else { return anythingElse ( t , tb ) ; } break;
case EndTag : Token . EndTag end = t . asEndTag () ; name = end . normalName () ; switch ( name ) { case lr_60 :
if ( tb . currentElement () . normalName () . equals ( lr_46 ) && tb . aboveOnStack ( tb . currentElement () ) != null && tb . aboveOnStack ( tb . currentElement () ) . normalName () . equals ( lr_60 ) )
tb . processEndTag ( lr_46 ) ; if ( tb . currentElement () . normalName () . equals ( lr_60 ) ) tb . pop () ; else tb . error ( this ) ; break; case lr_46 :
if ( tb . currentElement () . normalName () . equals ( lr_46 ) ) tb . pop () ; else tb . error ( this ) ; break; case lr_45 : if ( ! tb . inSelectScope ( name ) ) { tb . error ( this ) ;
return false ; } else { tb . popStackToClose ( name ) ; tb . resetInsertionMode () ; } break; default: return anythingElse ( t , tb ) ; } break; case EOF : if ( ! tb . currentElement () . normalName () . equals ( lr_1 ) )
tb . error ( this ) ; break; default: return anythingElse ( t , tb ) ; } return true ; } private boolean anythingElse ( Token t , HtmlTreeBuilder tb ) { tb . error ( this ) ; return false ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
tb . error ( this ) ; tb . processEndTag ( lr_45 ) ; return tb . process ( t ) ;
} else if ( t . isEndTag () && StringUtil . in ( t . asEndTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) { tb . error ( this ) ;
if ( tb . inTableScope ( t . asEndTag () . normalName () ) ) { tb . processEndTag ( lr_45 ) ; return ( tb . process ( t ) ) ; } else return false ; } else {
return tb . process ( t , InSelect ) ; } } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { return tb . process ( t , InBody ) ; } else if ( t . isComment () ) {
tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { return tb . process ( t , InBody ) ;
} else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_1 ) ) { if ( tb . isFragmentParsing () ) { tb . error ( this ) ; return false ; } else {
tb . transition ( AfterAfterBody ) ; } } else if ( t . isEOF () ) { } else { tb . error ( this ) ; tb . transition ( InBody ) ; return tb . process ( t ) ; } return true ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () ) { tb . error ( this ) ; return false ; } else if ( t . isStartTag () ) { Token . StartTag start = t . asStartTag () ; switch ( start . normalName () ) {
case lr_1 : return tb . process ( start , InBody ) ; case lr_17 : tb . insert ( start ) ; break; case lr_62 : tb . insertEmpty ( start ) ; break; case lr_13 : return tb . process ( start , InHead ) ; default:
tb . error ( this ) ; return false ; } } else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_17 ) ) { if ( tb . currentElement () . normalName () . equals ( lr_1 ) ) {
tb . error ( this ) ; return false ; } else { tb . pop () ; if ( ! tb . isFragmentParsing () && ! tb . currentElement () . normalName () . equals ( lr_17 ) ) { tb . transition ( AfterFrameset ) ; } }
} else if ( t . isEOF () ) { if ( ! tb . currentElement () . normalName () . equals ( lr_1 ) ) { tb . error ( this ) ; return true ; } } else { tb . error ( this ) ;
return false ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
tb . insert ( t . asComment () ) ; } else if ( t . isDoctype () ) { tb . error ( this ) ; return false ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) { return tb . process ( t , InBody ) ;
} else if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_1 ) ) { tb . transition ( AfterAfterFrameset ) ;
} else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_13 ) ) { return tb . process ( t , InHead ) ; } else if ( t . isEOF () ) { } else {
tb . error ( this ) ; return false ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () || isWhitespace ( t ) || ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) ) { return tb . process ( t , InBody ) ;
} else if ( t . isEOF () ) { } else { tb . error ( this ) ; tb . transition ( InBody ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) {
if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else if ( t . isDoctype () || isWhitespace ( t ) || ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) ) { return tb . process ( t , InBody ) ;
} else if ( t . isEOF () ) { } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_13 ) ) { return tb . process ( t , InHead ) ; } else {
tb . error ( this ) ; return false ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { return true ; } private static boolean isWhitespace ( Token t ) { if ( t . isCharacter () ) {
String data = t . asCharacter () . getData () ; return isWhitespace ( data ) ; } return false ; } private static boolean isWhitespace ( String data ) { return StringUtil . isBlank ( data ) ; }
private static void handleRcData ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . tokeniser . transition ( TokeniserState . Rcdata ) ; tb . markInsertionMode () ; tb . transition ( Text ) ; tb . insert ( startTag ) ; }
private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode () ; tb . transition ( Text ) ; tb . insert ( startTag ) ; }
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case Character : Token . Character c = t . asCharacter () ; if ( c . getData () . equals ( nullString ) ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isEndTag () && t . asEndTag () . normalName () . equals ( lr_50 ) ) { Token . EndTag endTag = t . asEndTag () ; String name = endTag . normalName () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case StartTag : Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isStartTag () ) { Token . StartTag startTag = t . asStartTag () ; String name = startTag . normalName () ; if ( name . equals ( lr_59 ) ) {
private boolean handleMissingTr ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N]
private boolean handleMissingTr ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N]
private boolean handleMissingTr ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N]
private boolean handleMissingTr ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N]
private boolean handleMissingTr ( Token t , TreeBuilder tb ) { boolean processed = tb . processEndTag ( lr_58 ) ; if ( processed ) return tb . process ( t ) ; else return false ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N]
if ( tb . inTableScope ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . inTableScope ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . inTableScope ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . inTableScope ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case Character :
if ( tb . inTableScope ( lr_56 ) ) tb . processEndTag ( lr_56 ) ; else tb . processEndTag ( lr_57 ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case Character :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isStartTag () && StringUtil . in ( t . asStartTag () . normalName () , lr_50 , lr_27 , lr_53 , lr_54 , lr_55 , lr_58 , lr_56 , lr_57 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { return true ; } else if ( t . isComment () ) { tb . insert ( t . asComment () ) ;
} else { tb . transition ( BeforeHtml ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( BeforeHtml ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( BeforeHtml ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( BeforeHtml ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
} else { tb . transition ( BeforeHtml ) ; return tb . process ( t ) ; } return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isDoctype () ) { tb . error ( this ) ; } else if ( t . isStartTag () && t . asStartTag () . normalName () . equals ( lr_1 ) ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
return true ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isComment () ) {
tb . insertStartTag ( lr_1 ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . insertStartTag ( lr_1 ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . insertStartTag ( lr_1 ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . insertStartTag ( lr_1 ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
tb . insertStartTag ( lr_1 ) ; tb . transition ( BeforeHead ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { return true ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( isWhitespace ( t ) ) { tb . insert ( t . asCharacter () ) ; return true ; } switch ( t . type ) { case Comment :
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isCharacter () ) { tb . newPendingTableCharacters () ; tb . markInsertionMode () ; tb . transition ( InTableText ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isCharacter () ) { tb . newPendingTableCharacters () ; tb . markInsertionMode () ; tb . transition ( InTableText ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isCharacter () ) { tb . newPendingTableCharacters () ; tb . markInsertionMode () ; tb . transition ( InTableText ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isCharacter () ) { tb . newPendingTableCharacters () ; tb . markInsertionMode () ; tb . transition ( InTableText ) ; return tb . process ( t ) ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isCharacter () ) { tb . newPendingTableCharacters () ; tb . markInsertionMode () ; tb . transition ( InTableText ) ; return tb . process ( t ) ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
tb . framesetOk ( true ) ; return tb . process ( t ) ; } boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] switch ( t . type ) { case Character : { Token . Character c = t . asCharacter () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.ABSMutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isEOF () ) { tb . error ( this ) ; tb . pop () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI1Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isEOF () ) { tb . error ( this ) ; tb . pop () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI3Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isEOF () ) { tb . error ( this ) ; tb . pop () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI4Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isEOF () ) { tb . error ( this ) ; tb . pop () ;
boolean process ( Token t , HtmlTreeBuilder tb ) { MST[rv.UOI2Mutator]MSP[N] if ( t . isCharacter () ) { tb . insert ( t . asCharacter () ) ; } else if ( t . isEOF () ) { tb . error ( this ) ; tb . pop () ;
public static Connection connect ( String url ) { Connection con = new HttpConnection () ; con . url ( url ) ; return con ; } public static Connection connect ( URL url ) { Connection con = new HttpConnection () ; con . url ( url ) ;
return con ; } private static String encodeUrl ( String url ) { try { URL u = new URL ( url ) ; return encodeUrl ( u ) . toExternalForm () ; } catch ( Exception e ) { return url ; } }
static URL encodeUrl ( URL u ) { try { String urlS = u . toExternalForm () ; urlS = urlS . replace ( lr_1 , lr_2 ) ; final URI uri = new URI ( urlS ) ; return new URL ( uri . toASCIIString () ) ;
} catch ( URISyntaxException | MalformedURLException e ) { return u ; } } private static String encodeMimeName ( String val ) { if ( val == null ) return null ; return val . replace ( lr_3 , lr_4 ) ; }
public Connection url ( URL url ) { req . url ( url ) ; return this ; } public Connection url ( String url ) { Validate . notEmpty ( url , lr_5 ) ; try {
req . url ( new URL ( encodeUrl ( url ) ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( lr_6 + url , e ) ; } return this ; } public Connection proxy ( Proxy proxy ) {
req . proxy ( proxy ) ; return this ; } public Connection proxy ( String host , int port ) { req . proxy ( host , port ) ; return this ; } public Connection userAgent ( String userAgent ) {
Validate . notNull ( userAgent , lr_7 ) ; req . header ( USER_AGENT , userAgent ) ; return this ; } public Connection timeout ( int millis ) { req . timeout ( millis ) ; return this ; } public Connection maxBodySize ( int bytes ) {
req . maxBodySize ( bytes ) ; return this ; } public Connection followRedirects ( boolean followRedirects ) { req . followRedirects ( followRedirects ) ; return this ; } public Connection referrer ( String referrer ) { Validate . notNull ( referrer , lr_8 ) ;
req . header ( lr_9 , referrer ) ; return this ; } public Connection method ( Method method ) { req . method ( method ) ; return this ; } public Connection ignoreHttpErrors ( boolean ignoreHttpErrors ) { req . ignoreHttpErrors ( ignoreHttpErrors ) ; return this ;
} public Connection ignoreContentType ( boolean ignoreContentType ) { req . ignoreContentType ( ignoreContentType ) ; return this ; } public Connection data ( String key , String value ) { req . data ( KeyVal . create ( key , value ) ) ; return this ; }
public Connection sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { req . sslSocketFactory ( sslSocketFactory ) ; return this ; } public Connection data ( String key , String filename , InputStream inputStream ) { req . data ( KeyVal . create ( key , filename , inputStream ) ) ;
return this ; } @Override public Connection data ( String key , String filename , InputStream inputStream , String contentType ) { req . data ( KeyVal . create ( key , filename , inputStream ) . contentType ( contentType ) ) ; return this ; }
public Connection data ( Map < String , String > data ) { Validate . notNull ( data , lr_10 ) ; for ( Map . Entry < String , String > entry : data . entrySet () ) {
req . data ( KeyVal . create ( entry . getKey () , entry . getValue () ) ) ; } return this ; } public Connection data ( String ... keyvals ) { Validate . notNull ( keyvals , lr_11 ) ;
Validate . isTrue ( keyvals . length % 2 == 0 , lr_12 ) ; for ( int i = 0 ; i < keyvals . length ; i += 2 ) { String key = keyvals [ i ] ;
String value = keyvals [ i + 1 ] ; Validate . notEmpty ( key , lr_13 ) ; Validate . notNull ( value , lr_14 ) ; req . data ( KeyVal . create ( key , value ) ) ; } return this ; }
public Connection data ( Collection < Connection . KeyVal > data ) { Validate . notNull ( data , lr_15 ) ; for ( Connection . KeyVal entry : data ) { req . data ( entry ) ; } return this ; }
public Connection . KeyVal data ( String key ) { Validate . notEmpty ( key , lr_13 ) ; for ( Connection . KeyVal keyVal : request () . data () ) { if ( keyVal . key () . equals ( key ) ) return keyVal ; }
return null ; } public Connection requestBody ( String body ) { req . requestBody ( body ) ; return this ; } public Connection header ( String name , String value ) { req . header ( name , value ) ; return this ; }
public Connection headers ( Map < String , String > headers ) { Validate . notNull ( headers , lr_16 ) ; for ( Map . Entry < String , String > entry : headers . entrySet () ) {
req . header ( entry . getKey () , entry . getValue () ) ; } return this ; } public Connection cookie ( String name , String value ) { req . cookie ( name , value ) ; return this ; }
public Connection cookies ( Map < String , String > cookies ) { Validate . notNull ( cookies , lr_17 ) ; for ( Map . Entry < String , String > entry : cookies . entrySet () ) {
req . cookie ( entry . getKey () , entry . getValue () ) ; } return this ; } public Connection parser ( Parser parser ) { req . parser ( parser ) ; return this ; } public Document get () throws IOException {
req . method ( Method . GET ) ; execute () ; return res . parse () ; } public Document post () throws IOException { req . method ( Method . POST ) ; execute () ; return res . parse () ; }
public Connection . Response execute () throws IOException { res = Response . execute ( req ) ; return res ; } public Connection . Request request () { return req ; } public Connection request ( Connection . Request request ) { req = request ; return this ;
} public Connection . Response response () { return res ; } public Connection response ( Connection . Response response ) { res = response ; return this ; } public Connection postDataCharset ( String charset ) { req . postDataCharset ( charset ) ; return this ; }
public URL url () { return url ; } public T url ( URL url ) { Validate . notNull ( url , lr_18 ) ; this . url = url ; return ( T ) this ; } public Method method () { return method ; }
public T method ( Method method ) { Validate . notNull ( method , lr_19 ) ; this . method = method ; return ( T ) this ; } public String header ( String name ) { Validate . notNull ( name , lr_20 ) ;
List < String > vals = getHeadersCaseInsensitive ( name ) ; if ( vals . size () > 0 ) { return StringUtil . join ( vals , lr_21 ) ; } return null ; } @Override public T addHeader ( String name , String value ) {
Validate . notEmpty ( name ) ; value = value == null ? lr_22 : value ; List < String > values = headers ( name ) ; if ( values . isEmpty () ) { values = new ArrayList <> () ;
headers . put ( name , values ) ; } values . add ( fixHeaderEncoding ( value ) ) ; return ( T ) this ; } @Override public List < String > headers ( String name ) { Validate . notEmpty ( name ) ;
return getHeadersCaseInsensitive ( name ) ; } private static String fixHeaderEncoding ( String val ) { try { byte [] bytes = val . getBytes ( lr_23 ) ; if ( ! looksLikeUtf8 ( bytes ) ) return val ; return new String ( bytes , lr_24 ) ;
} catch ( UnsupportedEncodingException e ) { return val ; } } private static boolean looksLikeUtf8 ( byte [] input ) { int i = 0 ; if ( input . length >= 3 && ( input [ 0 ] & 0xFF ) == 0xEF
&& ( input [ 1 ] & 0xFF ) == 0xBB & ( input [ 2 ] & 0xFF ) == 0xBF ) { i = 3 ; } int end ; for ( int j = input . length ; i < j ; ++ i ) {
int o = input [ i ] ; if ( ( o & 0x80 ) == 0 ) { continue; } if ( ( o & 0xE0 ) == 0xC0 ) { end = i + 1 ;
} else if ( ( o & 0xF0 ) == 0xE0 ) { end = i + 2 ; } else if ( ( o & 0xF8 ) == 0xF0 ) { end = i + 3 ; } else { return false ; }
if ( end >= input . length ) return false ; while ( i < end ) { i ++ ; o = input [ i ] ; if ( ( o & 0xC0 ) != 0x80 ) { return false ; } } } return true ; }
public T header ( String name , String value ) { Validate . notEmpty ( name , lr_25 ) ; removeHeader ( name ) ; addHeader ( name , value ) ; return ( T ) this ; } public boolean hasHeader ( String name ) {
Validate . notEmpty ( name , lr_25 ) ; return ! getHeadersCaseInsensitive ( name ) . isEmpty () ; } public boolean hasHeaderWithValue ( String name , String value ) { Validate . notEmpty ( name ) ; Validate . notEmpty ( value ) ;
List < String > values = headers ( name ) ; for ( String candidate : values ) { if ( value . equalsIgnoreCase ( candidate ) ) return true ; } return false ; } public T removeHeader ( String name ) {
Validate . notEmpty ( name , lr_25 ) ; Map . Entry < String , List < String > > entry = scanHeaders ( name ) ; if ( entry != null ) headers . remove ( entry . getKey () ) ; return ( T ) this ; }
public Map < String , String > headers () { LinkedHashMap < String , String > map = new LinkedHashMap <> ( headers . size () ) ; for ( Map . Entry < String , List < String > > entry : headers . entrySet () ) {
String header = entry . getKey () ; List < String > values = entry . getValue () ; if ( values . size () > 0 ) map . put ( header , values . get ( 0 ) ) ; } return map ; } @Override
public Map < String , List < String > > multiHeaders () { return headers ; } private List < String > getHeadersCaseInsensitive ( String name ) { Validate . notNull ( name ) ;
for ( Map . Entry < String , List < String > > entry : headers . entrySet () ) { if ( name . equalsIgnoreCase ( entry . getKey () ) ) return entry . getValue () ; } return Collections . emptyList () ; }
private Map . Entry < String , List < String > > scanHeaders ( String name ) { String lc = lowerCase ( name ) ; for ( Map . Entry < String , List < String > > entry : headers . entrySet () ) {
if ( lowerCase ( entry . getKey () ) . equals ( lc ) ) return entry ; } return null ; } public String cookie ( String name ) { Validate . notEmpty ( name , lr_26 ) ; return cookies . get ( name ) ; }
public T cookie ( String name , String value ) { Validate . notEmpty ( name , lr_26 ) ; Validate . notNull ( value , lr_27 ) ; cookies . put ( name , value ) ; return ( T ) this ; }
public boolean hasCookie ( String name ) { Validate . notEmpty ( name , lr_26 ) ; return cookies . containsKey ( name ) ; } public T removeCookie ( String name ) { Validate . notEmpty ( name , lr_26 ) ; cookies . remove ( name ) ;
return ( T ) this ; } public Map < String , String > cookies () { return cookies ; } public Proxy proxy () { return proxy ; } public Request proxy ( Proxy proxy ) { this . proxy = proxy ; return this ; }
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . isTrue ( bytes >= 0 , lr_29 ) ; maxBodySizeBytes = bytes ; return this ; } public boolean followRedirects () { return followRedirects ; } public Connection . Request followRedirects ( boolean followRedirects ) { this . followRedirects = followRedirects ; return this ; }
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ;
return this ; } public String requestBody () { return body ; } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; }
public Connection . Request postDataCharset ( String charset ) { Validate . notNull ( charset , lr_31 ) ; if ( ! Charset . isSupported ( charset ) ) throw new IllegalCharsetNameException ( charset ) ; this . postDataCharset = charset ; return this ; }
public String postDataCharset () { return postDataCharset ; } static Response execute ( Connection . Request req ) throws IOException { return execute ( req , null ) ; } static Response execute ( Connection . Request req , Response previousResponse ) throws IOException {
Validate . notNull ( req , lr_32 ) ; Validate . notNull ( req . url () , lr_33 ) ; String protocol = req . url () . getProtocol () ; if ( ! protocol . equals ( lr_34 ) && ! protocol . equals ( lr_35 ) )
throw new MalformedURLException ( lr_36 ) ; final boolean methodHasBody = req . method () . hasBody () ; final boolean hasRequestBody = req . requestBody () != null ; if ( ! methodHasBody ) Validate . isFalse ( hasRequestBody , lr_37 + req . method () ) ;
String mimeBoundary = null ; if ( req . data () . size () > 0 && ( ! methodHasBody || hasRequestBody ) ) serialiseRequestUrl ( req ) ; else if ( methodHasBody ) mimeBoundary = setOutputContentType ( req ) ; long startTime = System . nanoTime () ;
HttpURLConnection conn = createConnection ( req ) ; Response res = null ; try { conn . connect () ; if ( conn . getDoOutput () ) writePost ( req , conn . getOutputStream () , mimeBoundary ) ; int status = conn . getResponseCode () ;
res = new Response ( previousResponse ) ; res . setupFromConnection ( conn , previousResponse ) ; res . req = req ; if ( res . hasHeader ( LOCATION ) && req . followRedirects () ) { if ( status != HTTP_TEMP_REDIR ) {
req . method ( Method . GET ) ; req . data () . clear () ; req . requestBody ( null ) ; req . removeHeader ( CONTENT_TYPE ) ; } String location = res . header ( LOCATION ) ;
if ( location . startsWith ( lr_38 ) && location . charAt ( 6 ) != '/' ) location = location . substring ( 6 ) ; URL redir = StringUtil . resolve ( req . url () , location ) ;
req . url ( encodeUrl ( redir ) ) ; for ( Map . Entry < String , String > cookie : res . cookies . entrySet () ) { req . cookie ( cookie . getKey () , cookie . getValue () ) ; }
return execute ( req , res ) ; } if ( ( status < 200 || status >= 400 ) && ! req . ignoreHttpErrors () ) throw new HttpStatusException ( lr_39 , status , req . url () . toString () ) ;
String contentType = res . contentType () ; if ( contentType != null && ! req . ignoreContentType () && ! contentType . startsWith ( lr_40 ) && ! xmlContentTypeRxp . matcher ( contentType ) . matches () ) throw new UnsupportedMimeTypeException ( lr_41 ,
contentType , req . url () . toString () ) ; if ( contentType != null && xmlContentTypeRxp . matcher ( contentType ) . matches () ) { if ( req instanceof HttpConnection . Request && ! ( ( Request ) req ) . parserDefined ) {
req . parser ( Parser . xmlParser () ) ; } } res . charset = DataUtil . getCharsetFromContentType ( res . contentType ) ; if ( conn . getContentLength () != 0 && req . method () != HEAD ) { res . bodyStream = null ;
res . bodyStream = conn . getErrorStream () != null ? conn . getErrorStream () : conn . getInputStream () ; if ( res . hasHeaderWithValue ( CONTENT_ENCODING , lr_42 ) ) { res . bodyStream = new GZIPInputStream ( res . bodyStream ) ;
} else if ( res . hasHeaderWithValue ( CONTENT_ENCODING , lr_43 ) ) { res . bodyStream = new InflaterInputStream ( res . bodyStream , new Inflater ( true ) ) ; } res . bodyStream = ConstrainableInputStream
. wrap ( res . bodyStream , DataUtil . bufferSize , req . maxBodySize () ) . timeout ( startTime , req . timeout () ) ; } else { res . byteData = DataUtil . emptyByteBuffer () ; } } catch ( IOException e ) {
if ( res != null ) res . safeClose () ; throw e ; } res . executed = true ; return res ; } public int statusCode () { return statusCode ; } public String statusMessage () { return statusMessage ; } public String charset () {
return charset ; } public Response charset ( String charset ) { this . charset = charset ; return this ; } public String contentType () { return contentType ; } public Document parse () throws IOException { Validate . isTrue ( executed , lr_44 ) ;
if ( byteData != null ) { bodyStream = new ByteArrayInputStream ( byteData . array () ) ; inputStreamRead = false ; } Validate . isFalse ( inputStreamRead , lr_45 ) ;
Document doc = DataUtil . parseInputStream ( bodyStream , charset , url . toExternalForm () , req . parser () ) ; charset = doc . outputSettings () . charset () . name () ; inputStreamRead = true ; safeClose () ; return doc ; }
private void prepareByteData () { Validate . isTrue ( executed , lr_46 ) ; if ( byteData == null ) { Validate . isFalse ( inputStreamRead , lr_47 ) ; try { byteData = DataUtil . readToByteBuffer ( bodyStream , req . maxBodySize () ) ;
} catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } finally { inputStreamRead = true ; safeClose () ; } } } public String body () { prepareByteData () ; String body ; if ( charset == null )
body = Charset . forName ( DataUtil . defaultCharset ) . decode ( byteData ) . toString () ; else body = Charset . forName ( charset ) . decode ( byteData ) . toString () ; ( ( Buffer ) byteData ) . rewind () ; return body ;
} public byte [] bodyAsBytes () { prepareByteData () ; return byteData . array () ; } @Override public Connection . Response bufferUp () { prepareByteData () ; return this ; } @Override public BufferedInputStream bodyStream () { Validate . isTrue ( executed , lr_46 ) ;
Validate . isFalse ( inputStreamRead , lr_48 ) ; inputStreamRead = true ; return ConstrainableInputStream . wrap ( bodyStream , DataUtil . bufferSize , req . maxBodySize () ) ; } private static HttpURLConnection createConnection ( Connection . Request req ) throws IOException { final HttpURLConnection conn = (HttpURLConnection) (
req . proxy () == null ? req . url () . openConnection () : req . url () . openConnection ( req . proxy () ) ) ; conn . setRequestMethod ( req . method () . name () ) ; conn . setInstanceFollowRedirects ( false ) ;
conn . setConnectTimeout ( req . timeout () ) ; conn . setReadTimeout ( req . timeout () / 2 ) ; if ( req . sslSocketFactory () != null && conn instanceof HttpsURLConnection ) ( ( HttpsURLConnection ) conn ) . setSSLSocketFactory ( req . sslSocketFactory () ) ;
if ( req . method () . hasBody () ) conn . setDoOutput ( true ) ; if ( req . cookies () . size () > 0 ) conn . addRequestProperty ( lr_49 , getRequestCookieString ( req ) ) ;
for ( Map . Entry < String , List < String > > header : req . multiHeaders () . entrySet () ) { for ( String value : header . getValue () ) { conn . addRequestProperty ( header . getKey () , value ) ; } }
return conn ; } private void safeClose () { if ( bodyStream != null ) { try { bodyStream . close () ; } catch ( IOException e ) { } finally { bodyStream = null ; } } if ( conn != null ) {
conn . disconnect () ; conn = null ; } } private void setupFromConnection ( HttpURLConnection conn , HttpConnection . Response previousResponse ) throws IOException { this . conn = conn ; method = Method . valueOf ( conn . getRequestMethod () ) ;
url = conn . getURL () ; statusCode = conn . getResponseCode () ; statusMessage = conn . getResponseMessage () ; contentType = conn . getContentType () ; Map < String , List < String > > resHeaders = createHeaderMap ( conn ) ; processResponseHeaders ( resHeaders ) ;
if ( previousResponse != null ) { for ( Map . Entry < String , String > prevCookie : previousResponse . cookies () . entrySet () ) { if ( ! hasCookie ( prevCookie . getKey () ) )
cookie ( prevCookie . getKey () , prevCookie . getValue () ) ; } previousResponse . safeClose () ; } } private static LinkedHashMap < String , List < String > > createHeaderMap ( HttpURLConnection conn ) {
final LinkedHashMap < String , List < String > > headers = new LinkedHashMap <> () ; int i = 0 ; while ( true ) { final String key = conn . getHeaderFieldKey ( i ) ; final String val = conn . getHeaderField ( i ) ;
if ( key == null && val == null ) break; i ++ ; if ( key == null || val == null ) continue; if ( headers . containsKey ( key ) ) headers . get ( key ) . add ( val ) ; else {
final ArrayList < String > vals = new ArrayList <> () ; vals . add ( val ) ; headers . put ( key , vals ) ; } } return headers ; } void processResponseHeaders ( Map < String , List < String > > resHeaders ) {
for ( Map . Entry < String , List < String > > entry : resHeaders . entrySet () ) { String name = entry . getKey () ; if ( name == null ) continue; List < String > values = entry . getValue () ;
if ( name . equalsIgnoreCase ( lr_50 ) ) { for ( String value : values ) { if ( value == null ) continue; TokenQueue cd = new TokenQueue ( value ) ; String cookieName = cd . chompTo ( lr_51 ) . trim () ;
String cookieVal = cd . consumeTo ( lr_52 ) . trim () ; if ( cookieName . length () > 0 ) cookie ( cookieName , cookieVal ) ; } } for ( String value : values ) { addHeader ( name , value ) ; } } }
private static String setOutputContentType ( final Connection . Request req ) { String bound = null ; if ( req . hasHeader ( CONTENT_TYPE ) ) { if( req . header ( CONTENT_TYPE ) . contains ( MULTIPART_FORM_DATA ) &&
! req . header ( CONTENT_TYPE ) . contains ( lr_53 ) ) { bound = DataUtil . mimeBoundary () ; req . header ( CONTENT_TYPE , MULTIPART_FORM_DATA + lr_54 + bound ) ; } } else if ( needsMultipart ( req ) ) {
bound = DataUtil . mimeBoundary () ; req . header ( CONTENT_TYPE , MULTIPART_FORM_DATA + lr_54 + bound ) ; } else { req . header ( CONTENT_TYPE , FORM_URL_ENCODED + lr_55 + req . postDataCharset () ) ; } return bound ; }
private static void writePost ( final Connection . Request req , final OutputStream outputStream , final String bound ) throws IOException { final Collection < Connection . KeyVal > data = req . data () ;
final BufferedWriter w = new BufferedWriter ( new OutputStreamWriter ( outputStream , req . postDataCharset () ) ) ; if ( bound != null ) { for ( Connection . KeyVal keyVal : data ) { w . write ( lr_56 ) ; w . write ( bound ) ;
w . write ( lr_57 ) ; w . write ( lr_58 ) ; w . write ( encodeMimeName ( keyVal . key () ) ) ; w . write ( lr_3 ) ; if ( keyVal . hasInputStream () ) { w . write ( lr_59 ) ;
w . write ( encodeMimeName ( keyVal . value () ) ) ; w . write ( lr_60 ) ; w . write ( keyVal . contentType () != null ? keyVal . contentType () : DefaultUploadType ) ; w . write ( lr_61 ) ;
w . flush () ; DataUtil . crossStreams ( keyVal . inputStream () , outputStream ) ; outputStream . flush () ; } else { w . write ( lr_61 ) ; w . write ( keyVal . value () ) ; } w . write ( lr_57 ) ;
} w . write ( lr_56 ) ; w . write ( bound ) ; w . write ( lr_56 ) ; } else if ( req . requestBody () != null ) { w . write ( req . requestBody () ) ; } else {
boolean first = true ; for ( Connection . KeyVal keyVal : data ) { if ( ! first ) w . append ( '&' ) ; else first = false ;
w . write ( URLEncoder . encode ( keyVal . key () , req . postDataCharset () ) ) ; w . write ( '=' ) ; w . write ( URLEncoder . encode ( keyVal . value () , req . postDataCharset () ) ) ; } }
w . close () ; } private static String getRequestCookieString ( Connection . Request req ) { StringBuilder sb = StringUtil . borrowBuilder () ; boolean first = true ;
for ( Map . Entry < String , String > cookie : req . cookies () . entrySet () ) { if ( ! first ) sb . append ( lr_62 ) ; else first = false ;
sb . append ( cookie . getKey () ) . append ( '=' ) . append ( cookie . getValue () ) ; } return StringUtil . releaseBuilder ( sb ) ; } private static void serialiseRequestUrl ( Connection . Request req ) throws IOException {
URL in = req . url () ; StringBuilder url = StringUtil . borrowBuilder () ; boolean first = true ; url . append ( in . getProtocol () ) . append ( lr_63 ) . append ( in . getAuthority () )
. append ( in . getPath () ) . append ( lr_64 ) ; if ( in . getQuery () != null ) { url . append ( in . getQuery () ) ; first = false ; }
for ( Connection . KeyVal keyVal : req . data () ) { Validate . isFalse ( keyVal . hasInputStream () , lr_65 ) ; if ( ! first ) url . append ( '&' ) ; else first = false ; url
. append ( URLEncoder . encode ( keyVal . key () , DataUtil . defaultCharset ) ) . append ( '=' ) . append ( URLEncoder . encode ( keyVal . value () , DataUtil . defaultCharset ) ) ; }
req . url ( new URL ( StringUtil . releaseBuilder ( url ) ) ) ; req . data () . clear () ; } private static boolean needsMultipart ( Connection . Request req ) { for ( Connection . KeyVal keyVal : req . data () ) {
if ( keyVal . hasInputStream () ) return true ; } return false ; } public static KeyVal create ( String key , String value ) { return new KeyVal () . key ( key ) . value ( value ) ; }
public static KeyVal create ( String key , String filename , InputStream stream ) { return new KeyVal () . key ( key ) . value ( filename ) . inputStream ( stream ) ; } public KeyVal key ( String key ) {
Validate . notEmpty ( key , lr_13 ) ; this . key = key ; return this ; } public String key () { return key ; } public KeyVal value ( String value ) { Validate . notNull ( value , lr_14 ) ;
this . value = value ; return this ; } public String value () { return value ; } public KeyVal inputStream ( InputStream inputStream ) { Validate . notNull ( value , lr_66 ) ; this . stream = inputStream ; return this ; }
public InputStream inputStream () { return stream ; } public boolean hasInputStream () { return stream != null ; } @Override public Connection . KeyVal contentType ( String contentType ) { Validate . notEmpty ( contentType ) ; this . contentType = contentType ; return this ; } @Override
public String contentType () { return contentType ; } @Override public String toString () { return key + lr_51 + value ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[ConditionalsBoundaryMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.ABSMutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; MST[ReturnValsMutator]MSP[S] } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
return this ; MST[NullReturnValsMutator]MSP[S] } public String requestBody () { return body ; } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[PrimitiveReturnsMutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.ABSMutator]MSP[N] }
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; MST[BooleanTrueReturnValsMutator]MSP[S] } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[experimental.MemberVariableMutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; MST[NullReturnValsMutator]MSP[S] } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI1Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; MST[ReturnValsMutator]MSP[S] } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI4Mutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.ABSMutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; MST[ReturnValsMutator]MSP[S] } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI4Mutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI3Mutator]MSP[S]
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI2Mutator]MSP[N] }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR2Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; MST[ReturnValsMutator]MSP[S] } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI1Mutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
return ( T ) this ; } public Map < String , String > cookies () { return cookies ; } public Proxy proxy () { return proxy ; MST[NullReturnValsMutator]MSP[N] } public Request proxy ( Proxy proxy ) { this . proxy = proxy ; return this ; }
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; MST[NullReturnValsMutator]MSP[S] } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR3Mutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return ( T ) this ; } public Map < String , String > cookies () { return cookies ; } public Proxy proxy () { return proxy ; MST[ReturnValsMutator]MSP[N] } public Request proxy ( Proxy proxy ) { this . proxy = proxy ; return this ; }
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI2Mutator]MSP[S]
return this ; } public boolean ignoreContentType () { return ignoreContentType ; MST[BooleanTrueReturnValsMutator]MSP[S] } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; } public String requestBody () { return body ; } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; MST[ReturnValsMutator]MSP[S] }
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; MST[ReturnValsMutator]MSP[N] } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Connection . Request requestBody ( String body ) { this . body = body ;
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ; MST[experimental.MemberVariableMutator]MSP[N]
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI4Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI2Mutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[VoidMethodCallMutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[experimental.MemberVariableMutator]MSP[S]
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[PrimitiveReturnsMutator]MSP[N] }
return this ; } public boolean ignoreContentType () { return ignoreContentType ; MST[ReturnValsMutator]MSP[S] } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI1Mutator]MSP[S] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public String postDataCharset () { return postDataCharset ; MST[EmptyObjectReturnValsMutator]MSP[S] } static Response execute ( Connection . Request req ) throws IOException { return execute ( req , null ) ; } static Response execute ( Connection . Request req , Response previousResponse ) throws IOException {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; MST[ReturnValsMutator]MSP[S] } public Request data ( Connection . KeyVal keyval ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; MST[NullReturnValsMutator]MSP[N] } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.ABSMutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR6Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI3Mutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR4Mutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; MST[NonVoidMethodCallMutator]MSP[N] return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ;
return this ; } public String requestBody () { return body ; } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; MST[NullReturnValsMutator]MSP[S] }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[NegateConditionalsMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[ReturnValsMutator]MSP[N] }
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; MST[NullReturnValsMutator]MSP[S] } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[InlineConstantMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public String postDataCharset () { return postDataCharset ; MST[ReturnValsMutator]MSP[S] } static Response execute ( Connection . Request req ) throws IOException { return execute ( req , null ) ; } static Response execute ( Connection . Request req , Response previousResponse ) throws IOException {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[ReturnValsMutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public String requestBody () { return body ; MST[ReturnValsMutator]MSP[N] } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; }
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI1Mutator]MSP[N] }
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI3Mutator]MSP[N] }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR1Mutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; MST[NullReturnValsMutator]MSP[S] } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR5Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ROR3Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI1Mutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI2Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . notNull ( keyval , lr_30 ) ; MST[VoidMethodCallMutator]MSP[S] data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; } public Connection . Request requestBody ( String body ) { this . body = body ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI3Mutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR4Mutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.ABSMutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; MST[BooleanFalseReturnValsMutator]MSP[N] } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ;
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR5Mutator]MSP[S] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI4Mutator]MSP[S]
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI4Mutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; MST[rv.UOI2Mutator]MSP[S] return this ; } public Request data ( Connection . KeyVal keyval ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.UOI3Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
Validate . notNull ( keyval , lr_30 ) ; data . add ( keyval ) ; return this ; } public Collection < Connection . KeyVal > data () { return data ; MST[ReturnValsMutator]MSP[N] } public Connection . Request requestBody ( String body ) { this . body = body ;
return this ; } public String requestBody () { return body ; MST[EmptyObjectReturnValsMutator]MSP[N] } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[rv.UOI2Mutator]MSP[S] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; MST[ReturnValsMutator]MSP[S] } public String requestBody () { return body ; } public Request parser ( Parser parser ) { this . parser = parser ; parserDefined = true ; return this ; } public Parser parser () { return parser ; }
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; MST[rv.UOI3Mutator]MSP[S] } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; timeoutMilliseconds = millis ; MST[experimental.MemberVariableMutator]MSP[N] return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
public Request timeout ( int millis ) { Validate . isTrue ( millis >= 0 , lr_28 ) ; MST[rv.CRCR2Mutator]MSP[N] timeoutMilliseconds = millis ; return this ; } public int maxBodySize () { return maxBodySizeBytes ; } public Connection . Request maxBodySize ( int bytes ) {
return this ; } public boolean ignoreContentType () { return ignoreContentType ; MST[BooleanFalseReturnValsMutator]MSP[S] } public Connection . Request ignoreContentType ( boolean ignoreContentType ) { this . ignoreContentType = ignoreContentType ; return this ; } public Request data ( Connection . KeyVal keyval ) {
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.ABSMutator]MSP[S]
public Request proxy ( String host , int port ) { this . proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( host , port ) ) ; return this ; } public int timeout () { return timeoutMilliseconds ; MST[rv.UOI4Mutator]MSP[N] }
public boolean ignoreHttpErrors () { return ignoreHttpErrors ; } public SSLSocketFactory sslSocketFactory () { return sslSocketFactory ; } public void sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; } public Connection . Request ignoreHttpErrors ( boolean ignoreHttpErrors ) { this . ignoreHttpErrors = ignoreHttpErrors ; MST[rv.UOI1Mutator]MSP[S]
public static String lowerCase ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String normalize ( final String input , boolean isStringLiteral ) { return isStringLiteral ? lowerCase ( input ) : normalize ( input ) ; }
public static String lowerCase ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[rv.ROR5Mutator]MSP[N] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String lowerCase ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[NegateConditionalsMutator]MSP[N] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String lowerCase ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String lowerCase ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[ReturnValsMutator]MSP[N] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String lowerCase ( final String input ) { return input != null ? input . toLowerCase ( Locale . ENGLISH ) : lr_1 ; MST[NonVoidMethodCallMutator]MSP[S] } public static String normalize ( final String input ) { return lowerCase ( input ) . trim () ; }
public static String normalize ( final String input , boolean isStringLiteral ) { return isStringLiteral ? lowerCase ( input ) : normalize ( input ) ; MST[ArgumentPropagationMutator]MSP[S] }
public static String normalize ( final String input , boolean isStringLiteral ) { return isStringLiteral ? lowerCase ( input ) : normalize ( input ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static String join ( Collection strings , String sep ) { return join ( strings . iterator () , sep ) ; } public static String join ( Iterator strings , String sep ) { if ( ! strings . hasNext () ) return lr_1 ;
String start = strings . next () . toString () ; if ( ! strings . hasNext () ) return start ; StringBuilder sb = StringUtil . borrowBuilder () . append ( start ) ; while ( strings . hasNext () ) { sb . append ( sep ) ;
sb . append ( strings . next () ) ; } return StringUtil . releaseBuilder ( sb ) ; } public static String join ( String [] strings , String sep ) { return join ( Arrays . asList ( strings ) , sep ) ; }
public static String padding ( int width ) { if ( width < 0 ) throw new IllegalArgumentException ( lr_2 ) ; if ( width < padding . length ) return padding [ width ] ; char [] out = new char [ width ] ;
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
public static boolean isWhitespace ( int c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' ; } public static boolean isActuallyWhitespace ( int c ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
public static String normaliseWhitespace ( String string ) { StringBuilder sb = StringUtil . borrowBuilder () ; appendNormalisedWhitespace ( sb , string , false ) ; return StringUtil . releaseBuilder ( sb ) ; } public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) {
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) {
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) {
base = new URL ( base . getProtocol () , base . getHost () , base . getPort () , lr_4 + base . getFile () ) ; } return new URL ( base , relUrl ) ; }
public static String resolve ( final String baseUrl , final String relUrl ) { URL base ; try { try { base = new URL ( baseUrl ) ; } catch ( MalformedURLException e ) { URL abs = new URL ( relUrl ) ;
return abs . toExternalForm () ; } return resolve ( base , relUrl ) . toExternalForm () ; } catch ( MalformedURLException e ) { return lr_1 ; } } public static StringBuilder borrowBuilder () { synchronized ( builders ) { return builders . empty () ?
new StringBuilder ( MaxCachedBuilderSize ) : builders . pop () ; } } public static String releaseBuilder ( StringBuilder sb ) { Validate . notNull ( sb ) ; String string = sb . toString () ; if ( sb . length () > MaxCachedBuilderSize )
sb = new StringBuilder ( MaxCachedBuilderSize ) ; else sb . delete ( 0 , sb . length () ) ; synchronized ( builders ) { builders . push ( sb ) ; while ( builders . size () > MaxIdleBuilders ) { builders . pop () ; } }
return string ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI3Mutator]MSP[S] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
else if ( ! isInvisibleChar ( c ) ) { MST[rv.UOI4Mutator]MSP[N] accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
public static String normaliseWhitespace ( String string ) { StringBuilder sb = StringUtil . borrowBuilder () ; appendNormalisedWhitespace ( sb , string , false ) ; MST[rv.CRCR3Mutator]MSP[S] return StringUtil . releaseBuilder ( sb ) ; } public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR5Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR4Mutator]MSP[S] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; return String . valueOf ( out ) ; MST[ReturnValsMutator]MSP[S] } public static boolean isBlank ( String string ) {
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.UOI1Mutator]MSP[N]
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) MST[rv.ROR4Mutator]MSP[S] return true ; } return false ; }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.UOI3Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[InlineConstantMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; MST[rv.CRCR3Mutator]MSP[N] reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR2Mutator]MSP[S] if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) return true ; MST[rv.CRCR4Mutator]MSP[N] } return false ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { MST[rv.CRCR1Mutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI4Mutator]MSP[S] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) MST[rv.ROR1Mutator]MSP[S] return false ; } return true ; }
return abs . toExternalForm () ; } return resolve ( base , relUrl ) . toExternalForm () ; MST[NonVoidMethodCallMutator]MSP[N] } catch ( MalformedURLException e ) { return lr_1 ; } } public static StringBuilder borrowBuilder () { synchronized ( builders ) { return builders . empty () ?
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; MST[rv.CRCR1Mutator]MSP[S] } return true ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.CRCR5Mutator]MSP[S] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ; MST[rv.CRCR3Mutator]MSP[N]
if ( string == null || string . length () == 0 ) return true ; MST[rv.CRCR6Mutator]MSP[N] int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.UOI1Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { MST[rv.UOI1Mutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[S] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; MST[rv.CRCR3Mutator]MSP[S] return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
for ( int i = 0 ; i < width ; i ++ ) MST[rv.UOI1Mutator]MSP[S] out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) MST[rv.ABSMutator]MSP[S] return true ; } return false ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ABSMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; MST[rv.CRCR5Mutator]MSP[N] lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.CRCR4Mutator]MSP[N] }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.CRCR1Mutator]MSP[N] }
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) MST[NonVoidMethodCallMutator]MSP[S] return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.UOI2Mutator]MSP[N] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
boolean lastWasWhite = false ; MST[rv.CRCR6Mutator]MSP[S] boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) {
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) MST[rv.UOI3Mutator]MSP[N] return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.ROR5Mutator]MSP[S]
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.ROR3Mutator]MSP[N]
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; MST[rv.CRCR6Mutator]MSP[N] }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; MST[rv.CRCR6Mutator]MSP[S] } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
if ( string == null || string . length () == 0 ) MST[rv.ROR5Mutator]MSP[N] return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.ROR4Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[InlineConstantMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.ROR1Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) MST[rv.ROR2Mutator]MSP[N] continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.CRCR5Mutator]MSP[N] }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ABSMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR1Mutator]MSP[S] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) ) MST[NonVoidMethodCallMutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR3Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; MST[rv.ROR2Mutator]MSP[S] } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.ABSMutator]MSP[N] }
else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; MST[NonVoidMethodCallMutator]MSP[N] lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
c = string . codePointAt ( i ) ; MST[rv.UOI4Mutator]MSP[N] if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
if ( string == null || string . length () == 0 ) MST[rv.ROR2Mutator]MSP[N] return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { MST[rv.ROR5Mutator]MSP[S] if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
for ( int i = 0 ; i < width ; i ++ ) MST[rv.UOI2Mutator]MSP[S] out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.ABSMutator]MSP[N]
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; MST[InlineConstantMutator]MSP[S] } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
for ( int i = 0 ; i < width ; i ++ ) MST[rv.CRCR5Mutator]MSP[S] out [ i ] = ' ' ; return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
public static boolean isWhitespace ( int c ) { return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' ; MST[rv.CRCR3Mutator]MSP[S] } public static boolean isActuallyWhitespace ( int c ) {
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.CRCR2Mutator]MSP[S]
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) ) MST[NegateConditionalsMutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR5Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] return false ;
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[InlineConstantMutator]MSP[N] }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; MST[InlineConstantMutator]MSP[N] lastWasWhite = true ; }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { MST[NegateConditionalsMutator]MSP[N] if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { MST[rv.UOI2Mutator]MSP[N]
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { MST[rv.UOI3Mutator]MSP[N]
boolean lastWasWhite = false ; boolean reachedNonWhite = false ; int len = string . length () ; int c ; for ( int i = 0 ; i < len ; i += Character . charCount ( c ) ) { MST[rv.ROR2Mutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.UOI2Mutator]MSP[N] }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; MST[rv.UOI1Mutator]MSP[N] }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; MST[NonVoidMethodCallMutator]MSP[N] lastWasWhite = true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[InlineConstantMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; MST[rv.CRCR3Mutator]MSP[N] } } } public static boolean in ( final String needle , final String ... haystack ) {
else if ( ! isInvisibleChar ( c ) ) { MST[rv.UOI1Mutator]MSP[N] accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ; } } } public static boolean in ( final String needle , final String ... haystack ) {
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[rv.UOI1Mutator]MSP[S] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
final int len = haystack . length ; for ( int i = 0 ; i < len ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] if ( haystack [ i ] . equals ( needle ) ) return true ; } return false ; }
for ( int i = 0 ; i < width ; i ++ ) out [ i ] = ' ' ; MST[rv.UOI3Mutator]MSP[S] return String . valueOf ( out ) ; } public static boolean isBlank ( String string ) {
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) MST[rv.ROR1Mutator]MSP[S] return false ; } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ROR4Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.ABSMutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
c = string . codePointAt ( i ) ; if ( isActuallyWhitespace ( c ) ) { MST[rv.ROR5Mutator]MSP[N] if ( ( stripLeading && ! reachedNonWhite ) || lastWasWhite ) continue; accum . append ( ' ' ) ; lastWasWhite = true ; }
if ( string == null || string . length () == 0 ) return true ; MST[rv.CRCR3Mutator]MSP[N] int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.CRCR5Mutator]MSP[S]
public static boolean inSorted ( String needle , String [] haystack ) { return Arrays . binarySearch ( haystack , needle ) >= 0 ; MST[RemoveConditionalMutator_ORDER_IF]MSP[S] } public static URL resolve ( URL base , String relUrl ) throws MalformedURLException { if ( relUrl . startsWith ( lr_3 ) )
if ( string == null || string . length () == 0 ) return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[ConditionalsBoundaryMutator]MSP[N]
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { MST[NegateConditionalsMutator]MSP[S] if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; }
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR2Mutator]MSP[N] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[rv.ROR1Mutator]MSP[S]
if ( string == null || string . length () == 0 ) MST[NegateConditionalsMutator]MSP[N] return true ; int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) {
int l = string . length () ; for ( int i = 0 ; i < l ; i ++ ) { if ( ! Character . isDigit ( string . codePointAt ( i ) ) ) return false ; } return true ; MST[rv.CRCR3Mutator]MSP[N] }
relUrl = base . getPath () + relUrl ; if ( relUrl . indexOf ( '.' ) == 0 && base . getFile () . indexOf ( '/' ) != 0 ) { MST[NonVoidMethodCallMutator]MSP[N]
return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160 ; MST[rv.CRCR1Mutator]MSP[S] } public static boolean isInvisibleChar ( int c ) { return c == 8203 || c == 173 ; }
if ( ! StringUtil . isWhitespace ( string . codePointAt ( i ) ) ) return false ; MST[rv.CRCR1Mutator]MSP[N] } return true ; } public static boolean isNumeric ( String string ) { if ( string == null || string . length () == 0 ) return false ;
void read ( Tokeniser t , CharacterReader r ) { switch ( r . current () ) { case '&' : t . advanceTransition ( CharacterReferenceInData ) ; break; case '<' : t . advanceTransition ( TagOpen ) ; break; case nullChar : t . error ( this ) ;
t . emit ( r . consume () ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default: String data = r . consumeData () ; t . emit ( data ) ; break; } }
void read ( Tokeniser t , CharacterReader r ) { readCharRef ( t , Data ) ; } void read ( Tokeniser t , CharacterReader r ) { switch ( r . current () ) { case '&' : t . advanceTransition ( CharacterReferenceInRcdata ) ; break; case '<' :
t . advanceTransition ( RcdataLessthanSign ) ; break; case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default:
String data = r . consumeData () ; t . emit ( data ) ; break; } } void read ( Tokeniser t , CharacterReader r ) { readCharRef ( t , Rcdata ) ; } void read ( Tokeniser t , CharacterReader r ) {
readRawData ( t , r , this , RawtextLessthanSign ) ; } void read ( Tokeniser t , CharacterReader r ) { readRawData ( t , r , this , ScriptDataLessthanSign ) ; } void read ( Tokeniser t , CharacterReader r ) {
switch ( r . current () ) { case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default:
String data = r . consumeTo ( nullChar ) ; t . emit ( data ) ; break; } } void read ( Tokeniser t , CharacterReader r ) { switch ( r . current () ) { case '!' : t . advanceTransition ( MarkupDeclarationOpen ) ; break;
case '/' : t . advanceTransition ( EndTagOpen ) ; break; case '?' : t . createBogusCommentPending () ; t . advanceTransition ( BogusComment ) ; break; default: if ( r . matchesLetter () ) { t . createTagPending ( true ) ; t . transition ( TagName ) ;
} else { t . error ( this ) ; t . emit ( '<' ) ; t . transition ( Data ) ; } break; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) {
t . eofError ( this ) ; t . emit ( lr_1 ) ; t . transition ( Data ) ; } else if ( r . matchesLetter () ) { t . createTagPending ( false ) ; t . transition ( TagName ) ;
} else if ( r . matches ( '>' ) ) { t . error ( this ) ; t . advanceTransition ( Data ) ; } else { t . error ( this ) ; t . createBogusCommentPending () ; t . advanceTransition ( BogusComment ) ; } }
void read ( Tokeniser t , CharacterReader r ) { String tagName = r . consumeTagName () ; t . tagPending . appendTagName ( tagName ) ; char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' :
case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break; case '/' : t . transition ( SelfClosingStartTag ) ; break; case '<' : r . unconsume () ; t . error ( this ) ; case '>' : t . emitTagPending () ;
t . transition ( Data ) ; break; case nullChar : t . tagPending . appendTagName ( replacementStr ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . tagPending . appendTagName ( c ) ; }
} void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . createTempBuffer () ; t . advanceTransition ( RCDATAEndTagOpen ) ;
} else if ( r . matchesLetter () && t . appropriateEndTagName () != null && ! r . containsIgnoreCase ( lr_1 + t . appropriateEndTagName () ) ) { t . tagPending = t . createTagPending ( false ) . name ( t . appropriateEndTagName () ) ;
t . emitTagPending () ; r . unconsume () ; t . transition ( Data ) ; } else { t . emit ( lr_2 ) ; t . transition ( Rcdata ) ; } } void read ( Tokeniser t , CharacterReader r ) {
if ( r . matchesLetter () ) { t . createTagPending ( false ) ; t . tagPending . appendTagName ( r . current () ) ; t . dataBuffer . append ( r . current () ) ; t . advanceTransition ( RCDATAEndTagName ) ; } else {
t . emit ( lr_1 ) ; t . transition ( Rcdata ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) { String name = r . consumeLetterSequence () ;
t . tagPending . appendTagName ( name ) ; t . dataBuffer . append ( name ) ; return; } char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
if ( t . isAppropriateEndTagToken () ) t . transition ( BeforeAttributeName ) ; else anythingElse ( t , r ) ; break; case '/' : if ( t . isAppropriateEndTagToken () ) t . transition ( SelfClosingStartTag ) ; else anythingElse ( t , r ) ; break;
case '>' : if ( t . isAppropriateEndTagToken () ) { t . emitTagPending () ; t . transition ( Data ) ; } else anythingElse ( t , r ) ; break; default: anythingElse ( t , r ) ; } }
private void anythingElse ( Tokeniser t , CharacterReader r ) { t . emit ( lr_1 + t . dataBuffer . toString () ) ; r . unconsume () ; t . transition ( Rcdata ) ; } void read ( Tokeniser t , CharacterReader r ) {
if ( r . matches ( '/' ) ) { t . createTempBuffer () ; t . advanceTransition ( RawtextEndTagOpen ) ; } else { t . emit ( '<' ) ; t . transition ( Rawtext ) ; } }
void read ( Tokeniser t , CharacterReader r ) { readEndTag ( t , r , RawtextEndTagName , Rawtext ) ; } void read ( Tokeniser t , CharacterReader r ) { handleDataEndTag ( t , r , Rawtext ) ; }
void read ( Tokeniser t , CharacterReader r ) { switch ( r . consume () ) { case '/' : t . createTempBuffer () ; t . transition ( ScriptDataEndTagOpen ) ; break; case '!' : t . emit ( lr_3 ) ;
t . transition ( ScriptDataEscapeStart ) ; break; case eof : t . emit ( lr_2 ) ; t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . emit ( lr_2 ) ; r . unconsume () ;
t . transition ( ScriptData ) ; } } void read ( Tokeniser t , CharacterReader r ) { readEndTag ( t , r , ScriptDataEndTagName , ScriptData ) ; } void read ( Tokeniser t , CharacterReader r ) { handleDataEndTag ( t , r , ScriptData ) ;
} void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '-' ) ) { t . emit ( '-' ) ; t . advanceTransition ( ScriptDataEscapeStartDash ) ; } else { t . transition ( ScriptData ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '-' ) ) { t . emit ( '-' ) ; t . advanceTransition ( ScriptDataEscapedDashDash ) ; } else { t . transition ( ScriptData ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ; t . transition ( Data ) ; return; } switch ( r . current () ) { case '-' :
t . emit ( '-' ) ; t . advanceTransition ( ScriptDataEscapedDash ) ; break; case '<' : t . advanceTransition ( ScriptDataEscapedLessthanSign ) ; break; case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; default:
String data = r . consumeToAny ( '-' , '<' , nullChar ) ; t . emit ( data ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ;
t . transition ( Data ) ; return; } char c = r . consume () ; switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( ScriptDataEscapedDashDash ) ; break; case '<' : t . transition ( ScriptDataEscapedLessthanSign ) ;
break; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( ScriptDataEscaped ) ; break; default: t . emit ( c ) ; t . transition ( ScriptDataEscaped ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ; t . transition ( Data ) ; return; } char c = r . consume () ; switch ( c ) { case '-' :
t . emit ( c ) ; break; case '<' : t . transition ( ScriptDataEscapedLessthanSign ) ; break; case '>' : t . emit ( c ) ; t . transition ( ScriptData ) ; break; case nullChar : t . error ( this ) ;
t . emit ( replacementChar ) ; t . transition ( ScriptDataEscaped ) ; break; default: t . emit ( c ) ; t . transition ( ScriptDataEscaped ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) {
t . createTempBuffer () ; t . dataBuffer . append ( r . current () ) ; t . emit ( lr_2 + r . current () ) ; t . advanceTransition ( ScriptDataDoubleEscapeStart ) ; } else if ( r . matches ( '/' ) ) {
t . createTempBuffer () ; t . advanceTransition ( ScriptDataEscapedEndTagOpen ) ; } else { t . emit ( '<' ) ; t . transition ( ScriptDataEscaped ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) {
t . createTagPending ( false ) ; t . tagPending . appendTagName ( r . current () ) ; t . dataBuffer . append ( r . current () ) ; t . advanceTransition ( ScriptDataEscapedEndTagName ) ; } else { t . emit ( lr_1 ) ;
t . transition ( ScriptDataEscaped ) ; } } void read ( Tokeniser t , CharacterReader r ) { handleDataEndTag ( t , r , ScriptDataEscaped ) ; } void read ( Tokeniser t , CharacterReader r ) { handleDataDoubleEscapeTag ( t , r , ScriptDataDoubleEscaped , ScriptDataEscaped ) ;
} void read ( Tokeniser t , CharacterReader r ) { char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedDash ) ; break; case '<' :
t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedLessthanSign ) ; break; case nullChar : t . error ( this ) ; r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . eofError ( this ) ;
t . transition ( Data ) ; break; default: String data = r . consumeToAny ( '-' , '<' , nullChar ) ; t . emit ( data ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ;
switch ( c ) { case '-' : t . emit ( c ) ; t . transition ( ScriptDataDoubleEscapedDashDash ) ; break; case '<' : t . emit ( c ) ; t . transition ( ScriptDataDoubleEscapedLessthanSign ) ; break; case nullChar :
t . error ( this ) ; t . emit ( replacementChar ) ; t . transition ( ScriptDataDoubleEscaped ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . emit ( c ) ;
t . transition ( ScriptDataDoubleEscaped ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' : t . emit ( c ) ; break; case '<' :
t . emit ( c ) ; t . transition ( ScriptDataDoubleEscapedLessthanSign ) ; break; case '>' : t . emit ( c ) ; t . transition ( ScriptData ) ; break; case nullChar : t . error ( this ) ; t . emit ( replacementChar ) ;
t . transition ( ScriptDataDoubleEscaped ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . emit ( c ) ; t . transition ( ScriptDataDoubleEscaped ) ; } }
void read ( Tokeniser t , CharacterReader r ) { if ( r . matches ( '/' ) ) { t . emit ( '/' ) ; t . createTempBuffer () ; t . advanceTransition ( ScriptDataDoubleEscapeEnd ) ; } else { t . transition ( ScriptDataDoubleEscaped ) ; }
} void read ( Tokeniser t , CharacterReader r ) { handleDataDoubleEscapeTag ( t , r , ScriptDataEscaped , ScriptDataDoubleEscaped ) ; } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' :
case '\n' : case '\r' : case '\f' : case ' ' : break; case '/' : t . transition ( SelfClosingStartTag ) ; break; case '<' : r . unconsume () ; t . error ( this ) ; case '>' : t . emitTagPending () ;
t . transition ( Data ) ; break; case nullChar : r . unconsume () ; t . error ( this ) ; t . tagPending . newAttribute () ; t . transition ( AttributeName ) ; break; case eof : t . eofError ( this ) ;
t . transition ( Data ) ; break; case '"' : case '\'' : case '=' : t . error ( this ) ; t . tagPending . newAttribute () ; t . tagPending . appendAttributeName ( c ) ; t . transition ( AttributeName ) ; break; default:
t . tagPending . newAttribute () ; r . unconsume () ; t . transition ( AttributeName ) ; } } void read ( Tokeniser t , CharacterReader r ) { String name = r . consumeToAnySorted ( attributeNameCharsSorted ) ; t . tagPending . appendAttributeName ( name ) ;
char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( AfterAttributeName ) ; break; case '/' : t . transition ( SelfClosingStartTag ) ; break;
case '=' : t . transition ( BeforeAttributeValue ) ; break; case '>' : t . emitTagPending () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeName ( replacementChar ) ; break; case eof :
t . eofError ( this ) ; t . transition ( Data ) ; break; case '"' : case '\'' : case '<' : t . error ( this ) ; t . tagPending . appendAttributeName ( c ) ; break; default:
t . tagPending . appendAttributeName ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
break; case '/' : t . transition ( SelfClosingStartTag ) ; break; case '=' : t . transition ( BeforeAttributeValue ) ; break; case '>' : t . emitTagPending () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ;
t . tagPending . appendAttributeName ( replacementChar ) ; t . transition ( AttributeName ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; case '"' : case '\'' : case '<' :
t . error ( this ) ; t . tagPending . newAttribute () ; t . tagPending . appendAttributeName ( c ) ; t . transition ( AttributeName ) ; break; default: t . tagPending . newAttribute () ; r . unconsume () ;
t . transition ( AttributeName ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break;
case '"' : t . transition ( AttributeValue_doubleQuoted ) ; break; case '&' : r . unconsume () ; t . transition ( AttributeValue_unquoted ) ; break; case '\'' : t . transition ( AttributeValue_singleQuoted ) ; break; case nullChar : t . error ( this ) ;
t . tagPending . appendAttributeValue ( replacementChar ) ; t . transition ( AttributeValue_unquoted ) ; break; case eof : t . eofError ( this ) ; t . emitTagPending () ; t . transition ( Data ) ; break; case '>' : t . error ( this ) ;
t . emitTagPending () ; t . transition ( Data ) ; break; case '<' : case '=' : case '`' : t . error ( this ) ; t . tagPending . appendAttributeValue ( c ) ; t . transition ( AttributeValue_unquoted ) ; break; default:
r . unconsume () ; t . transition ( AttributeValue_unquoted ) ; } } void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAnySorted ( attributeDoubleValueCharsSorted ) ; if ( value . length () > 0 )
t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue () ; char c = r . consume () ; switch ( c ) { case '"' : t . transition ( AfterAttributeValue_quoted ) ; break; case '&' :
int [] ref = t . consumeCharacterReference ( '"' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break; case nullChar : t . error ( this ) ;
t . tagPending . appendAttributeValue ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: t . tagPending . appendAttributeValue ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) {
String value = r . consumeToAnySorted ( attributeSingleValueCharsSorted ) ; if ( value . length () > 0 ) t . tagPending . appendAttributeValue ( value ) ; else t . tagPending . setEmptyAttributeValue () ; char c = r . consume () ; switch ( c ) {
case '\'' : t . transition ( AfterAttributeValue_quoted ) ; break; case '&' : int [] ref = t . consumeCharacterReference ( '\'' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else
t . tagPending . appendAttributeValue ( '&' ) ; break; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default:
t . tagPending . appendAttributeValue ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) { String value = r . consumeToAnySorted ( attributeValueUnquoted ) ; if ( value . length () > 0 ) t . tagPending . appendAttributeValue ( value ) ;
char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break; case '&' :
int [] ref = t . consumeCharacterReference ( '>' , true ) ; if ( ref != null ) t . tagPending . appendAttributeValue ( ref ) ; else t . tagPending . appendAttributeValue ( '&' ) ; break; case '>' : t . emitTagPending () ;
t . transition ( Data ) ; break; case nullChar : t . error ( this ) ; t . tagPending . appendAttributeValue ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; case '"' :
case '\'' : case '<' : case '=' : case '`' : t . error ( this ) ; t . tagPending . appendAttributeValue ( c ) ; break; default: t . tagPending . appendAttributeValue ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeAttributeName ) ; break; case '/' :
t . transition ( SelfClosingStartTag ) ; break; case '>' : t . emitTagPending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: r . unconsume () ;
t . error ( this ) ; t . transition ( BeforeAttributeName ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '>' : t . tagPending . selfClosing = true ;
t . emitTagPending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . transition ( Data ) ; break; default: r . unconsume () ; t . error ( this ) ;
t . transition ( BeforeAttributeName ) ; } } void read ( Tokeniser t , CharacterReader r ) { r . unconsume () ; t . commentPending . data . append ( r . consumeTo ( '>' ) ) ; char next = r . consume () ;
if ( next == '>' || next == eof ) { t . emitCommentPending () ; t . transition ( Data ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchConsume ( lr_4 ) ) { t . createCommentPending () ;
t . transition ( CommentStart ) ; } else if ( r . matchConsumeIgnoreCase ( lr_5 ) ) { t . transition ( Doctype ) ; } else if ( r . matchConsume ( lr_6 ) ) { t . createTempBuffer () ; t . transition ( CdataSection ) ;
} else { t . error ( this ) ; t . createBogusCommentPending () ; t . advanceTransition ( BogusComment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' :
t . transition ( CommentStartDash ) ; break; case nullChar : t . error ( this ) ; t . commentPending . data . append ( replacementChar ) ; t . transition ( Comment ) ; break; case '>' : t . error ( this ) ;
t . emitCommentPending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break; default: t . commentPending . data . append ( c ) ;
t . transition ( Comment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' : t . transition ( CommentStartDash ) ; break; case nullChar :
t . error ( this ) ; t . commentPending . data . append ( replacementChar ) ; t . transition ( Comment ) ; break; case '>' : t . error ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break;
case eof : t . eofError ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break; default: t . commentPending . data . append ( c ) ; t . transition ( Comment ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . current () ; switch ( c ) { case '-' : t . advanceTransition ( CommentEndDash ) ; break; case nullChar : t . error ( this ) ; r . advance () ;
t . commentPending . data . append ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break; default:
t . commentPending . data . append ( r . consumeToAny ( '-' , nullChar ) ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '-' :
t . transition ( CommentEnd ) ; break; case nullChar : t . error ( this ) ; t . commentPending . data . append ( '-' ) . append ( replacementChar ) ; t . transition ( Comment ) ; break; case eof :
t . eofError ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break; default: t . commentPending . data . append ( '-' ) . append ( c ) ; t . transition ( Comment ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '>' : t . emitCommentPending () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ;
t . commentPending . data . append ( lr_4 ) . append ( replacementChar ) ; t . transition ( Comment ) ; break; case '!' : t . error ( this ) ; t . transition ( CommentEndBang ) ; break; case '-' :
t . error ( this ) ; t . commentPending . data . append ( '-' ) ; break; case eof : t . eofError ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break; default: t . error ( this ) ;
t . commentPending . data . append ( lr_4 ) . append ( c ) ; t . transition ( Comment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) {
case '-' : t . commentPending . data . append ( lr_7 ) ; t . transition ( CommentEndDash ) ; break; case '>' : t . emitCommentPending () ; t . transition ( Data ) ; break; case nullChar : t . error ( this ) ;
t . commentPending . data . append ( lr_7 ) . append ( replacementChar ) ; t . transition ( Comment ) ; break; case eof : t . eofError ( this ) ; t . emitCommentPending () ; t . transition ( Data ) ; break; default:
t . commentPending . data . append ( lr_7 ) . append ( c ) ; t . transition ( Comment ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) {
case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BeforeDoctypeName ) ; break; case eof : t . eofError ( this ) ; case '>' : t . error ( this ) ; t . createDoctypePending () ;
t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . transition ( BeforeDoctypeName ) ; } } void read ( Tokeniser t , CharacterReader r ) {
if ( r . matchesLetter () ) { t . createDoctypePending () ; t . transition ( DoctypeName ) ; return; } char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' :
case ' ' : break; case nullChar : t . error ( this ) ; t . createDoctypePending () ; t . doctypePending . name . append ( replacementChar ) ; t . transition ( DoctypeName ) ; break; case eof : t . eofError ( this ) ;
t . createDoctypePending () ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . createDoctypePending () ; t . doctypePending . name . append ( c ) ; t . transition ( DoctypeName ) ;
} } void read ( Tokeniser t , CharacterReader r ) { if ( r . matchesLetter () ) { String name = r . consumeLetterSequence () ; t . doctypePending . name . append ( name ) ; return; } char c = r . consume () ;
switch ( c ) { case '>' : t . emitDoctypePending () ; t . transition ( Data ) ; break; case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( AfterDoctypeName ) ; break; case nullChar :
t . error ( this ) ; t . doctypePending . name . append ( replacementChar ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break;
default: t . doctypePending . name . append ( c ) ; } } void read ( Tokeniser t , CharacterReader r ) { if ( r . isEmpty () ) { t . eofError ( this ) ; t . doctypePending . forceQuirks = true ;
t . emitDoctypePending () ; t . transition ( Data ) ; return; } if ( r . matchesAny ( '\t' , '\n' , '\r' , '\f' , ' ' ) ) r . advance () ; else if ( r . matches ( '>' ) ) {
t . emitDoctypePending () ; t . advanceTransition ( Data ) ; } else if ( r . matchConsumeIgnoreCase ( DocumentType . PUBLIC_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . PUBLIC_KEY ; t . transition ( AfterDoctypePublicKeyword ) ;
} else if ( r . matchConsumeIgnoreCase ( DocumentType . SYSTEM_KEY ) ) { t . doctypePending . pubSysKey = DocumentType . SYSTEM_KEY ; t . transition ( AfterDoctypeSystemKeyword ) ; } else { t . error ( this ) ; t . doctypePending . forceQuirks = true ;
t . advanceTransition ( BogusDoctype ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
t . transition ( BeforeDoctypePublicIdentifier ) ; break; case '"' : t . error ( this ) ; t . transition ( DoctypePublicIdentifier_doubleQuoted ) ; break; case '\'' : t . error ( this ) ; t . transition ( DoctypePublicIdentifier_singleQuoted ) ; break; case '>' :
t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ;
t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . transition ( BogusDoctype ) ; } } void read ( Tokeniser t , CharacterReader r ) {
char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break; case '"' : t . transition ( DoctypePublicIdentifier_doubleQuoted ) ; break; case '\'' :
t . transition ( DoctypePublicIdentifier_singleQuoted ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof : t . eofError ( this ) ;
t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . transition ( BogusDoctype ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '"' : t . transition ( AfterDoctypePublicIdentifier ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . publicIdentifier . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . publicIdentifier . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\'' : t . transition ( AfterDoctypePublicIdentifier ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . publicIdentifier . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . publicIdentifier . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : t . transition ( BetweenDoctypePublicAndSystemIdentifiers ) ; break; case '>' :
t . emitDoctypePending () ; t . transition ( Data ) ; break; case '"' : t . error ( this ) ; t . transition ( DoctypeSystemIdentifier_doubleQuoted ) ; break; case '\'' : t . error ( this ) ; t . transition ( DoctypeSystemIdentifier_singleQuoted ) ; break;
case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ;
t . transition ( BogusDoctype ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break;
case '>' : t . emitDoctypePending () ; t . transition ( Data ) ; break; case '"' : t . error ( this ) ; t . transition ( DoctypeSystemIdentifier_doubleQuoted ) ; break; case '\'' : t . error ( this ) ;
t . transition ( DoctypeSystemIdentifier_singleQuoted ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ;
t . doctypePending . forceQuirks = true ; t . transition ( BogusDoctype ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' :
case '\f' : case ' ' : t . transition ( BeforeDoctypeSystemIdentifier ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case '"' :
t . error ( this ) ; t . transition ( DoctypeSystemIdentifier_doubleQuoted ) ; break; case '\'' : t . error ( this ) ; t . transition ( DoctypeSystemIdentifier_singleQuoted ) ; break; case eof : t . eofError ( this ) ;
t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break; case '"' : t . transition ( DoctypeSystemIdentifier_doubleQuoted ) ;
break; case '\'' : t . transition ( DoctypeSystemIdentifier_singleQuoted ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ; t . doctypePending . forceQuirks = true ;
t . transition ( BogusDoctype ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '"' : t . transition ( AfterDoctypeSystemIdentifier ) ; break; case nullChar :
t . error ( this ) ; t . doctypePending . systemIdentifier . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break;
case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . systemIdentifier . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\'' : t . transition ( AfterDoctypeSystemIdentifier ) ; break; case nullChar : t . error ( this ) ;
t . doctypePending . systemIdentifier . append ( replacementChar ) ; break; case '>' : t . error ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; case eof :
t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . doctypePending . systemIdentifier . append ( c ) ; } }
void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' : break; case '>' : t . emitDoctypePending () ;
t . transition ( Data ) ; break; case eof : t . eofError ( this ) ; t . doctypePending . forceQuirks = true ; t . emitDoctypePending () ; t . transition ( Data ) ; break; default: t . error ( this ) ;
t . transition ( BogusDoctype ) ; } } void read ( Tokeniser t , CharacterReader r ) { char c = r . consume () ; switch ( c ) { case '>' : t . emitDoctypePending () ; t . transition ( Data ) ; break;
case eof : t . emitDoctypePending () ; t . transition ( Data ) ; break; default: break; } } void read ( Tokeniser t , CharacterReader r ) { String data = r . consumeTo ( lr_8 ) ; t . dataBuffer . append ( data ) ;
if ( r . matchConsume ( lr_8 ) || r . isEmpty () ) { t . emit ( new Token . CData ( t . dataBuffer . toString () ) ) ; t . transition ( Data ) ; } }
private static void handleDataEndTag ( Tokeniser t , CharacterReader r , TokeniserState elseTransition ) { if ( r . matchesLetter () ) { String name = r . consumeLetterSequence () ; t . tagPending . appendTagName ( name ) ; t . dataBuffer . append ( name ) ; return;
} boolean needsExitTransition = false ; if ( t . isAppropriateEndTagToken () && ! r . isEmpty () ) { char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' : case '\f' : case ' ' :
t . transition ( BeforeAttributeName ) ; break; case '/' : t . transition ( SelfClosingStartTag ) ; break; case '>' : t . emitTagPending () ; t . transition ( Data ) ; break; default: t . dataBuffer . append ( c ) ; needsExitTransition = true ; }
} else { needsExitTransition = true ; } if ( needsExitTransition ) { t . emit ( lr_1 + t . dataBuffer . toString () ) ; t . transition ( elseTransition ) ; } }
private static void readRawData ( Tokeniser t , CharacterReader r , TokeniserState current , TokeniserState advance ) { switch ( r . current () ) { case '<' : t . advanceTransition ( advance ) ; break; case nullChar : t . error ( current ) ;
r . advance () ; t . emit ( replacementChar ) ; break; case eof : t . emit ( new Token . EOF () ) ; break; default: String data = r . consumeRawData () ; t . emit ( data ) ; break; } }
private static void readCharRef ( Tokeniser t , TokeniserState advance ) { int [] c = t . consumeCharacterReference ( null , false ) ; if ( c == null ) t . emit ( '&' ) ; else t . emit ( c ) ;
t . transition ( advance ) ; } private static void readEndTag ( Tokeniser t , CharacterReader r , TokeniserState a , TokeniserState b ) { if ( r . matchesLetter () ) { t . createTagPending ( false ) ; t . transition ( a ) ;
} else { t . emit ( lr_1 ) ; t . transition ( b ) ; } } private static void handleDataDoubleEscapeTag ( Tokeniser t , CharacterReader r , TokeniserState primary , TokeniserState fallback ) { if ( r . matchesLetter () ) {
String name = r . consumeLetterSequence () ; t . dataBuffer . append ( name ) ; t . emit ( name ) ; return; } char c = r . consume () ; switch ( c ) { case '\t' : case '\n' : case '\r' :
case '\f' : case ' ' : case '/' : case '>' : if ( t . dataBuffer . toString () . equals ( lr_9 ) ) t . transition ( primary ) ; else t . transition ( fallback ) ; t . emit ( c ) ; break;
default: r . unconsume () ; t . transition ( fallback ) ; } }
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.ABSMutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedDash ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI3Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedDash ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI4Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedDash ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI2Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedDash ) ; break; case '<' :
} void read ( Tokeniser t , CharacterReader r ) { MST[rv.UOI1Mutator]MSP[N] char c = r . current () ; switch ( c ) { case '-' : t . emit ( c ) ; t . advanceTransition ( ScriptDataDoubleEscapedDash ) ; break; case '<' :
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; MST[EmptyObjectReturnValsMutator]MSP[N] } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[ConstructorCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[NonVoidMethodCallMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; MST[EmptyObjectReturnValsMutator]MSP[N] } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[experimental.NakedReceiverMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[EmptyObjectReturnValsMutator]MSP[S] }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; MST[ReturnValsMutator]MSP[S] }
public String getMimeType () { return mimeType ; MST[ReturnValsMutator]MSP[N] } public String getUrl () { return url ; } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public String getMimeType () { return mimeType ; } public String getUrl () { return url ; MST[ReturnValsMutator]MSP[N] } @Override public String toString () { return super . toString () + lr_1 + mimeType + lr_2 + url ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
lr_6 , lr_1 , lr_7 , lr_8 , lr_9 , lr_10 , lr_11 , lr_12 , lr_13 , lr_2 , lr_3 , lr_14 , lr_15 , lr_16 , lr_17 , lr_18 , lr_19 , lr_20 , lr_21 , lr_4 , lr_22 , lr_23 , lr_5 , lr_24 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
lr_6 , lr_1 , lr_7 , lr_8 , lr_39 , lr_9 , lr_10 , lr_40 , lr_41 , lr_11 , lr_42 , lr_12 , lr_13 , lr_2 , lr_43 , lr_44 , lr_45 , lr_46 , lr_47 , lr_48 ,
lr_3 , lr_32 , lr_14 , lr_15 , lr_16 , lr_17 , lr_18 , lr_19 , lr_20 , lr_21 , lr_4 , lr_22 , lr_23 , lr_49 , lr_50 , lr_51 , lr_52 , lr_53 , lr_54 , lr_55 , lr_5 , lr_24 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ;
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
if ( this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ;
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) {
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; } public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
protocols . remove ( tagName ) ; } return this ; } protected boolean isSafeTag ( String tag ) { return tagNames . contains ( TagName . valueOf ( tag ) ) ; } protected boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) {
TagName tag = TagName . valueOf ( tagName ) ; AttributeKey key = AttributeKey . valueOf ( attr . getKey () ) ; Set < AttributeKey > okSet = attributes . get ( tag ) ; if ( okSet != null && okSet . contains ( key ) ) {
if ( protocols . containsKey ( tag ) ) { Map < AttributeKey , Set < Protocol > > attrProts = protocols . get ( tag ) ;
return ! attrProts . containsKey ( key ) || testValidProtocol ( el , attr , attrProts . get ( key ) ) ; } else { return true ; } } Map < AttributeKey , AttributeValue > enforcedSet = enforcedAttributes . get ( tag ) ;
if ( enforcedSet != null ) { Attributes expect = getEnforcedAttributes ( tagName ) ; String attrKey = attr . getKey () ; if ( expect . hasKeyIgnoreCase ( attrKey ) ) { return expect . getIgnoreCase ( attrKey ) . equals ( attr . getValue () ) ; }
} return ! tagName . equals ( lr_65 ) && isSafeAttribute ( lr_65 , el , attr ) ; } private boolean testValidProtocol ( Element el , Attribute attr , Set < Protocol > protocols ) { String value = el . absUrl ( attr . getKey () ) ;
if ( value . length () == 0 ) value = attr . getValue () ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ; for ( Protocol protocol : protocols ) { String prot = protocol . toString () ;
if ( prot . equals ( lr_67 ) ) { if ( isValidAnchor ( value ) ) { return true ; } else { continue; } } prot += lr_68 ; if ( lowerCase ( value ) . startsWith ( prot ) ) { return true ; } }
return false ; } private boolean isValidAnchor ( String value ) { return value . startsWith ( lr_67 ) && ! value . matches ( lr_69 ) ; } Attributes getEnforcedAttributes ( String tagName ) { Attributes attrs = new Attributes () ;
TagName tag = TagName . valueOf ( tagName ) ; if ( enforcedAttributes . containsKey ( tag ) ) { Map < AttributeKey , AttributeValue > keyVals = enforcedAttributes . get ( tag ) ;
for ( Map . Entry < AttributeKey , AttributeValue > entry : keyVals . entrySet () ) { attrs . put ( entry . getKey () . toString () , entry . getValue () . toString () ) ; } } return attrs ; }
static TagName valueOf ( String value ) { return new TagName ( value ) ; } static AttributeKey valueOf ( String value ) { return new AttributeKey ( value ) ; } static AttributeValue valueOf ( String value ) { return new AttributeValue ( value ) ; }
static Protocol valueOf ( String value ) { return new Protocol ( value ) ; } @Override public int hashCode () { final int prime = 31 ; int result = 1 ;
result = prime * result + ( ( value == null ) ? 0 : value . hashCode () ) ; return result ; } @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ;
if ( obj == null ) return false ; if ( getClass () != obj . getClass () ) return false ; TypedValue other = ( TypedValue ) obj ; if ( value == null ) { return other . value == null ;
} else return value . equals ( other . value ) ; } @Override public String toString () { return value ; }
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
for ( String protocol : removeProtocols ) { MST[rv.UOI1Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[NegateConditionalsMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ; MST[VoidMethodCallMutator]MSP[S]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
preserveRelativeLinks = preserve ; MST[experimental.MemberVariableMutator]MSP[S] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[experimental.NakedReceiverMutator]MSP[S]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
if ( this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; MST[ArgumentPropagationMutator]MSP[N] }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; MST[NullReturnValsMutator]MSP[N] } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR1Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR6Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[NonVoidMethodCallMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; MST[ArgumentPropagationMutator]MSP[S] if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[NegateConditionalsMutator]MSP[S] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; MST[NullReturnValsMutator]MSP[N] } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
protocols . remove ( tagName ) ; } return this ; MST[ReturnValsMutator]MSP[S] } protected boolean isSafeTag ( String tag ) { return tagNames . contains ( TagName . valueOf ( tag ) ) ; } protected boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) {
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[NegateConditionalsMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
attrMap = this . protocols . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[S] } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
for ( String protocol : removeProtocols ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
for ( String protocol : removeProtocols ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notEmpty ( attribute ) ;
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
preserveRelativeLinks = preserve ; MST[rv.UOI4Mutator]MSP[S] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[S] attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_32 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[NonVoidMethodCallMutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR4Mutator]MSP[N]
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR2Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR4Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR5Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI2Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR4Mutator]MSP[N]
tagNames . add ( TagName . valueOf ( tagName ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR2Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR2Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[InlineConstantMutator]MSP[N] . addTags ( lr_32 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR5Mutator]MSP[S] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; MST[VoidMethodCallMutator]MSP[N] attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[N] for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( protocols ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; MST[NonVoidMethodCallMutator]MSP[N] } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[N] this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR1Mutator]MSP[N]
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR2Mutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ; MST[ConstructorCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
for ( String protocol : removeProtocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR3Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR4Mutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; MST[VoidMethodCallMutator]MSP[N] for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[S] if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[ConditionalsBoundaryMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR4Mutator]MSP[N]
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
attrMap . put ( attrKey , attrVal ) ; MST[ArgumentPropagationMutator]MSP[N] enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
preserveRelativeLinks = preserve ; MST[rv.UOI1Mutator]MSP[N] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR1Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR5Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[S] Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; MST[NonVoidMethodCallMutator]MSP[N] } if ( attrMap . containsKey ( attrKey ) ) {
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; } public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
preserveRelativeLinks = preserve ; return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[NegateConditionalsMutator]MSP[S]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
this . attributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] } if( tag . equals ( lr_65 ) ) for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N]
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR1Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[InlineConstantMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR4Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] } } return this ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; MST[ArgumentPropagationMutator]MSP[N] } if ( attrMap . containsKey ( attrKey ) ) {
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[InlineConstantMutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[S] currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR5Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[NegateConditionalsMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; MST[ArgumentPropagationMutator]MSP[N] } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[InlineConstantMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_6 , lr_25 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR1Mutator]MSP[N]
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR4Mutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR6Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
protSet = attrMap . get ( attrKey ) ; MST[ArgumentPropagationMutator]MSP[S] } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR2Mutator]MSP[S]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI1Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N]
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[NegateConditionalsMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[NonVoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[VoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
attrMap . put ( attrKey , attrVal ) ; MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . put ( tagName , attrMap ) ; } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR5Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; MST[NonVoidMethodCallMutator]MSP[S] } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[experimental.NakedReceiverMutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR4Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR4Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR3Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[S] AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI2Mutator]MSP[S] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if ( this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; MST[NonVoidMethodCallMutator]MSP[N] }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] protocols . remove ( tagName ) ; } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[experimental.NakedReceiverMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[S]
attrMap = this . protocols . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[S] } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) {
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[ReturnValsMutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; MST[NonVoidMethodCallMutator]MSP[S] if( currentSet . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; MST[NonVoidMethodCallMutator]MSP[S] if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR5Mutator]MSP[S]
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[experimental.NakedReceiverMutator]MSP[S] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; MST[NullReturnValsMutator]MSP[N] } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_32 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR2Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR1Mutator]MSP[S] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR3Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; MST[NullReturnValsMutator]MSP[N] } public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[NonVoidMethodCallMutator]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
protocols . remove ( tagName ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } protected boolean isSafeTag ( String tag ) { return tagNames . contains ( TagName . valueOf ( tag ) ) ; } protected boolean isSafeAttribute ( String tagName , Element el , Attribute attr ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ; MST[ArgumentPropagationMutator]MSP[S]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR3Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR2Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[VoidMethodCallMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR1Mutator]MSP[N]
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR2Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) MST[experimental.NakedReceiverMutator]MSP[N] ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[NegateConditionalsMutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
tagNames . add ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[S] Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[NegateConditionalsMutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[rv.ROR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
preserveRelativeLinks = preserve ; MST[rv.UOI3Mutator]MSP[S] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[S] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR5Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
if ( this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
if ( this . attributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[rv.ROR3Mutator]MSP[S] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
Validate . notEmpty ( attribute ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; MST[VoidMethodCallMutator]MSP[N] Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; MST[NonVoidMethodCallMutator]MSP[S] Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[NonVoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI1Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[N] }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) MST[experimental.NakedReceiverMutator]MSP[S] ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; MST[ConstructorCallMutator]MSP[N] } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR3Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[S] if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[S]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
Protocol prot = Protocol . valueOf ( protocol ) ; MST[NonVoidMethodCallMutator]MSP[N] protSet . add ( prot ) ; } return this ; } public Whitelist removeProtocols ( String tag , String attribute , String ... removeProtocols ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[S] for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
preserveRelativeLinks = preserve ; return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; MST[VoidMethodCallMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tagName ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; MST[VoidMethodCallMutator]MSP[N] attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI2Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR6Mutator]MSP[S]
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; MST[VoidMethodCallMutator]MSP[N] attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
if ( this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[S] attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI3Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[NonVoidMethodCallMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; MST[ReturnValsMutator]MSP[N] } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notEmpty ( value ) ; TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; MST[VoidMethodCallMutator]MSP[N] Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR2Mutator]MSP[N]
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[S] Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; MST[NonVoidMethodCallMutator]MSP[N] if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) this . attributes . remove ( name ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist addEnforcedAttribute ( String tag , String attribute , String value ) { Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR5Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR5Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; MST[NonVoidMethodCallMutator]MSP[N] Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) {
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[experimental.NakedReceiverMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; MST[ReturnValsMutator]MSP[S] }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist preserveRelativeLinks ( boolean preserve ) {
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; MST[NullReturnValsMutator]MSP[S] }
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
preserveRelativeLinks = preserve ; MST[rv.ABSMutator]MSP[N] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
preserveRelativeLinks = preserve ; MST[rv.UOI2Mutator]MSP[N] return this ; } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR1Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; MST[ConstructorCallMutator]MSP[N] attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { Validate . notEmpty ( protocol ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR4Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; MST[VoidMethodCallMutator]MSP[N] Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ;
for ( String protocol : removeProtocols ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
Map < AttributeKey , Set < Protocol > > tagProtocols = protocols . get ( tagName ) ; MST[ArgumentPropagationMutator]MSP[S] Validate . isTrue ( tagProtocols . containsKey ( attr ) , lr_66 ) ; Set < Protocol > attrProtocols = tagProtocols . get ( attr ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[NonVoidMethodCallMutator]MSP[S] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
attrMap = this . protocols . get ( tagName ) ; } else { attrMap = new HashMap <> () ; this . protocols . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { MST[rv.ROR4Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[rv.ROR3Mutator]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI4Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR2Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) enforcedAttributes . remove ( tagName ) ; } return this ; MST[ReturnValsMutator]MSP[S] } public Whitelist preserveRelativeLinks ( boolean preserve ) {
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR6Mutator]MSP[N] . addTags ( lr_32 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
preserveRelativeLinks = preserve ; return this ; MST[NullReturnValsMutator]MSP[S] } public Whitelist addProtocols ( String tag , String attribute , String ... protocols ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ; Validate . notNull ( protocols ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; MST[VoidMethodCallMutator]MSP[N] for( String tag : tags ) { Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR2Mutator]MSP[S]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[ConstructorCallMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[rv.ROR3Mutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; MST[ArgumentPropagationMutator]MSP[N] } return this ; } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
for ( String protocol : removeProtocols ) { MST[rv.UOI4Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[experimental.NakedReceiverMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
this . attributes . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] } if( tag . equals ( lr_65 ) ) for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR6Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
for ( String protocol : removeProtocols ) { MST[rv.ABSMutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; MST[NonVoidMethodCallMutator]MSP[S] currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
Validate . notEmpty ( attribute ) ; Validate . notNull ( removeProtocols ) ; MST[VoidMethodCallMutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attr = AttributeKey . valueOf ( attribute ) ; Validate . isTrue ( protocols . containsKey ( tagName ) , lr_66 ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; MST[ArgumentPropagationMutator]MSP[N] } } return this ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR4Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[InlineConstantMutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR2Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) { MST[rv.ROR3Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[NullReturnValsMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N] ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { Validate . notEmpty ( tagName ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR3Mutator]MSP[S]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[rv.CRCR1Mutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[experimental.NakedReceiverMutator]MSP[N] . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.ROR1Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR1Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[NonVoidMethodCallMutator]MSP[N]
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () MST[rv.CRCR3Mutator]MSP[N] . addTags ( lr_32 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[experimental.NakedReceiverMutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR5Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
this . attributes . remove ( tagName ) ; } if( tag . equals ( lr_65 ) ) MST[NonVoidMethodCallMutator]MSP[N] for( TagName name : this . attributes . keySet () ) { Set < AttributeKey > currentSet = this . attributes . get ( name ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR4Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; MST[ReturnValsMutator]MSP[N] } public Whitelist removeEnforcedAttribute ( String tag , String attribute ) { Validate . notEmpty ( tag ) ; Validate . notEmpty ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; MST[NonVoidMethodCallMutator]MSP[N] } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { Validate . notEmpty ( tag ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[rv.CRCR1Mutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
return this ; MST[NullReturnValsMutator]MSP[N] } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( tag ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . protocols . containsKey ( tagName ) ) {
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR2Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
AttributeValue attrVal = AttributeValue . valueOf ( value ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { MST[NegateConditionalsMutator]MSP[N] enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap <> () ;
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR2Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[InlineConstantMutator]MSP[S]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR4Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI2Mutator]MSP[N] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
for ( String protocol : removeProtocols ) { MST[rv.UOI2Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[ReturnValsMutator]MSP[N] . addTags (
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
if ( this . attributes . containsKey ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . attributes . put ( tagName , attributeSet ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR6Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags ( MST[NonVoidMethodCallMutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . remove ( tagName ) ) { MST[rv.ROR1Mutator]MSP[N] attributes . remove ( tagName ) ; enforcedAttributes . remove ( tagName ) ; protocols . remove ( tagName ) ; } } return this ; }
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[InlineConstantMutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
. addProtocols ( lr_18 , lr_9 , lr_27 , lr_28 ) ; } public Whitelist addTags ( String ... tags ) { Validate . notNull ( tags ) ; for ( String tagName : tags ) { MST[rv.ABSMutator]MSP[N] Validate . notEmpty ( tagName ) ;
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[rv.CRCR6Mutator]MSP[N] TagName tagName = TagName . valueOf ( tag ) ;
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR2Mutator]MSP[N]
TagName tagName = TagName . valueOf ( tag ) ; MST[NonVoidMethodCallMutator]MSP[S] Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR1Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR6Mutator]MSP[N]
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
TagName tagName = TagName . valueOf ( tag ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; MST[NonVoidMethodCallMutator]MSP[S] }
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[rv.ROR5Mutator]MSP[S] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if( attrMap . isEmpty () ) MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[N] enforcedAttributes . remove ( tagName ) ; } return this ; } public Whitelist preserveRelativeLinks ( boolean preserve ) {
tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; } public Whitelist removeTags ( String ... tags ) { Validate . notNull ( tags ) ; for( String tag : tags ) { MST[rv.UOI3Mutator]MSP[S] Validate . notEmpty ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 )
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[NonVoidMethodCallMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) MST[rv.CRCR5Mutator]MSP[N] . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 , lr_37 ) MST[InlineConstantMutator]MSP[N] . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 ) MST[rv.CRCR3Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
if( tagNames . contains ( tagName ) && this . attributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] Set < AttributeKey > currentSet = this . attributes . get ( tagName ) ; currentSet . removeAll ( attributeSet ) ; if( currentSet . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR3Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) MST[rv.CRCR3Mutator]MSP[N] . addAttributes ( lr_49 , lr_58 , lr_38 )
public Whitelist addAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; MST[VoidMethodCallMutator]MSP[N] Validate . isTrue ( attributes . length > 0 , lr_64 ) ; TagName tagName = TagName . valueOf ( tag ) ;
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
TagName tagName = TagName . valueOf ( tag ) ; if( tagNames . contains ( tagName ) && enforcedAttributes . containsKey ( tagName ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[N] AttributeKey attrKey = AttributeKey . valueOf ( attribute ) ;
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
return this ; } public Whitelist removeAttributes ( String tag , String ... attributes ) { Validate . notEmpty ( tag ) ; Validate . notNull ( attributes ) ; Validate . isTrue ( attributes . length > 0 , lr_64 ) ; MST[ConditionalsBoundaryMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N] . addAttributes ( lr_41 , lr_20 , lr_38 )
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR1Mutator]MSP[N]
protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet <> () ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : protocols ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( protocol ) ;
. addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addEnforcedAttribute ( lr_6 , lr_30 , lr_31 ) ; } public static Whitelist basicWithImages () { return basic () . addTags ( lr_32 ) MST[rv.CRCR3Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR1Mutator]MSP[N] . addTags (
. addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 ) MST[rv.CRCR3Mutator]MSP[N] . addProtocols ( lr_9 , lr_9 , lr_27 , lr_28 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () . addTags (
tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet <> () ; for ( String key : attributes ) { MST[rv.UOI1Mutator]MSP[N] Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; }
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR5Mutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR6Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR2Mutator]MSP[N]
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () MST[rv.CRCR4Mutator]MSP[N] . addTags (
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addAttributes ( lr_15 , lr_56 , lr_57 ) . addAttributes ( lr_18 , lr_9 ) . addAttributes ( lr_49 , lr_58 , lr_38 ) MST[rv.CRCR6Mutator]MSP[N]
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[rv.CRCR2Mutator]MSP[N] . addTags (
for ( String protocol : removeProtocols ) { MST[rv.UOI1Mutator]MSP[S] Validate . notEmpty ( protocol ) ; attrProtocols . remove ( Protocol . valueOf ( protocol ) ) ; } if ( attrProtocols . isEmpty () ) { tagProtocols . remove ( attr ) ; if ( tagProtocols . isEmpty () )
public static Whitelist none () { return new Whitelist () ; } public static Whitelist simpleText () { return new Whitelist () . addTags ( lr_1 , lr_2 , lr_3 , lr_4 , lr_5 ) ; } public static Whitelist basic () { return new Whitelist () MST[InlineConstantMutator]MSP[N] . addTags (
. addAttributes ( lr_51 , lr_59 , lr_60 , lr_61 , lr_62 , lr_38 ) . addAttributes ( MST[InlineConstantMutator]MSP[N] lr_53 , lr_59 , lr_60 , lr_61 , lr_62 , lr_63 , lr_38 ) . addAttributes ( lr_24 , lr_57 )
. addAttributes ( lr_32 , lr_33 , lr_34 , lr_35 , lr_36 , lr_37 , lr_38 ) . addProtocols ( lr_32 , lr_36 , lr_27 , lr_28 ) ; } public static Whitelist relaxed () { return new Whitelist () . addTags ( MST[InlineConstantMutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR4Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 , lr_37 ) . addAttributes ( lr_7 , lr_9 ) . addAttributes ( lr_40 , lr_20 , lr_38 ) . addAttributes ( lr_41 , lr_20 , lr_38 ) MST[rv.CRCR5Mutator]MSP[N]
. addAttributes ( lr_6 , lr_25 ) . addAttributes ( lr_7 , lr_9 ) MST[rv.CRCR5Mutator]MSP[N] . addAttributes ( lr_18 , lr_9 ) . addProtocols ( lr_6 , lr_25 , lr_26 , lr_27 , lr_28 , lr_29 ) . addProtocols ( lr_7 , lr_9 , lr_27 , lr_28 )
