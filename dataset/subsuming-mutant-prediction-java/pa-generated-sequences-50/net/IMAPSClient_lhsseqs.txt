if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
public boolean execTLS () throws SSLException , IOException { if ( sendCommand ( IMAPCommand . getCommand ( IMAPCommand . STARTTLS ) ) != IMAPReply . OK ) { return false ; } MST[experimental.MemberVariableMutator]MSP[] performSSLNegotiation () ; return true ; } public TrustManager getTrustManager () { return trustManager ; }
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[rv.ROR1Mutator]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[rv.ROR5Mutator]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[rv.ROR3Mutator]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; MST[NonVoidMethodCallMutator]MSP[] } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { MST[NegateConditionalsMutator]MSP[] performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
{ keyManager = newKeyManager ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR5Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR1Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
@Override MST[rv.ROR4Mutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
{ keyManager = newKeyManager ; MST[rv.ROR5Mutator]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; MST[NonVoidMethodCallMutator]MSP[] } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
{ keyManager = newKeyManager ; MST[rv.ROR1Mutator]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[experimental.MemberVariableMutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { MST[rv.ROR5Mutator]MSP[] performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR3Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR5Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
@Override MST[NegateConditionalsMutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
{ keyManager = newKeyManager ; MST[NegateConditionalsMutator]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) { MST[NonVoidMethodCallMutator]MSP[]
socket . startHandshake () ; _socket_ = socket ; MST[NullReturnValsMutator]MSP[] _input_ = socket . getInputStream () ; _output_ = socket . getOutputStream () ; _reader = new CRLFLineReader ( new InputStreamReader ( _input_ , __DEFAULT_ENCODING ) ) ; __writer = new BufferedWriter ( new OutputStreamWriter ( _output_ ,
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[NegateConditionalsMutator]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
@Override MST[rv.ROR2Mutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
socket . startHandshake () ; _socket_ = socket ; MST[ReturnValsMutator]MSP[] _input_ = socket . getInputStream () ; _output_ = socket . getOutputStream () ; _reader = new CRLFLineReader ( new InputStreamReader ( _input_ , __DEFAULT_ENCODING ) ) ; __writer = new BufferedWriter ( new OutputStreamWriter ( _output_ ,
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[VoidMethodCallMutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { MST[experimental.MemberVariableMutator]MSP[] throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[rv.ROR4Mutator]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
if ( _socket_ instanceof SSLSocket ) { return ( ( SSLSocket ) _socket_ ) . getEnabledCipherSuites () ; } return null ; MST[rv.ROR2Mutator]MSP[] } public void setEnabledProtocols ( final String [] protocolVersions ) { protocols = new String [ protocolVersions . length ] ;
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[InlineConstantMutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
{ keyManager = newKeyManager ; MST[rv.ROR4Mutator]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
{ keyManager = newKeyManager ; MST[rv.ROR2Mutator]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
@Override MST[rv.ROR5Mutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR6Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
@Override MST[rv.ROR1Mutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; MST[experimental.MemberVariableMutator]MSP[] } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
{ keyManager = newKeyManager ; } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () MST[experimental.MemberVariableMutator]MSP[] {
@Override MST[experimental.MemberVariableMutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
context = SSLContextUtils . createSSLContext ( protocol , getKeyManager () , getTrustManager () ) ; MST[NonVoidMethodCallMutator]MSP[] } } private void performSSLNegotiation () throws IOException { initSSLContext () ; final SSLSocketFactory ssf = context . getSocketFactory () ;
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR1Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR6Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; MST[NonVoidMethodCallMutator]MSP[] } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
@Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
@Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[rv.CRCR3Mutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
@Override MST[rv.ROR3Mutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
@Override MST[VoidMethodCallMutator]MSP[] protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException { if ( context == null ) {
__DEFAULT_ENCODING ) ) ; if ( hostnameVerifier != null && ! hostnameVerifier . verify ( host , socket . getSession () ) ) { throw new SSLHandshakeException ( lr_1 ) ; } } private KeyManager getKeyManager () MST[InlineConstantMutator]MSP[] { return keyManager ; } public void setKeyManager ( final KeyManager newKeyManager )
{ keyManager = newKeyManager ; MST[rv.ROR3Mutator]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
@Override protected void _connectAction_ () throws IOException { if ( isImplicit ) { performSSLNegotiation () ; } super . _connectAction_ () ; } private void initSSLContext () throws IOException MST[VoidMethodCallMutator]MSP[] { if ( context == null ) {
{ keyManager = newKeyManager ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public void setEnabledCipherSuites ( final String [] cipherSuites ) { suites = new String [ cipherSuites . length ] ; System . arraycopy ( cipherSuites , 0 , suites , 0 , cipherSuites . length ) ; } public String [] getEnabledCipherSuites () {
