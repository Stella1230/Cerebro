} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI3Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[rv.ROR1Mutator]MSP[] final int off = factvalue . length () - 3 ;
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[rv.ROR5Mutator]MSP[] final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR1Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
file . setName ( entry . substring ( 1 ) ) ; return file ; MST[NullReturnValsMutator]MSP[] } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[NegateConditionalsMutator]MSP[] file . setType ( intType . intValue () ) ; } }
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.UOI1Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI2Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { MST[rv.CRCR2Mutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[NonVoidMethodCallMutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[NonVoidMethodCallMutator]MSP[] }
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; MST[rv.CRCR3Mutator]MSP[] final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[InlineConstantMutator]MSP[]
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR4Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI2Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[NonVoidMethodCallMutator]MSP[]
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[ConditionalsBoundaryMutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; MST[NegateConditionalsMutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR1Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR5Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR3Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.ROR4Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[rv.CRCR3Mutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; MST[rv.CRCR5Mutator]MSP[] }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR2Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.CRCR4Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.UOI2Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI3Mutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR5Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[RemoveConditionalMutator_ORDER_IF]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; MST[rv.CRCR1Mutator]MSP[] }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[InlineConstantMutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { MST[rv.CRCR4Mutator]MSP[] continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR3Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( factparts . length != 2 ) { return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; MST[experimental.NakedReceiverMutator]MSP[] } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[InlineConstantMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.UOI1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
file . setName ( entry . substring ( 1 ) ) ; MST[rv.CRCR3Mutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI3Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[rv.CRCR6Mutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.ABSMutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[rv.ROR3Mutator]MSP[] }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.CRCR3Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.ROR2Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( factparts . length != 2 ) { MST[NonVoidMethodCallMutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
@Override MST[rv.AOR1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
} else if ( lr_11 . equals ( unixfact ) ) { MST[rv.ROR1Mutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
} else if ( lr_11 . equals ( unixfact ) ) { MST[rv.ROR5Mutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ABSMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR3Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.UOI3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[RemoveConditionalMutator_ORDER_IF]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[InlineConstantMutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
file . setName ( entry . substring ( 1 ) ) ; return file ; } return null ; MST[ReturnValsMutator]MSP[] } final String parts [] = entry . split ( lr_1 , 2 ) ;
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[rv.ROR2Mutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[rv.ROR4Mutator]MSP[] }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ABSMutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.ABSMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[MathMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int off = factvalue . length () - 3 ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; MST[VoidMethodCallMutator]MSP[] } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[ConditionalsBoundaryMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { MST[rv.CRCR6Mutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI4Mutator]MSP[]
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { file . setType ( intType . intValue () ) ; MST[ArgumentPropagationMutator]MSP[] } }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR6Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override MST[rv.UOI1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[NonVoidMethodCallMutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI3Mutator]MSP[]
for( int i = 0 ; i < 3 ; i ++ ) { MST[NegateConditionalsMutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.ABSMutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[]
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR3Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[InlineConstantMutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
@Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[rv.CRCR2Mutator]MSP[]
@Override MST[rv.ROR1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI3Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[NullReturnValsMutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR3Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI2Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR6Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override MST[rv.UOI3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[rv.ROR3Mutator]MSP[] }
file . setName ( entry . substring ( 1 ) ) ; MST[InlineConstantMutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
@Override MST[ReturnValsMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; MST[ConstructorCallMutator]MSP[] } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[rv.ROR2Mutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] }
@Override MST[rv.UOI1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.CRCR5Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
} else if ( lr_11 . equals ( unixfact ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[ConditionalsBoundaryMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; MST[experimental.NakedReceiverMutator]MSP[] } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
@Override MST[rv.AOD2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[InlineConstantMutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( lr_8 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; MST[rv.CRCR4Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; MST[NonVoidMethodCallMutator]MSP[] } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR2Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[rv.ROR2Mutator]MSP[] }
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[rv.ROR5Mutator]MSP[] file . setType ( intType . intValue () ) ; } }
for( int i = 0 ; i < 3 ; i ++ ) { MST[rv.ROR4Mutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; MST[NonVoidMethodCallMutator]MSP[] for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[NonVoidMethodCallMutator]MSP[] }
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[rv.ROR2Mutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { MST[rv.CRCR5Mutator]MSP[] return null ; }
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[NonVoidMethodCallMutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR2Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
file . setName ( entry . substring ( 1 ) ) ; MST[VoidMethodCallMutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
@Override MST[rv.CRCR6Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR1Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.ROR3Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; MST[rv.ROR5Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[rv.CRCR3Mutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[NegateConditionalsMutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.AOD2Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[rv.CRCR4Mutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.CRCR2Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[rv.ROR2Mutator]MSP[] }
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[rv.ROR3Mutator]MSP[]
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[NonVoidMethodCallMutator]MSP[] }
@Override MST[rv.UOI4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.UOI2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[rv.ROR4Mutator]MSP[] final int off = factvalue . length () - 3 ;
if ( factparts . length != 2 ) { MST[rv.CRCR5Mutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
if ( factparts . length != 2 ) { MST[rv.CRCR1Mutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
else if ( factname . startsWith ( lr_9 ) ) { final String unixfact = factname . substring ( lr_9 . length () ) . toLowerCase ( Locale . ENGLISH ) ; MST[NonVoidMethodCallMutator]MSP[] if ( lr_10 . equals ( unixfact ) ) { file . setGroup ( factvalue ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR3Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[rv.ROR5Mutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[rv.ROR1Mutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[ConditionalsBoundaryMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[NonVoidMethodCallMutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[experimental.RemoveIncrementsMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[rv.CRCR2Mutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[rv.CRCR6Mutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( factparts . length != 2 ) { return null ; MST[rv.ROR4Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
@Override MST[MathMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( int i = 0 ; i < 3 ; i ++ ) { MST[rv.ROR3Mutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
return PARSER . parseFTPEntry ( entry ) ; } public static MLSxEntryParser getInstance () { return PARSER ; MST[NullReturnValsMutator]MSP[] }
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[rv.CRCR3Mutator]MSP[]
@Override MST[rv.ABSMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI1Mutator]MSP[]
@Override MST[rv.UOI2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI3Mutator]MSP[]
@Override MST[rv.UOI4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR1Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; MST[rv.CRCR3Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[experimental.NakedReceiverMutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; MST[ConstructorCallMutator]MSP[] final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.CRCR2Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.CRCR6Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.ROR3Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.CRCR3Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[rv.ROR1Mutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
for( int i = 0 ; i < 3 ; i ++ ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[rv.ROR4Mutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[rv.ROR5Mutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; MST[InlineConstantMutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR2Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR2Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[rv.CRCR6Mutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[NonVoidMethodCallMutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
@Override MST[NegateConditionalsMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[rv.ROR4Mutator]MSP[] file . setType ( intType . intValue () ) ; } }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR5Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.ROR3Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.ABSMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.UOI2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { file . setType ( intType . intValue () ) ; MST[NonVoidMethodCallMutator]MSP[] } }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[rv.ROR1Mutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
file . setName ( entry . substring ( 1 ) ) ; MST[rv.CRCR6Mutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[rv.CRCR1Mutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[rv.CRCR5Mutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
@Override MST[rv.UOI4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
file . setName ( entry . substring ( 1 ) ) ; MST[rv.CRCR2Mutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
@Override MST[rv.CRCR4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR4Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[VoidMethodCallMutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.AOR1Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.CRCR6Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.ROR4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[InlineConstantMutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[rv.CRCR3Mutator]MSP[]
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; MST[InlineConstantMutator]MSP[] final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
@Override MST[rv.AOR1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI1Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.ROR5Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[MathMutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR2Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI4Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.CRCR5Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[VoidMethodCallMutator]MSP[]
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[rv.ROR1Mutator]MSP[] }
@Override MST[rv.UOI1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[VoidMethodCallMutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.ROR2Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
} else if ( lr_11 . equals ( unixfact ) ) { MST[NegateConditionalsMutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[InlineConstantMutator]MSP[]
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR3Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[rv.ROR3Mutator]MSP[] file . setType ( intType . intValue () ) ; } }
@Override MST[rv.ABSMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR6Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.CRCR1Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.UOI3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[rv.ROR2Mutator]MSP[]
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[experimental.NakedReceiverMutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
@Override MST[rv.CRCR3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI1Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[IncrementsMutator]MSP[]
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[rv.ROR3Mutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[rv.ROR2Mutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[rv.ROR1Mutator]MSP[] }
@Override MST[rv.AOR2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
} else if ( lr_11 . equals ( unixfact ) ) { MST[rv.ROR4Mutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ABSMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] file . setType ( intType . intValue () ) ; } }
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[NegateConditionalsMutator]MSP[] final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR1Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR4Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR5Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override MST[rv.UOI1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; MST[rv.CRCR6Mutator]MSP[] }
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { MST[rv.CRCR3Mutator]MSP[] continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR5Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { MST[InlineConstantMutator]MSP[] continue; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[rv.ROR2Mutator]MSP[] }
@Override MST[rv.UOI3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
file . setName ( entry . substring ( 1 ) ) ; MST[experimental.NakedReceiverMutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI1Mutator]MSP[]
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[rv.ROR3Mutator]MSP[] final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI1Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI4Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[NegateConditionalsMutator]MSP[] }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR3Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { MST[rv.CRCR4Mutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; MST[rv.CRCR5Mutator]MSP[] final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[NegateConditionalsMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR2Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override MST[NonVoidMethodCallMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI4Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; MST[rv.CRCR1Mutator]MSP[] final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[NegateConditionalsMutator]MSP[] }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[rv.CRCR1Mutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR1Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override MST[InlineConstantMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR3Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int off = factvalue . length () - 3 ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.CRCR6Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.UOI4Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[rv.CRCR5Mutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; MST[rv.CRCR3Mutator]MSP[] }
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; MST[ConstructorCallMutator]MSP[] }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR5Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR1Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.UOI3Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; MST[ConstructorCallMutator]MSP[] file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.AOD1Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR4Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR5Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.ROR2Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { MST[rv.CRCR2Mutator]MSP[] continue; }
if ( factparts . length != 2 ) { return null ; MST[rv.CRCR6Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
@Override MST[rv.UOI3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[VoidMethodCallMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI1Mutator]MSP[]
file . setName ( entry . substring ( 1 ) ) ; MST[rv.CRCR5Mutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
if ( factparts . length != 2 ) { return null ; MST[rv.CRCR2Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
@Override MST[rv.AOD1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { MST[rv.CRCR6Mutator]MSP[] continue; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI4Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[ReturnValsMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.CRCR2Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; MST[rv.ROR3Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] file . setType ( intType . intValue () ) ; } }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { MST[rv.CRCR3Mutator]MSP[] return null ; }
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; MST[ReturnValsMutator]MSP[] } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
@Override MST[NonVoidMethodCallMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[rv.ROR4Mutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[rv.ROR1Mutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[rv.ROR5Mutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
} else if ( lr_11 . equals ( unixfact ) ) { MST[NonVoidMethodCallMutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[rv.CRCR1Mutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
return PARSER . parseFTPEntry ( entry ) ; } public static MLSxEntryParser getInstance () { return PARSER ; MST[ReturnValsMutator]MSP[] }
@Override MST[rv.UOI2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[NegateConditionalsMutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
@Override MST[rv.CRCR4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[rv.CRCR5Mutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.ROR1Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.ROR5Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[rv.CRCR2Mutator]MSP[]
for( int i = 0 ; i < 3 ; i ++ ) { MST[rv.ROR2Mutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
final ParsePosition pos = new ParsePosition ( 0 ) ; MST[NonVoidMethodCallMutator]MSP[] sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; }
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[rv.CRCR6Mutator]MSP[]
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[NonVoidMethodCallMutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { MST[NonVoidMethodCallMutator]MSP[] file . setSize ( Long . parseLong ( factvalue ) ) ; }
if ( factparts . length != 2 ) { return null ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[rv.ROR5Mutator]MSP[]
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[rv.ROR1Mutator]MSP[]
@Override MST[ReturnValsMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.ROR5Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.AOR2Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR5Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR1Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR6Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.CRCR5Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.CRCR4Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[]
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[InlineConstantMutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[NonVoidMethodCallMutator]MSP[] final int off = factvalue . length () - 3 ;
@Override MST[rv.AOR2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; MST[NonVoidMethodCallMutator]MSP[] if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[rv.CRCR4Mutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI2Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[rv.CRCR1Mutator]MSP[]
@Override MST[rv.ROR3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[NegateConditionalsMutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR3Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { MST[InlineConstantMutator]MSP[] return null ; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI3Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.ABSMutator]MSP[]
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[ReturnValsMutator]MSP[]
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[rv.ROR4Mutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR4Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override MST[rv.UOI2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.CRCR3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; MST[VoidMethodCallMutator]MSP[]
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { MST[VoidMethodCallMutator]MSP[] file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { file . setType ( intType . intValue () ) ; } }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[InlineConstantMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[rv.ROR1Mutator]MSP[] }
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[rv.ROR5Mutator]MSP[] }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR1Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR4Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[NegateConditionalsMutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI2Mutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI1Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[rv.ROR5Mutator]MSP[] }
if ( factparts . length != 2 ) { return null ; MST[rv.CRCR1Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI2Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { MST[experimental.NakedReceiverMutator]MSP[] file . setSize ( Long . parseLong ( factvalue ) ) ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[NegateConditionalsMutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.ROR4Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.CRCR5Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
else if ( factname . startsWith ( lr_9 ) ) { final String unixfact = factname . substring ( lr_9 . length () ) . toLowerCase ( Locale . ENGLISH ) ; MST[VoidMethodCallMutator]MSP[] if ( lr_10 . equals ( unixfact ) ) { file . setGroup ( factvalue ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.ROR1Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( factparts . length != 2 ) { return null ; MST[rv.ROR2Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
@Override MST[rv.AOR3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.CRCR1Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
} else if ( lr_11 . equals ( unixfact ) ) { MST[rv.ROR3Mutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[rv.ROR3Mutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR5Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[rv.ROR4Mutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
for( final int p : UNIX_PERMS [ ch ] ) { MST[NonVoidMethodCallMutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.UOI3Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.UOI3Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.UOI4Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.ROR1Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[rv.ROR2Mutator]MSP[] file . setType ( intType . intValue () ) ; } }
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; MST[VoidMethodCallMutator]MSP[] if ( pos . getIndex () != timestamp . length () ) { return null ; }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { MST[NonVoidMethodCallMutator]MSP[] final String [] factparts = fact . split ( lr_4 , - 1 ) ;
} else if ( lr_11 . equals ( unixfact ) ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[NegateConditionalsMutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[InlineConstantMutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[NonVoidMethodCallMutator]MSP[] file . setType ( intType . intValue () ) ; } }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI2Mutator]MSP[]
@Override MST[rv.CRCR2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI1Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI2Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI4Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
} else if ( lr_11 . equals ( unixfact ) ) { file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { MST[rv.ROR2Mutator]MSP[] final int off = factvalue . length () - 3 ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI3Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.UOI2Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override MST[NegateConditionalsMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI1Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR1Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; MST[rv.CRCR6Mutator]MSP[] final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI3Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[NegateConditionalsMutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[RemoveConditionalMutator_ORDER_IF]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[rv.ROR3Mutator]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
file . setName ( entry . substring ( 1 ) ) ; return file ; MST[ReturnValsMutator]MSP[] } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR5Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[rv.CRCR4Mutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; MST[ConstructorCallMutator]MSP[] file . setRawListing ( entry ) ;
for( int i = 0 ; i < 3 ; i ++ ) { MST[rv.ROR1Mutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { MST[NonVoidMethodCallMutator]MSP[] return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; final String [] facts = factList . split ( lr_2 ) ; MST[rv.CRCR5Mutator]MSP[]
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
file . setName ( entry . substring ( 1 ) ) ; MST[NonVoidMethodCallMutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
@Override MST[VoidMethodCallMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[rv.ROR4Mutator]MSP[] }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI4Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( int i = 0 ; i < 3 ; i ++ ) { MST[rv.ROR5Mutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[InlineConstantMutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.ABSMutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI3Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.ABSMutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.AOR4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[NegateConditionalsMutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { MST[rv.CRCR6Mutator]MSP[] return null ; }
} else if ( lr_11 . equals ( unixfact ) ) { MST[rv.ROR2Mutator]MSP[] file . setUser ( factvalue ) ; } else if ( lr_12 . equals ( unixfact ) ) { final int off = factvalue . length () - 3 ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { MST[NonVoidMethodCallMutator]MSP[] gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) {
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[rv.ROR5Mutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR4Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[InlineConstantMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[NegateConditionalsMutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.UOI1Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[NegateConditionalsMutator]MSP[] }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR2Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR6Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override MST[NonVoidMethodCallMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR6Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.UOI1Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) {
for( int i = 0 ; i < 3 ; i ++ ) { MST[NonVoidMethodCallMutator]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR3Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[rv.ROR4Mutator]MSP[] }
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { MST[rv.CRCR5Mutator]MSP[] continue; }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI4Mutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.AOR4Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[NonVoidMethodCallMutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.AOR3Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR2Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.ABSMutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { return null ; MST[InlineConstantMutator]MSP[] }
@Override MST[rv.AOD1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.AOD2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[NegateConditionalsMutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.ROR2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.AOR4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[rv.CRCR5Mutator]MSP[]
@Override MST[rv.AOR3Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI4Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR4Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override MST[rv.CRCR2Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
gc . setTime ( parsed ) ; if ( ! hasMillis ) { gc . clear ( Calendar . MILLISECOND ) ; } return gc ; } private void doUnixPerms ( final FTPFile file , final String valueLowerCase ) { MST[rv.CRCR6Mutator]MSP[]
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.CRCR2Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.ROR5Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.UOI1Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[NonVoidMethodCallMutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override MST[rv.UOI4Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[NegateConditionalsMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.ABSMutator]MSP[]
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { MST[InlineConstantMutator]MSP[] return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.ROR4Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
else if ( lr_7 . equals ( factname ) ) { final Calendar parsed = parseGMTdateTime ( factvalue ) ; if ( parsed == null ) { return null ; } file . setTimestamp ( parsed ) ; } else if ( lr_8 . equals ( factname ) ) { MST[ReturnValsMutator]MSP[]
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; MST[rv.ROR5Mutator]MSP[] }
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[NegateConditionalsMutator]MSP[]
final Integer intType = TYPE_TO_INT . get ( valueLowerCase ) ; if ( intType == null ) { file . setType ( FTPFile . UNKNOWN_TYPE ) ; } else { MST[rv.ROR1Mutator]MSP[] file . setType ( intType . intValue () ) ; } }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.CRCR5Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override MST[NegateConditionalsMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[rv.CRCR3Mutator]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
for( int i = 0 ; i < 3 ; i ++ ) { final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) { MST[rv.ROR4Mutator]MSP[]
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[rv.ROR3Mutator]MSP[] }
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.UOI4Mutator]MSP[]
@Override MST[rv.CRCR1Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.UOI2Mutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
final String valueLowerCase = factvalue . toLowerCase ( Locale . ENGLISH ) ; if ( lr_5 . equals ( factname ) || lr_6 . equals ( factname ) ) { file . setSize ( Long . parseLong ( factvalue ) ) ; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } MST[rv.ABSMutator]MSP[] } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( factparts . length != 2 ) { return null ; MST[rv.CRCR5Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[rv.CRCR3Mutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; } public static Calendar parseGMTdateTime ( final String timestamp ) { MST[rv.ROR5Mutator]MSP[] final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
if ( factparts . length != 2 ) { return null ; MST[rv.ROR1Mutator]MSP[] } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; }
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.CRCR4Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
@Override MST[rv.ABSMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; if ( factvalue . length () == 0 ) { continue; MST[RemoveConditionalMutator_EQUAL_IF]MSP[] }
hasMillis = true ; } else { sdf = new SimpleDateFormat ( lr_16 ) ; MST[NonVoidMethodCallMutator]MSP[] hasMillis = false ; } final TimeZone GMT = TimeZone . getTimeZone ( lr_17 ) ; sdf . setTimeZone ( GMT ) ; final GregorianCalendar gc = new GregorianCalendar ( GMT ) ;
final ParsePosition pos = new ParsePosition ( 0 ) ; sdf . setLenient ( false ) ; final Date parsed = sdf . parse ( timestamp , pos ) ; if ( pos . getIndex () != timestamp . length () ) { MST[ConstructorCallMutator]MSP[] return null ; }
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { MST[rv.CRCR1Mutator]MSP[] return null ; }
for( int i = 0 ; i < 3 ; i ++ ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int ch = factvalue . charAt ( off + i ) - '0' ; if ( ch >= 0 && ch <= 7 ) {
final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ; file . setName ( parts [ 1 ] ) ; MST[VoidMethodCallMutator]MSP[] final String [] facts = factList . split ( lr_2 ) ;
@Override MST[rv.ROR5Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
return PARSER . parseFTPEntry ( entry ) ; } public static MLSxEntryParser getInstance () { return PARSER ; MST[NonVoidMethodCallMutator]MSP[] }
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[NegateConditionalsMutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
final boolean hasUnixMode = parts [ 0 ] . toLowerCase ( Locale . ENGLISH ) . contains ( lr_3 ) ; for( final String fact : facts ) { final String [] factparts = fact . split ( lr_4 , - 1 ) ; MST[rv.ABSMutator]MSP[]
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { MST[rv.ROR5Mutator]MSP[] final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { MST[rv.CRCR5Mutator]MSP[] file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
doUnixPerms ( file , valueLowerCase ) ; } } return file ; MST[rv.ROR4Mutator]MSP[] } public static Calendar parseGMTdateTime ( final String timestamp ) { final SimpleDateFormat sdf ; final boolean hasMillis ; if ( timestamp . contains ( lr_14 ) ) { sdf = new SimpleDateFormat ( lr_15 ) ;
@Override MST[rv.ABSMutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[InlineConstantMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
if ( parts . length != 2 || parts [ 1 ] . length () == 0 ) { return null ; MST[rv.ROR4Mutator]MSP[] } final String factList = parts [ 0 ] ; if ( ! factList . endsWith ( lr_2 ) ) { return null ; }
file . setName ( entry . substring ( 1 ) ) ; MST[rv.CRCR4Mutator]MSP[] return file ; } return null ; } final String parts [] = entry . split ( lr_1 , 2 ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[rv.CRCR3Mutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; } } else { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
@Override public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { MST[rv.ROR3Mutator]MSP[] if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
if ( factparts . length != 2 ) { return null ; } final String factname = factparts [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; final String factvalue = factparts [ 1 ] ; MST[InlineConstantMutator]MSP[] if ( factvalue . length () == 0 ) { continue; }
@Override MST[rv.CRCR6Mutator]MSP[] public FTPFile parseFTPEntry ( final String entry ) { if ( entry . startsWith ( lr_1 ) ) { if ( entry . length () > 1 ) { final FTPFile file = new FTPFile () ; file . setRawListing ( entry ) ;
for( final int p : UNIX_PERMS [ ch ] ) { file . setPermission ( UNIX_GROUPS [ i ] , p , true ) ; MST[IncrementsMutator]MSP[] } } else { } } } } else if ( ! hasUnixMode && lr_13 . equals ( factname ) ) {
