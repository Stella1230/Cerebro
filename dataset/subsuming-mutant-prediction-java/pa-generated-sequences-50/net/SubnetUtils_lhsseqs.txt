return str . toString () ; } @Override MST[rv.CRCR5Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR2Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI2Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI3Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[] if ( value >= begin && value <= end ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR2Mutator]MSP[]
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR5Mutator]MSP[] final StringBuilder str = new StringBuilder () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI4Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI3Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR4Mutator]MSP[]
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI1Mutator]MSP[] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR4Mutator]MSP[]
return str . toString () ; } @Override MST[ReturnValsMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR1Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR5Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI3Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[ArgumentPropagationMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI3Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return str . toString () ; } @Override MST[rv.CRCR1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; MST[NonVoidMethodCallMutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } MST[experimental.NakedReceiverMutator]MSP[] private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR3Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.OBBN2Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[InlineConstantMutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOD1Mutator]MSP[] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI3Mutator]MSP[]
return str . toString () ; } @Override MST[InlineConstantMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } MST[rv.ROR2Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR6Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR6Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR1Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI4Mutator]MSP[] } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR4Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR1Mutator]MSP[] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[] if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.OBBN2Mutator]MSP[]
private int [] toArray ( final int val ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI4Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR1Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return str . toString () ; } @Override MST[rv.AOD1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[NegateConditionalsMutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR6Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[rv.CRCR4Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR4Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.UOI1Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.ABSMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.MemberVariableMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; MST[rv.UOI3Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[rv.ROR3Mutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[rv.ROR5Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.ABSMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR4Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[InlineConstantMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR5Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR3Mutator]MSP[] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR4Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.ABSMutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOR3Mutator]MSP[]
return str . toString () ; } @Override MST[NullReturnValsMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.ABSMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[ArgumentPropagationMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI4Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR6Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[ConstructorCallMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.OBBN3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI4Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI2Mutator]MSP[] int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR2Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[NegateConditionalsMutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR1Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.NakedReceiverMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR5Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOD2Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.ABSMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR4Mutator]MSP[] if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR1Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOD1Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[InlineConstantMutator]MSP[] final StringBuilder str = new StringBuilder () ;
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.ABSMutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
private int [] toArray ( final int val ) { MST[NonVoidMethodCallMutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[InlineConstantMutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR3Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR3Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR1Mutator]MSP[] int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[InlineConstantMutator]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI3Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR6Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI1Mutator]MSP[] } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR3Mutator]MSP[] int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR3Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[MathMutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[InlineConstantMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI3Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI1Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[ReturnValsMutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR4Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOD2Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[experimental.NakedReceiverMutator]MSP[] if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI3Mutator]MSP[]
return str . toString () ; } @Override MST[MathMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR2Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR6Mutator]MSP[]
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR5Mutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
return buf . toString () ; MST[rv.UOI1Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI4Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.ABSMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return str . toString () ; } @Override MST[rv.CRCR6Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ABSMutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.ABSMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return str . toString () ; } @Override MST[rv.AOD2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI4Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR1Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR5Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[experimental.MemberVariableMutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[] if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOD1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[MathMutator]MSP[] int addr = 0 ;
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[NonVoidMethodCallMutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR4Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[MathMutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI1Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI3Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR4Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR2Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI2Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI1Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[ConstructorCallMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI3Mutator]MSP[] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR3Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[ReturnValsMutator]MSP[] if ( value >= begin && value <= end ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[ConstructorCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR4Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOD1Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI1Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR5Mutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[InlineConstantMutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.NakedReceiverMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[InlineConstantMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.CRCR6Mutator]MSP[]
return str . toString () ; } @Override MST[rv.OBBN2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR4Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI1Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR5Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } MST[rv.AOR3Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR3Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } MST[rv.ABSMutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR3Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR5Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI2Mutator]MSP[] } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR1Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[rv.CRCR4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
private int [] toArray ( final int val ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR1Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR3Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[InlineConstantMutator]MSP[]
return str . toString () ; } @Override MST[MathMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.OBBN2Mutator]MSP[]
return str . toString () ; } @Override MST[rv.AOR4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[] if ( matcher . matches () ) {
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR3Mutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[InlineConstantMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
private int [] toArray ( final int val ) { MST[rv.ROR1Mutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR6Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[experimental.NakedReceiverMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR5Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOD2Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI2Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR1Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.ABSMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOD1Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI1Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ABSMutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[] if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.OBBN1Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return buf . toString () ; } MST[rv.AOD2Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } MST[NegateConditionalsMutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR2Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI2Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR5Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.CRCR2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI2Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.OBBN2Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI2Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI4Mutator]MSP[] int addr = 0 ;
return str . toString () ; } @Override MST[rv.AOR1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.AOR3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[InlineConstantMutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[InlineConstantMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR5Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR6Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[InlineConstantMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR4Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI4Mutator]MSP[]
return buf . toString () ; } MST[rv.ROR3Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI4Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.ABSMutator]MSP[] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[MathMutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR5Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.OBBN1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[InlineConstantMutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI4Mutator]MSP[]
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.UOI4Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR6Mutator]MSP[]
return buf . toString () ; MST[rv.UOI3Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[rv.ROR4Mutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR1Mutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR5Mutator]MSP[] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR1Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.OBBN1Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR3Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.OBBN1Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI4Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR1Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI3Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[MathMutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.ABSMutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR6Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return str . toString () ; } @Override MST[rv.AOR2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } MST[rv.CRCR2Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[ConditionalsBoundaryMutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[] if ( matcher . matches () ) {
return buf . toString () ; MST[rv.ABSMutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR2Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[InlineConstantMutator]MSP[]
private int [] toArray ( final int val ) { MST[ReturnValsMutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR2Mutator]MSP[] if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI4Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[experimental.MemberVariableMutator]MSP[]
return str . toString () ; } @Override MST[rv.CRCR3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[MathMutator]MSP[]
return str . toString () ; } @Override MST[rv.UOI1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR5Mutator]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR6Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[InlineConstantMutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
private int [] toArray ( final int val ) { MST[NonVoidMethodCallMutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[PrimitiveReturnsMutator]MSP[] } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[EmptyObjectReturnValsMutator]MSP[] if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI3Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[experimental.MemberVariableMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR3Mutator]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI1Mutator]MSP[]
return buf . toString () ; } MST[rv.AOR1Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[MathMutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI1Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR4Mutator]MSP[]
return buf . toString () ; MST[rv.UOI4Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI1Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return str . toString () ; } @Override MST[rv.CRCR1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR4Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[ConstructorCallMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR1Mutator]MSP[] final StringBuilder str = new StringBuilder () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI3Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOR2Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[MathMutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI3Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI4Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[] if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[ConditionalsBoundaryMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR6Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR5Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR2Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[] if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR3Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR3Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.OBBN1Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[experimental.NakedReceiverMutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI3Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.ABSMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; MST[rv.UOI2Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR5Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.OBBN3Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR2Mutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR2Mutator]MSP[] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR5Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.CRCR6Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI1Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.OBBN3Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI4Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.CRCR3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR5Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR4Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR4Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; MST[NonVoidMethodCallMutator]MSP[] return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[RemoveConditionalMutator_ORDER_IF]MSP[]
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR1Mutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOD2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR3Mutator]MSP[] if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI3Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI2Mutator]MSP[]
return str . toString () ; } @Override MST[rv.CRCR2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[InlineConstantMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; MST[experimental.NakedReceiverMutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.CRCR4Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } MST[NonVoidMethodCallMutator]MSP[] private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI1Mutator]MSP[]
return str . toString () ; } @Override MST[rv.AOD1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI2Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI4Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR5Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR6Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.ROR1Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR2Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR1Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI3Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI1Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI4Mutator]MSP[]
return str . toString () ; } @Override MST[rv.CRCR6Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI4Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) MST[ConstructorCallMutator]MSP[] . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI4Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR1Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.ABSMutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[InlineConstantMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR4Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[rv.AOR4Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI4Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI2Mutator]MSP[] if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR5Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[] if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[] if ( matcher . matches () ) {
return buf . toString () ; } MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_IF]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.ABSMutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR6Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[InlineConstantMutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI2Mutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR2Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[InlineConstantMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[NonVoidMethodCallMutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.OBBN1Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[MathMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[experimental.NakedReceiverMutator]MSP[]
return str . toString () ; } @Override MST[rv.UOI3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[PrimitiveReturnsMutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI2Mutator]MSP[] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR5Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[ConditionalsBoundaryMutator]MSP[] if ( matcher . matches () ) {
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR4Mutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[NegateConditionalsMutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR4Mutator]MSP[] if ( matcher . matches () ) {
return buf . toString () ; } MST[rv.UOI3Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[MathMutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR5Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[IncrementsMutator]MSP[]
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.AOD2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[MathMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR4Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR2Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR2Mutator]MSP[] int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR4Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR3Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.OBBN3Mutator]MSP[]
return buf . toString () ; } MST[rv.ROR1Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR6Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI1Mutator]MSP[] if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[MathMutator]MSP[] int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[InlineConstantMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } MST[rv.AOD1Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR5Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI1Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.ABSMutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR1Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR6Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[NonVoidMethodCallMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.UOI3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[MathMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.OBBN3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[experimental.NakedReceiverMutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ROR3Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI1Mutator]MSP[] int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[InlineConstantMutator]MSP[] int addr = 0 ;
return buf . toString () ; } MST[rv.CRCR5Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; MST[rv.UOI1Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI4Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR4Mutator]MSP[]
private int [] toArray ( final int val ) { MST[rv.ROR2Mutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI4Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI1Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR6Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR3Mutator]MSP[]
return buf . toString () ; } MST[InlineConstantMutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return str . toString () ; } @Override MST[rv.CRCR3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.ABSMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[InlineConstantMutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR3Mutator]MSP[] final StringBuilder str = new StringBuilder () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI1Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI3Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOR4Mutator]MSP[]
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[ConstructorCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR2Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR6Mutator]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.UOI2Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[MathMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
return buf . toString () ; MST[rv.UOI4Mutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[NegateConditionalsMutator]MSP[] if ( matcher . matches () ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI1Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR1Mutator]MSP[] if ( matcher . matches () ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[MathMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.ABSMutator]MSP[] } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.AOD2Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[MathMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.UOI2Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI3Mutator]MSP[] int addr = 0 ;
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.OBBN1Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[NonVoidMethodCallMutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[MathMutator]MSP[]
return str . toString () ; } @Override MST[rv.AOR4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR4Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR3Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[] if ( value >= begin && value <= end ) {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI3Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[InlineConstantMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[ReturnValsMutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR4Mutator]MSP[] int addr = 0 ;
return buf . toString () ; } MST[rv.UOI1Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.OBBN2Mutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.CRCR2Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI2Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI3Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.UOI2Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ABSMutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.UOI3Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[ReturnValsMutator]MSP[] } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return str . toString () ; } @Override MST[rv.OBBN2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return str . toString () ; } @Override MST[rv.UOI3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.CRCR2Mutator]MSP[]
return buf . toString () ; } MST[rv.CRCR6Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[ArgumentPropagationMutator]MSP[] if ( value >= begin && value <= end ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR2Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[ConditionalsBoundaryMutator]MSP[] if ( matcher . matches () ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR3Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI4Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.OBBN3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[ConditionalsBoundaryMutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.ABSMutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[InlineConstantMutator]MSP[]
return str . toString () ; } @Override MST[MathMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[PrimitiveReturnsMutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.OBBN3Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return str . toString () ; } @Override MST[rv.AOR1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[] if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR4Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ROR5Mutator]MSP[] if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[PrimitiveReturnsMutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOR3Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.AOR1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.ABSMutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) { MST[rv.UOI2Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.UOI2Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.UOI2Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.ABSMutator]MSP[] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[experimental.NakedReceiverMutator]MSP[] if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[MathMutator]MSP[]
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[ConstructorCallMutator]MSP[] if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI3Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
return buf . toString () ; } MST[MathMutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; MST[rv.UOI1Mutator]MSP[] } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.CRCR5Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.UOI2Mutator]MSP[]
return str . toString () ; } @Override MST[rv.OBBN1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.ABSMutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.ABSMutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.UOI2Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return buf . toString () ; } MST[rv.AOR2Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR3Mutator]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR5Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR1Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR6Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { MST[rv.OBBN2Mutator]MSP[] final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) {
private int [] toArray ( final int val ) { final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { MST[ConstructorCallMutator]MSP[]
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.ROR3Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.CRCR2Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.UOI2Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { MST[rv.CRCR1Mutator]MSP[] str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN2Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return buf . toString () ; } MST[RemoveConditionalMutator_EQUAL_IF]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[InlineConstantMutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.UOI1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
return str . toString () ; } @Override MST[rv.CRCR4Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.CRCR2Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOD2Mutator]MSP[] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI2Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[rv.AOR3Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return buf . toString () ; } MST[rv.CRCR3Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
private int [] toArray ( final int val ) { MST[NegateConditionalsMutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { int addr = 0 ; MST[rv.AOR2Mutator]MSP[]
return str . toString () ; } @Override MST[rv.CRCR5Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.CRCR6Mutator]MSP[] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; MST[rv.UOI3Mutator]MSP[] } }
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.AOR4Mutator]MSP[] int addr = 0 ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOD1Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.AOR2Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
return str . toString () ; } @Override MST[rv.UOI1Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.ABSMutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[experimental.NakedReceiverMutator]MSP[] if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { MST[rv.OBBN1Mutator]MSP[] final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ;
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.AOR4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[InlineConstantMutator]MSP[]
return str . toString () ; } @Override MST[rv.UOI2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[MathMutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
private int [] toArray ( final int val ) { MST[rv.ROR5Mutator]MSP[] final int ret [] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) {
return buf . toString () ; MST[rv.ABSMutator]MSP[] } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR6Mutator]MSP[]
return format ( toArray ( address ) ) + lr_2 + pop ( netmask ) ; } public String [] getAllAddresses () { final int ct = getAddressCount () ; final String [] addresses = new String [ ct ] ; if ( ct == 0 ) { MST[rv.UOI3Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR5Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { MST[NonVoidMethodCallMutator]MSP[] if ( value >= begin && value <= end ) {
return buf . toString () ; } MST[rv.ROR4Mutator]MSP[] public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches () ) {
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { final StringBuilder str = new StringBuilder () ; MST[rv.CRCR4Mutator]MSP[]
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.AOD1Mutator]MSP[]
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR1Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[rv.CRCR1Mutator]MSP[]
return matchAddress ( matcher ) ; } throw new IllegalArgumentException ( String . format ( PARSE_FAIL , address ) ) ; } private static int matchAddress ( final Matcher matcher ) { MST[rv.UOI4Mutator]MSP[] int addr = 0 ;
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; MST[rv.UOI1Mutator]MSP[] } return addr ; } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
addr |= ( n & 0xff ) << 8 * ( 4 - i ) ; } return addr ; MST[rv.OBBN3Mutator]MSP[] } private static int rangeCheck ( final int value , final int begin , final int end ) { if ( value >= begin && value <= end ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.ABSMutator]MSP[]
ret [ j ] |= val >>> 8 * ( 3 - j ) & 0xff ; } return ret ; } private String format ( final int [] octets ) { MST[rv.CRCR6Mutator]MSP[] final StringBuilder str = new StringBuilder () ;
return str . toString () ; } @Override MST[rv.AOR2Mutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { return toInteger ( address ) ; } public String getCidrSignature () { MST[rv.OBBN3Mutator]MSP[]
return str . toString () ; } @Override MST[InlineConstantMutator]MSP[] public String toString () { final StringBuilder buf = new StringBuilder () ; buf . append ( lr_4 ) . append ( getCidrSignature () ) . append ( lr_5 )
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR5Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
final long count = b - n + ( isInclusiveHostCount () ? 1 : - 1 ) ; return count < 0 ? 0 : count ; } public int asInteger ( final String address ) { MST[rv.CRCR6Mutator]MSP[] return toInteger ( address ) ; } public String getCidrSignature () {
throw new RuntimeException ( lr_1 + countLong ) ; } return ( int ) countLong ; } public long getAddressCountLong () { MST[rv.ROR2Mutator]MSP[] final long b = broadcastLong () ; final long n = networkLong () ;
. append ( lr_10 ) . append ( getLowAddress () ) . append ( lr_7 ) . append ( lr_11 ) . append ( getHighAddress () ) . append ( lr_7 ) . append ( lr_12 ) . append ( getAddressCount () ) . append ( lr_7 ) ; MST[NegateConditionalsMutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.UOI4Mutator]MSP[] if ( matcher . matches () ) {
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR6Mutator]MSP[]
for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; MST[rv.CRCR4Mutator]MSP[] if ( i != octets . length - 1 ) { str . append ( lr_3 ) ; } }
for ( int i = 1 ; i <= 4 ; ++ i ) { final int n = rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , 0 , 255 ) ; MST[rv.CRCR5Mutator]MSP[]
return buf . toString () ; } public final SubnetInfo getInfo () { return new SubnetInfo () ; } private static int toInteger ( final String address ) { final Matcher matcher = addressPattern . matcher ( address ) ; MST[rv.ABSMutator]MSP[] if ( matcher . matches () ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[NegateConditionalsMutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR3Mutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[NegateConditionalsMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI1Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( broadcast ) ) ; MST[rv.ABSMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( broadcast ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[ArgumentPropagationMutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[]
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR2Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_IF]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR5Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[NegateConditionalsMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[ReturnValsMutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[ConditionalsBoundaryMutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[PrimitiveReturnsMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[ReturnValsMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getHighAddress () { return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { MST[rv.CRCR5Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NegateConditionalsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR4Mutator]MSP[]
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI4Mutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[InlineConstantMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[NegateConditionalsMutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR5Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI3Mutator]MSP[]
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[RemoveConditionalMutator_ORDER_IF]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ConditionalsBoundaryMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR5Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[ConditionalsBoundaryMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR4Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR5Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI4Mutator]MSP[]
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[NonVoidMethodCallMutator]MSP[] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[BooleanFalseReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[PrimitiveReturnsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { MST[ReturnValsMutator]MSP[] return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR1Mutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR6Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR2Mutator]MSP[]
return format ( toArray ( broadcast ) ) ; MST[ConstructorCallMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { MST[ReturnValsMutator]MSP[] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR3Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[rv.UOI2Mutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[ReturnValsMutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[NonVoidMethodCallMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[ReturnValsMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { MST[rv.CRCR5Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR1Mutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.ROR5Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR3Mutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR6Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR4Mutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { MST[NonVoidMethodCallMutator]MSP[] return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NegateConditionalsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ABSMutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR6Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[MathMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR5Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR5Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ABSMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI1Mutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[NonVoidMethodCallMutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NegateConditionalsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI4Mutator]MSP[]
public boolean isInclusiveHostCount () { MST[ReturnValsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.AOR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { MST[PrimitiveReturnsMutator]MSP[] return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[EmptyObjectReturnValsMutator]MSP[] return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ConditionalsBoundaryMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[ReturnValsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[NegateConditionalsMutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; MST[NonVoidMethodCallMutator]MSP[] } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI1Mutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR5Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[rv.UOI3Mutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR5Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[InlineConstantMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR5Mutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[NonVoidMethodCallMutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI2Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR6Mutator]MSP[]
private int low () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { MST[rv.CRCR1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR2Mutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[EmptyObjectReturnValsMutator]MSP[] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[ConditionalsBoundaryMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_ORDER_ELSE]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[ConstructorCallMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[NonVoidMethodCallMutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI3Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR5Mutator]MSP[]
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR1Mutator]MSP[]
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR4Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
broadcastLong () - networkLong () > 1 ? broadcast - 1 : 0 ; } public boolean isInRange ( final String address ) { MST[ReturnValsMutator]MSP[] return isInRange ( toInteger ( address ) ) ; } public boolean isInRange ( final int address ) { if ( address == 0 ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.ABSMutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { MST[rv.ROR4Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[PrimitiveReturnsMutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { MST[EmptyObjectReturnValsMutator]MSP[] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_ORDER_IF]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR3Mutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR6Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR4Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[RemoveConditionalMutator_EQUAL_ELSE]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.ABSMutator]MSP[]
private int low () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.ROR4Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; MST[rv.UOI4Mutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { MST[MathMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NegateConditionalsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI1Mutator]MSP[]
public boolean isInclusiveHostCount () { MST[rv.AOR4Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[InlineConstantMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR1Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI2Mutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI4Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[NullReturnValsMutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[PrimitiveReturnsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.UOI3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[NonVoidMethodCallMutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () { MST[NonVoidMethodCallMutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOD2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI2Mutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[InlineConstantMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR5Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[ReturnValsMutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[ReturnValsMutator]MSP[] return isInclusiveHostCount () ? broadcast :
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR6Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ABSMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.CRCR5Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[rv.CRCR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ABSMutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI4Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.ROR5Mutator]MSP[]
public boolean isInclusiveHostCount () { MST[rv.AOR4Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.AOD2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[EmptyObjectReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[ReturnValsMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[EmptyObjectReturnValsMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[RemoveConditionalMutator_ORDER_IF]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[RemoveConditionalMutator_EQUAL_IF]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[ReturnValsMutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.UOI4Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.CRCR4Mutator]MSP[]
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[BooleanTrueReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( low () ) ) ; } public String getHighAddress () { MST[rv.ROR1Mutator]MSP[] return format ( toArray ( high () ) ) ; } @Deprecated public int getAddressCount () { final long countLong = getAddressCountLong () ; if ( countLong > Integer . MAX_VALUE ) {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[MathMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { MST[InlineConstantMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[NonVoidMethodCallMutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR3Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[InlineConstantMutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return false ; } final long addLong = address & UNSIGNED_INT_MASK ; final long lowLong = low () & UNSIGNED_INT_MASK ; final long highLong = high () & UNSIGNED_INT_MASK ; return addLong >= lowLong && addLong <= highLong ; } public String getBroadcastAddress () { MST[rv.UOI2Mutator]MSP[]
public boolean isInclusiveHostCount () { MST[rv.AOR1Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.ROR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[InlineConstantMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR6Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( broadcast ) ) ; } public String getNetworkAddress () { MST[rv.UOI3Mutator]MSP[] return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( broadcast ) ) ; MST[rv.UOI1Mutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[MathMutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[BooleanTrueReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.CRCR3Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { MST[rv.ROR2Mutator]MSP[] this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
private int low () { return isInclusiveHostCount () ? network : broadcastLong () - networkLong () > 1 ? network + 1 : 0 ; } private int high () { MST[NonVoidMethodCallMutator]MSP[] return isInclusiveHostCount () ? broadcast :
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[NonVoidMethodCallMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI2Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( broadcast ) ) ; MST[experimental.NakedReceiverMutator]MSP[] } public String getNetworkAddress () { return format ( toArray ( network ) ) ; } public String getNetmask () { return format ( toArray ( netmask ) ) ; } public String getAddress () {
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[ReturnValsMutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } MST[rv.ROR2Mutator]MSP[] private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.CRCR2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
public boolean isInclusiveHostCount () { MST[rv.ROR2Mutator]MSP[] return inclusiveHostCount ; } public void setInclusiveHostCount ( final boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; } private long networkLong () { return network & UNSIGNED_INT_MASK ; } private long broadcastLong () { return broadcast & UNSIGNED_INT_MASK ; }
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.AOR1Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[EmptyObjectReturnValsMutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () { MST[rv.UOI3Mutator]MSP[]
return format ( toArray ( address ) ) ; } public String getNextAddress () { MST[rv.UOI3Mutator]MSP[] return format ( toArray ( address + 1 ) ) ; } public String getPreviousAddress () { return format ( toArray ( address - 1 ) ) ; } public String getLowAddress () {
